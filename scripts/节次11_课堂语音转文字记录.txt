00:16是是是是一嗯，我就党性继续呃，我们上节课讲到对吧？那么为了让这个这个开发人员，比如开发微微信端的这个开发者者，更好的去理解他这个存的数据会发生什么情况，
05:46对吧？我们的这个 system 的 infrax 团队，就是说去真正的实现存这些数据的这样的一个开发人员。他们需要去定这个 appappiction develop 定义清楚啊，一个叫 consistence model。就是说什么样的这个数据，
06:00它能够在满足应用的需求的前提下啊出尽可能的会变得这样的一个。那么对于微信来说的话，它其实这样的一个或也或类微信啊，或不是不是不是什么特别应用。就对于类类微信的这样的一个程序来说的话，它其实只需要一个很很简单的这样一个性质。
06:18就是啊我的这个中间的不一致可以暴露给用户，只要你的这个每个 rewrite 互换。然后呢，但是我最终啊当我每一个服务器对吧的，每每设设备都收到了这个相同的消息之后，对吧？
06:29我最好最好只能给用户去呈现一个一致的这样的一个聊天记录啊。但是我们说什么呃什么叫做一致的聊天记录？我们我们听听说它是一个一样的就一模一样的对吧？那肯定是最致，就是他们的消息呈现的顺序是一样的。但是里边其实有有个很大的问题，
06:45就是说第一我们怎么去保证它是一样的，对吧？第二就是说我到底一样可以，那我这么多消息息开那么多牌子合，我到底哪一种给用户呈现的是最好的，然后我们系统还排起来能实现现，
06:57那这其实里面是有些讲究的，所以呢我们就先来看一下，对吧？假设我们想要让消息变成一样啊，所有设备的消息，假设他们收到的是段都是一样的。
07:08 reright 的操作是一样的话，那是否能变成一样？那这个我觉得相对来说还是比较容易去实现的对吧？大家大家想想，我们先看看为什么会出现不一样。那不一样的原因是什么呢？
07:20不一样的原因无非就是这个我原本有一个两个这个这个两个手手机。然后呢，他这个我们微信为了容我们这个聊天记录呃， APP 容错对吧？我们把这个数据存在两个服务器上 OK。然后呢，
07:35我比如说我要发第一个消息， pos 第一个消息之后，我只能联系到第一台服务器啊，为了为了满足可能性，那我就让原用户访回就表明 OK 我这个消息成功了。那么他在本地啊这个这个这个更新了一下，
07:49发现它的这个这个这个这个消息里面第一条是十 x 然后呢另一台另一台另一台设备对吧？它跟前一台设备一样啊，只不过它只能连接到服务器二。好，那这个时候呢它的这个里面的第一条消息就就变成了这个这个这个 y 对吧？这个时候就就是这样的一个 y 然后如果我们这样给用户去呈现，
08:12我们交换了一下这个 think 之后，我们会发现它的这样的一个这个这个这个这个原本的这个消息啊，它是不一样，对吧？因为 x 的话呃，因为因为站在这个个人的角度来说，
08:21它是 x 在先 y 在后，对吧？如果你去做一个同步的话，你会发现它是 y 在前 x 在后。如果我们去直接以一种 appad 的方式去把同步过来的这个消息给 apply 到这个数据上，对吧？
08:32但是这这个是肯定是会有问题的。所以我们在 think 的时候，我们不能够简单的把这个消息给 append 到这个当前的这个 list 上，对不对？因为这样的话啊，它虽然每个 server 它收到的这个消息是一样的，
08:48但是啊它的这个顺序是不一样。所以说这两个聊天记录相对来说就乱序的啊，虽然有时候微微信可能也会出现这种情况的，但基基本上是很少的。那么怎么去解决这个问题呢？其实这个问题非常容易解决，
09:00我们发现如果消息不一样，那我们如果我们我们又知道哪些信，我们又知道我们收到哪些消息，那我们按照一个确定性的顺序给它排序，然后再重新 apply 一下不就可以了吗？不就可以了吗？
09:14对吧？比如说我在这个这个这个这个这个这个这个这个我在每个 pt 这边啊，我有我除了自己展示的这样的一个消息之外呢，我还会维护一个这个 log 这个 log 在记录着我自己发的这个消息，以及从这个其他机器收到的消息。然后呢，
09:33我每收到一个消息之后呢，我除了更新这个这个这个这个这个这个前端，对吧？我还得什么，我还得先把这个消息放到每个人自己的这个 log OK。那么假设我 siink 完之后，
09:46我每个 server 收到了所有的之后，我按照某一种顺序对吧？我们把这个 log 啊去排序。比如说我们这边的顺序就是 x 在前 y 在后。然后我们有了这个顺序之后啊，我们再把它给重新更新回这样的一个这个这个这个这个这个这个这个这个这个显示的这样的列表里边，
10:07这个东西它不就能够保证。就虽然我一开始对吧这个可能这个大家看到的消息不全，对吧？但是当我经过一次这个消息同步之后，对吧，我们两个人显示的这个数据都都完成了，
10:20对吧？这很简单，对吧？我们就这样就实现完这个 image on 自的资源。当然里面还有一些小的细节需要处理。比如说我们一开始这个这个这这边对吧？
10:31这边的这个这个 count 二这边看看 t 二这边的话，他给用户先展示的是 y 在前。然后然后他收到了一个 x 他叫是他选派这个这个这个的顺序和之前的这个其实不大一样的吧。之前是 y 在 y 在前， x 在后啊，其实它没有 x 然后他收到的这个消息实际上是要是要把 x 插入到 y 在前，
10:51那这时候怎么办呢？其实很简单，对吧？我们只需要把这个同步的时候，对吧？我们如果发现这个消息的这个前缀啊和当前展示的这个绘制，
11:00我们把这个这个这个这个当前四万二的这个所有消息都回滚。就我把它把这个 list，直接从从一个空的状态，然后再按照这个 log 的这个顺序去重新 apply 的这样的一个操作。那么大家想想这样呢之后，我这样派之后，
11:16其实我把这个擦掉，对吧？我重新 appapply，这样我不就是能够最终最终这个看点量，这这呈呈细致致了。对，
11:23把一个非常简单的这样的一个操作，我就解决。第一个问题，就是说我的这个 apppad log 的时候，对吧？两者的这个初始，
11:30这这样一个个状是不不一样 OK。然后第二个我们其实解讲，其实其实到大家看到这里为止，我们其实已经实现了一个 eventual consistence 的系统了。对吧？就非常非常简单。
11:41那么大家其实想一想，我们这个这个这个里面的难点在哪？其实它最大的核心的难点，不不是说难点吧，就是说你需要考虑的难点，就是我们保证一致性的前提是什么？
11:53是我们在每台机器里面我们会按照一个顺序，对于所有的操作进行排序，对不对？那么我们问题就在在我到底是是按哪一种顺序排序，这个其实对于你的这个用户体验是影响非常非常大的。家想想，
12:08如果是你来设计这样的一个 eventual 斯 consic 系统，然后我们这个这个这个这个这个这个这个这个我们要我们要要排序，我们会用什么东西来排序。但是啊我们消息理论上来说，我们如果是作为一个 check 的这样的一个 APP，对吧？
12:23那么我理想上来说，我的这个消息的顺序应该是取决于什么？它应该是它应该最好是这个跟我们的这个第一它那个排序要满足两个要求啊，第一个就是要求是我两者对吧？最终排完序肯定得一样，对吧？
12:38这是 election 考试要求。第二个就是我这个消息对吧？它基本上要满足我这个事件发生的顺序，对吧？最好是我先发的。这个消息应该是在我最后呈现在这个这个这个这个这个 log 里面，
12:50应该在更前面，对不对？不然的话，我这个消息就跟我的这个时持续发生是不一样的。所以所以我们其实一个很自然的思想，就是说我们在真实世界中，
13:01我们怎么去判断发生事件的先后呢？我们其实用的是时钟，对不对？那么在计算系统里面，我们这个判断的方法也是一样，我们也可以用这个时钟。
13:11比如说我们的电脑上会，如果是你是 linux 啊，你是对吧？有那个 passidemmer，对我可以在每发生一个事件上获得这样的一个时钟。那么大家想想，
13:21我们能不能直接用时钟来作为我们的排序手段的。因为时钟它其实是一个很 intuitive 的这个假。比如说它理论上来说，我们只要手机这个时钟是定期啊，是定期跟这个全球全球活去全部的话，那么大概是上了我们的时间是差不多的对吧？
13:36如果时间上发生上更早的这样的消息，理论上它就应该有个更小的这个时钟的这个时间戳，对不对？那大家想想我们又 linux 的对吧？就 get time time day 去去为这个的排序，能不能作为它的这个排序呢？
13:52我其实告诉大家，它其实是不能作为这个排序的，为什么呢？为什么大家想想我们这个 evenvenconconstlinux 的这个时间戳，它本质是什么？它本质上是一个整数，
14:02对吧？它就是个六十四位的整数，它表达的什么？表达的是你自从某个时间点之后发生了多少秒，对不对？那它是有整数，
14:10它就会有一个什么问题，就是我不同的这个 server，对吧？他打给这个服务器打上的这给这个事件打上的这样的一个时间戳，可能会出现相同的情况，对不对？
14:23那如果我两个操作的时间戳是相同的，然后我在收到这些消息之后，我再用他们的这个相同的时间戳去排序，会出现很大的一个情况。他们排序出来的结果可能会也是会不一样，对吧？
14:35不管你是用一些啊我们说算法里面有那种稳定的排序，算法也好，不稳定的排序算法也好。如果你是稳定的排序算法的话，如果他们一开始啊在 log 里面的顺序是不一样，那你最后排出来的也是不一样。
14:46如果你是不稳定的这个排序算法，就是你你排序其实会不同的。 t 啊，它啊相同的 t 它的位置可能会乱掉的话，那你这个根本就没法很很难去推导它。最后会不会一样？
14:56对不？所以我们其实会发现，如果我们要用时钟这个点去排序的话，第一他显然他他不能够很很直呼他虽然能体现啊大概体现我们事件发生的这个相对顺序，但是它其实并不能啊很好的去实现这个圆球 consenstces。那这个问题怎么解决呢？
15:15其实这个 PT 已经讲了，对吧？其实解决方法很简单，那我如果两个时钟相相呃时间戳相同，那么他们如果是呃我们要区分它的话，它其实本质上是什么？
15:24是，如果说呃不不就如果我们两个事件它的时钟相同，那如果这两个事件是在一台 server 上的，大家想想这个事件可能会出现吗？其实不大可能会出现。为什么？
15:34因为我们如果在一台机器上，我们只需要实现一个很简单的机器，就是我们每每记录每获取的时间重给本地的这个呃 linux 记的时间戳加一。对，那其实就可以在一台机器上去，就把这两个时间戳区分开。
15:47因为比较麻烦的什么就是我我果归两台机器，对吧？如果这两台机器，它的时间戳是是是一样的怎么办？我怎么区分啊？其实很简单，
15:56因为我们在分布式里面，一般来说我们每个每个设备，每个数据存储的设备，它其实都有什么，都有个 server ID，对吧？
16:02那我其实就可以用这个时间 t 当和这个 server ID，对吧？这两者我作为一个限作为向量时钟，向量时钟，然后我去把它这个作为一个时间错了，其实就可以了。
16:15那么这个向量时用怎么比呢？其实我先要比较的什么，先要比较的是说我先看一下他们的这个时这个这个先按照第一项，就是时间排序啊排序了。如果他们时间相同的话，我再按 server ID 都的 ID，
16:28第二个去排序。那这样的话我就能够实现什么呢？就是我的这个最我首先我所有的人都能够啊排出一个比较稳定的这样的一个这个这个这个顺序都是一样的。以及第二个就是我的这个事件的顺序，对吧？大概是符合这样所间。
16:44所以说我们说你要排序很重要的一点就是要先确定时间戳，确定时间戳。但是我们说我们现在这样的一个时间戳，对吧？这个是不是这不急啊，就解决了，
16:55对吧？比如说我们第一个问题我们就回答了，就是说我们不能够用这个这个简单的使用这个 give time day 啊返回的这样的一个时间。当实现说那其实我们说这个你要实现一万之款三的时间，你光有这个这个这个这个 time t 啊和这个 note ID 是不同的啊，是不一样的。
17:14比如说我们可大家可以思考这两个问题啊，比如说第二个问题，我们前面讲这个排序的时候，是我们说尽可能的你要先去比较这个 t 然后再去比较这个这个这个这个这个 ID，为什么我不能反着来？我们先先要比较这个我们我们先比较 ID 再比较 t 呢，
17:31知道吧？那这个是第二种方法。大家想如果我们用第二种方法呢去排序的话，它会出现什么问题啊？它其实会出现就是我某一台设备的这个消息，一定是在另一台设备的这个消息前面，
17:43对吧？那大家想这个显然是不符合我们的这个用聊天记录的这样的一个这个这个这个这个这个这个这个这个这个频率啊。因为我们聊天记录的话，一般来说我我发一个消息，你你基于我这个消息去做这样的一个这个另一步频率吧。所以说我们不能够简单的用 note II，
17:59这叫 tam t 去做这样的一个问题。那么大家看这个背背后本质上他取他取他他背后其实讲的什么，他其实背后讲的是你这个数据啊，你最后光光是 eventiticonconstcy 其实不够的。因为你的这个不同的顺序，它对于用户的这个体验是不一样。
18:19比如说你如果是用 node ID 作为一个 primary key 去做这个排序的话，你会发现一台设备的消息永远在另一台设备前，那这肯定是不不好，对吧？那么那么我们前面说你一个 time key，就是我们先以时间来排序，
18:31能解决这个问题。但是它会不会引入新的这样的一个问题呢？比如说我们最早讲的一个例子，对吧？我们最早讲的一个例子是说一个人他的这个这个消息啊是说先啊先出现了这个就是先出现引用 five a 的这个消息，在文件在在这个发送 five a 之前这样的情况，
18:52这个其实是反拒绝的。因为我们的一个实的恰应该是先有文件再引用发消息的。那么大家想想，我们如果最后我们的这个系统排序出来的消息是呃请看文件 chareference 这个 five AA 先先，然后再再再出现这个 i 那那么大家想这个对于用户体验来说实也是不好的，对不对？
19:11我们在微信上其实很少会看到这样一种情况，对不对？那么这个本质上，首先大家想想，我们在这个用这个机器的始钟啊，就是这样的个 MT note ID 这样的一个一个一个一个 pare 的这种方式去作为使用的比较可不可能出现啊，
19:27我们说的这样一种情况呢，大家想想这个其实是其实是完全可能出现可能出现的。我们可以来看一下为什么会出现这样的一种情况，还是我们之前的一个例子，对吧？我们有两个 server 啊，
19:40他们通过 think 去同步这样的一个消息。然后一开始我们左边的这个 server 的这个时钟是十一，右边的 server 时间是八对吧。这个大家这个可不可能出现？其实可能出现，因为我们这个手机电脑，
19:52它的始钟其实不一定不不是百分之百每时每刻都一样，对吧？大家想想我们知道这个原理的呃，我们待会会不会会稍微讲一下这个原对吧。这手机上的时钟它其实不一定会出现一样。那么当时钟它稍微不一样的时候会出现什么情况呢？
20:06就是我如果我这个 ipad 对吧？它是 post 的这样的一个文件的时候，它用的是我本地的这个时钟。比如说十啊四位一啊去去去做了一个这样的一个这样一个操作。然后它同步过来呢，其实哎做完之后哎，
20:20我这个另一台设备对吧？他看到了这个第一个设备的这个消息之后，他发现了这个文件 a 然后他比如说他基于这个文件 a 去发了一个消息，对吧？比如说你你你是基于这个文件 a 发了一个 reference 的这样的一个一个消息。但大家想想，
20:36我们这样的一个消息，站在这个这个我立制台 server 二的这个视角，它的时时间戳是什么？它的时间戳其实是这个这个这个这个九，对吧？它时间戳其实是比这个呃呃后一条消息的时间戳实，
20:49实际上上比前面一条时间戳更更小。然后这种情况下，如果我们去同步一下会发生什种情况，那发现首先我在这个 pad 端对吧？它这两个消息就会乱序，对吧？
21:00就是我的这个这个 reference 的这个消息是在这个真实的这个消息之前，同时我原本这里的我这个个手机端，对吧？他看的这个消息是对的。但是一旦我这个做了一个同步之后，我按照统一的这个时这个时间戳，
21:16比如说这边是这边是九，对吧？这边是这个十的就排序啊哎，就会发现我原本对的这个顺序，他最后也被这个同步成了一个错的。这样的者说相对来说不是特别特别符合直觉的这样一个顺序吧。
21:29大家想想这个事情可能发生吗？其实在我们现在的这个这个这个这个你你用一个时间，它的这个这个用这个机器的这个实验啊，就是物理机器的物理时间去当成一个排序依据。它其实完全是可能出现的对吧？它的一个核心的出现的原因是什么？
21:48核心的原因是我们的事件之间其实是有时序关系。它不仅有时序关系，它还有什么？因因关系系吧，我先看到一个文件件，我再去做它的这样的一个操作。
21:58然后但是我们现在的这个排序手段用的实际上是一个机器上的这个物理时间。这个物理时间它其实并不能反映真实之界的这个这个严格来说的这个持续关系，以及他们的这个因果关系的，为什么呢？大家想想就是说大家就那所谓我觉得不能反不能反映的意思就是我也台 server 它有一个它先发生了一个事件。 OK 先我们我们在系统里白这个 workof time 嘛，
22:25指的就是说物理上的这个严格意义上的这个实验 OK 它先发生，但是它可能会拿到一个更大的这个机器上的这个物理物理事件。比如说 server 二对吧？它它这个这个这个发生在后面，它拿到的时间戳反而会更小。为什么为什么会出现这种情况呢？
22:42它其实本质上在于就是说我们我们从系系统的角度来说，是很难准确的去度量这个这个这个不同机同步不同机器的时间的 OK。那这边呢为什么为什么我们说这个这个事情呢，为什么这个事情成立呢？我们就得啊简单的去看一下，对吧？
23:01就是说我们的大家有没有想过我们的计算机是怎么去统计这样的一个这个这个这个时间呢？我们我们我们我们手机上为什么显示现在比如说是十四点十八分，对吧？为什么出现这个事呢？再想想时钟它本质上是什么？它本质上其实就是我离某一个它是本质上是个记录量，
23:20对吧？就是说就是说我比如说我我过了一秒，我其实就应该可以把一个一秒的这样的一个一个一一个假设我有个有个有个数值对吧？记住了，说我这个设备出厂了大概多少秒，对吧？
23:32那么我这个这个就理论来说，我就是过了一秒，我应该给这个物理的这样的一个时钟去加一对吧。那么在计算机里面，它其实也是这么实现的。但是它实现的是一个它实现的设备，
23:43实际上是一个听振管啊，它就是说它是会以一个固定的这个频率啊，固定的频率去去去去去触发。然后你即使是关机，它一般来说也会有一些微小的这个电源，那去去去定期的这个触发去更新 OK。
23:58那么大家想想，我们的这个我们前面说是呃用计算机计时的一个最大的问题，就是我两个设备其实始终可能是不同步的，为什么呢？就比如说我即使是我这个手机和电脑，我们是在比如说都都十四点出场的，
24:12然后我们然后我们里面的正管每分呃每挣一次我们就给他。比如说过了一秒加一，或者说加上一个等价的数。为什么说这种方法它没有办法保证这个两个设备对吧？它的这个时钟是一样的呢？其实原因很简单，
24:27因为它的这个震动啊，它是一个物理设备，它的震动的这个频率实际上是会会随着你的这个环境去改变了。比如说我这个手机稍微过热了一下，它的这个震动其实就会频率会加快。导致结果就是我的这个一个手机，
24:41它的这个表会比另一个这样一个设备的表去做去去去去去跳的更快。那么它们就我们这种叫 clock drift 啊， clock drift。那么我们为什么现在大家看到的手机至少在秒级别，它还是基本准确的呢？是因为我们现在这个有个叫同步服务器，
25:00对吧？叫叫做这个这个 NNTP 啊，或者也好啊，我们手机或者是电脑会定期的和这个全球的一个稳定的这样的一个服务器去做同步。但是这样的一个方法有个问题就是说第一啊它只能做到这个秒。一般来说现在最最最最呃如果是广域网的话，
25:16一般只能做到这个毫秒级别的这个精度同步精度。第二个呢就是说你的这个精度啊，它实际上是会随着这个网络环境变化。就如果你一旦这个网络出现波动啊，你的这个同步消息啊发的慢了啊，其实也会影响到这个同。
25:32所以目前来看的话，就是至少对于普通的大众设备啊，普通大众设备我们是很难做到这个这个两个这个设备之间啊，他们的始终是完全一样的，这个是做不到啊，做不到。
25:44当然大家可能会有听说过，对吧？就是就是说有一些更先进的设备，比如说叫这个像这个原子钟原子钟对吧？原子钟它其实它的这个 drakancy 啊，它就不大会随着这个环境去变动啊变动。
26:00但是呢啊这边会原子钟其实也有问题吧。因为原子钟它它是不大变动，但它本质上还是会有一些一些 drift。它只是会比这个这个我们手机上这个设备需要很多。然后第二个就是原子钟，它其实相对来说是是比较贵的。
26:13所以一般来说只有在个数据中心心面啊，才可能会用一些这个比较精确的这样一个同步设备啊。但是你如果你是跨地的话，其实也是比较难做的。所以我们会发现一个点就是说如果你要是严格的去啊要按照这个这个这个时用始终去同步这个事情的这个 a 子的话呢，它其实啊其实呃还是会比较这个这个比较比较困难。
26:39所以我们如果我们简单的用这样的一个使用去做这个 eventual consistency 的这个排序的话，就会遇到一个问题。就是说我的这个这个最终啊它排序出来的这个顺序和我们用户想要的这个顺序，它其实不一样啊，它是不一样的。那我们大家想想，
27:00我们对于这样的一个啊一个系统对一个系统而言，它理论上它比较我们应用用期望上一个比较啊比较好的这个展示的这个数呃这个数据形式是什么呢？其实我们说对于我们这个例子对吧？它其实需求很简单，它需求是什么？就是我如果有个消息，
27:19我是 depends on 你的一个之前的这样一个消消的。那么我就把这个之前的消息，本来一定要让它排到前面就可以了，对不对？那么我们说你一个物理的这个时钟是是达不到，那我们能不能有一些其他的始终能够满足这样的一个顺序呢？
27:37其实这个顺序啊，我们发现在这个分布式系统里面其实是非常常见的，而且它也是能够实现的。它其实叫什么呢？叫一个叫做 call cosl 的这样一个 moden，就是因果关系。
27:48什么意思呢？就是说如果一个事件 x 啊一个计算事件，比如说我发一个消息，它导致了另一个事件出现。 y 那么我们认为就是 x 这个事件在这个排序里面应该要再排到更前面。比如说按照我们之前的这样一个例子，
28:04对吧？我的这个后我是我的手机是先看，我是看到了你，你发送的这个文件。好，然后然后我再去发一个就是 reference 的这样的一个这样这样一个消息。
28:16那么其实我这个 post five a 这个事件，它其实是触发了这个 post 这个这个 reference 这个 a 的这样的一个事件，对不对？那么在这个世界上里面，其实这两个世界之间本质上就有一个这个 cause of oring 的这样的一个关系。具体来说，
28:31就是如果啊这个这个它严格定义，就是说如果我在一台设备上，如果一旦一个事情发生生在前，那么我一定 XXX 有两个事件 XY 如果 x 物理时始终发生在更前面，那么 x 一定在 y 前面，对吧？
28:44这很好理解。那另一个就是如果跨设备怎么办呢？如果我这个 x 是导致另一个设备的这个 y 事件的发生，那么 x 也应该在在 y 之前，当然还有符合这个传递性，对吧？
28:55那么我们就说这两个事件，它会有一个 caul ordering 的这样的一个这样的一个关系。这个关系大家想想，我们如果基于这种 caul ordering 的定义的话，其实我们是在系统里面是能够建立他们的这个联系的。为什么？
29:10因为比如说我这个 pos a 假设我发到了这个这个这个这个这个 iphone 这边啊，手机这边，对吧？然后我看到了这个消息，那我只需要做什么？我在发这个消息之前，
29:19我发这个消息是我让他的这个时间戳有有这个 pos 比它大对吧？其实我们只要做到它的时间比它大啊，不就能够实现这样的一个一个一个比较有有有用的这样的一个排序吗。所以这个也就是引出了，就是说我们这边要讲的一个分布式里面的一个非常重要的概念，叫做 lamport clock crop。
29:39它是一个啊满足我们之前讲的这样的一个 casl ordering 的这样在计时计算系统里面的这样的一个 ul orderling 的这样的一个方法。那它的思想其实很简单，就是我如果两个事件是 cosl 的，他们那么根据 casl 的义义在在知道事件二在在知道我我啊或者这么说吧，假设我一个两个事界 XY 对吧？我们知道它是有个合作关系，
30:04然后我们知道 y 是由 x 产生的话，那么我们根据这些的定义，我们在在做 y 的时候，我们一定能知道 x 的信息。所以呢我们在做 y 的时候，我们让 y 的这个始终啊，
30:16它隐含了一个这个 x 信息之后，我们其实就可以这个这个让它这个这个这个这个这个这个最最终这个时间戳去去去排序了啊。那么我具体具体来看一下这个我们的 lannumber，这个 coook 它能保证什么啊，能保证什么？它能保证的是说 OK，
30:34首先它首先是个逻辑使用，它不是一个物理的使用。因为物理使用的话，你它其实完全取决于你这个设备的这个经验，对吧？它其实你很难去区分的出到底 OK 哪一个哪一个这个这个这个这个这个这个设备前设备后，
30:48那他说什么呢？他说哎，他是一个反映这个 cosor 的这个关系的这样一个时钟。就是说如果我们它其实严格根据根据 pose 定义来，就是我们 poster 定义说是说是吧？两个这个事件 x event 一和 event 二，
31:03如果 event 一在前， event 二在后，那么我们说这个这个这个这个在 laandpod 里面， event 一的这个时钟一定小于 event 二的这个时钟。大家想那么这个在我们最终的排序结果里面，就会出现我一台设备里面先是先的消息 invent 前。
31:17那么同时呢，如果是跨设备的，如果是 event 一，它导它造成了这个 event 二二这个事情事件出现。那么在 lampod 这样的一个使用里面啊，它也是会出现变小。
31:28那么站在我们之前那个 case 的话，就如果我们另一个手机对吧？看到我这个发的这个文件，那么我后面发的消息一定要比这么发这个文件的这个消息更大。 OK 那么这个兰珀的这个 clock，它怎么去实现这样一个 cos 操作员？
31:45它其实我们我们其实发根据这这个前面讲的这个定义义，我们会发现它实现其实还是是比较简单的。我们说第一需求是什么？第一个需求是说我一个 server 里面它先发生的事件，它的时间戳会更小。那么怎么做呢？
31:57其实我们就是我每个 server，它自己有一个 clock。然后呢，我这 clock 每发生一次事件，或者说我每隔每隔一段时间我就给它加一对吧。那么这样的话，
32:08我这个前前面发生事件，它的时间数一定是变小了。那么大家想为什么我们需要让这个 logical clock 定期的去去去去增加呢？因为这其本质上上实，也是希望我们的这个这个 loloc ical ck 啊，它能够大概的反应是一个真实的这个历史的这样的一个呃就是说世世界发生这个呃真实的这个实验。
32:28不然的话，如果你太 server，对吧？你一直没有发生事件，那你的这个 clock 就很很很小，那这肯定也是不对的。
32:34 OK，那么这个同一台设备我们去维护这个 cosl pod 其实相对来说是比较好弄的，它比较难难点在哪？但是就是说我这跨设备对吧？我一台设备 x 如果造成了这个 y 事件，我我造成了一台设后这个 y 事件。
32:48比如说我的这个这个这个这个手机看到了别人发过来一个消息，那我怎么去保证我的这个后面这个消息一定是比你就导致我这个时间发生这个始终更大的。而且很简单，就是我在发消息的时候，我把这个我这个消这个消息，这个是这个消息所在的这个时间啊给附在这个消息里面。
33:07然后呢，当我一个 server 对吧？我收到了这样一个别的那个消息之后，我会把我这个本地的这样的一个时钟，把它变成一个这个这个这个我收到这个消息和我当前这个消呃收到这个加一和我当前本地消息的一个最大的这样的一只。那么大家想如果我们有了这样一个 max more 的操作之后，
33:26我们后续的这样一个 server 所发生的消息。一一定是嗯一定是会排在这个导致我这个这个这个加一这个操作发生的这样的一个消息后的对吧？那么这样我们其实就就就能够这个这个这个保证 pos ID。具体来说，比如说我这个 service 一对吧，它就 post 了一个这个这个 x 对吧？
33:46 post 了，然后后假设我我到的这个使用是十，然后我 server 二我这个这个这个我我我用了一个这个 reference XIDX，对吧？然后我看到了这个 IDX，然后呢，
33:57我去我这个说什么，我就是会把我这个 server 二的时候变成一比。这个我自己的时候已经和它的这个四 v 一的这个始终更大的一个人。那么我后面的这个 reference 这样一个消息的这个消息啊，他一定一定是会拿到一个更大的实用。那么根据我们之前的这个 eventual 的这样的一个排序，
34:18对吧？我们其实就会啊发现啊就会发现就是说我这个这个最后啊我给用户展示的这个聊天记录，一定是符合这样的一个口腔 conststenci 的的这样的一个关系的 OK。那这这这个就是呃这个分布式里面的一个非常经典的这样的一个这个这个这个这个这个这个作 hoconsistcy 的这样的一个这个这个啊呃 a lapod talk。当然这个 lampod talk 里面，这个本身它其实有很多这个会理解它啊，
34:44对吧？我们其实有很多问题，这个就可可以问啊，它本身也是一个比较有意思的时间戳。比如说我们假设啊这个 TS 表示的是这个 event 一的这个 lampp clock 啊，我们假设我们看到这个 lapot 啊，
35:01 event 一对吧，它的这个 lamer clock 比 event 二的这个 lampod clock 小，对吧？然后然后我们啊然后这两个消息我们呃这两个事件我们认为是在不同机期的。那么大家想想下面三三个问题对吧？哪些哪哪哪哪是对。
35:17那比如说第一个第一个他说的是 event，一一定在物理上比这个 invent 二发生的更早。大家想想这个对不对？这个其实是不对的对吧？它跟我们之前用这个 physical crop 一样，就是如果你两台 server 之间没有 thick 的话，
35:32他们的这个蓝 popocrock 实际上是没有任何的这个关系。这个蓝 pod 一个非常重要的点，就是它只有你对这个事件啊发生了这个关系有关系有关系的时候，它的这个比大小才可能反映这个事件的这个依赖关系。但是如果你这个事件是没有关系的啊，你这个 rolaandpod rock 比大小其实是没有恶意的那第二条就是说 node 一是否和这个 nonode 二通信过，
35:58对吧？其实也不一定。因为我那个 node 一的可能就是我发生的事件特别多，或者说我的这个那个那个始终更新的这个频率快特别多，对吧？它其实也可能啊会出现这样的一个这个 node 一的使用，
36:09比 node 二的这个啊这个这个这个这个小的这样的一个情况，对吧？然后第三点对不对呢？就是说第三点说的什么就是我事件如果 invent 一跟 invent 二二 think 过了，那么 invent 一它一定会是一个会比这个上上发生的这个物理时间更少。这个其实比较比较唠啊，
36:29大家想这个是第三点是不是？对，其实其实也不一定对吧？因为你说我 event 一 sin 比 event 二当家第三点，对不对？就是说我 event 一对吧，
36:44支支持跟这个发到了这个 server 二。那么我这个 event 二是不是一定能比这个这个这个这个这个在在这个 event 二二这个发生物理时间之前呢，啊之前的我们假设假设是是假设是不对的啊，就是说明我们得构造一个 case，对吧？就是说 event 一发生在这个 event 二之后，
37:06对吧？物理时间发生之后，那么大家想我们在这个 event 一路和物理时间发生在到二之后，有没有可能这个 evevent 二的这个这个它的蓝 port 的 lock 是更大，其实是是有可能的，对不对？
37:19其实有可能，因为为什么我 event 一路我发生在之后，然后我发一个消息过去。然后这个这个 evanda 它一开始的这个 lamper clock 实际上是比较大的那这种情况下的话其实还是有可能会出现。就是我一一的这个呃 maclock 比较小，但是它发生的这个时间还是比 emdea 大对吧，
37:37其实还是有可能会出现的。所以说我们说 lample pok 它的一个比较大的问题，就是说它对于这个无关的这个事件，它其实他其实那个可能会出现的这个情况特别多啊，所以这边可能是要注意 ok 行，那么有了这个蓝 port 的 clock 之后呢，
37:53我们就把它放回到我们之前的这样一个例子里面。我们可以看到就说我如果用蓝的 poclock 去对于整个这个这个这个 log 去呃整个 log 去排序啊，那么这最后我们就能够得到一个就是比较符合这个预期的啊这样的一个聊天记录。那具体来说的话，那假设我一开始这个就是说这个一开始啊这个这个啊这边可能标错了，一开始这个色袜的时候是比较小十九。
38:19然后呢，我这个这个色位一啊，它在比如说他拿到一个十的时间戳给这样的一个文件之后呢，他会把他在同步的 think 的时候，就会把他自己当前的这个 level box 十给报到这个 server 二。然后 server 拿到这个十之后，
38:35他就会把自己的这个 time 更新到一个更大的这样的一个值。 OK 更新完之后呢，这边我的这个手机看到的这个消息还是跟之前一样。看到消息之后呢，我去加了一条新的这个消息。新的这个消息呢他就会拿到一个更大的这个时间戳。
38:49就十三。然后拿到这个时间戳之后呢，再去同步的时候，我们就会发现啊这个消息顺序其实啊就是就是这个这个正确的啊，要它满足这个呃依赖关系，对吧？
39:01就是我这个这个文件在前，然后啊 reference 这个文件的这个消息在后面 OK 你们的事。那么讲完这个之后，其实我们就把一个一个实现的比较啊比较好的这样的一个这个 imatial。 consistent 系统啊比较啊，其实现在很多大量的这样的一个 image，
39:18 consistent 系统也是基于这种啊方式实现的 OK。那么最后有个有几个小问题，大大家也可以思考一下，对吧？比如说第一个问题就是我们说介绍了一个叫 number per 'clock 这个概念。那么它能不能替代掉我们之前所所所有所谓的用这个物理使用，
39:36加上 ID 的这样一种方式去做呢？其实其实稍微有一些有一个小问题，有个小问题是什么呢？就是说它它实际上 number clock 它并没有给一个这个叫做 total order。那什么叫做 total order 呢？就是说对于一个分布式分布式系统里面啊，
39:50你任意发生的两个事件，我们都能够去给它啊给标记蓝光。合罗大厦能不能给出一个这个 photo order 呢？它其实不行，为什么？因为它两个台 server 的使用是可能是一样的。
40:01这跟我们前面讲的这个物理时钟实际上是一样的。所以说我们得基于这样这个像这个之前的这个使用的这个这个这个这个这个物理时钟一样，对吧？我们得给他一个这个这个 noad ID 作为这样的一个这个区分服务啊，这样可以区分开 OK。好，
40:20行，那么回到我们最初的一个问题啊，那大家想一想我们的这个假设我们前面说对吧？我们用这个 lampod pop 去保证了这个事件之间的这个因果关系。那么我们在我们现在实现的这样的一个这个系统中能不能能不能去去能，会不会大家会不会看到个聊天记录，
40:40对吧？这个聊天记录显示的实际上是两个消息，它那个叫什么并没有因果关系，对吧？就是说我这个引用的内容不存在，这个其实是一个错误的错误的这样的一个展示，
40:49可不可能出现这样的一种情况呢？对吧？其实其实还是可能出现的。为什么？因为这个 eventually consistency，它最终它 care，
40:59只是说你这个是这个聊天去道，最终会会会会会会一致啊。但是你在这个这聊天记录在生成的这个过程中，它其实有可能是不是比如说我这个同步的这个 server，那恰好就没有这样的一个文件。那这个时候其实你再怎么同步，
41:13它也没有用，你知道是吧？你最后到收到这样的一个呃 server 的这样一个文件的时候，你才能够保证这个这个这个消息是不对。所以说你完全好在这里他的问题就是啊我用户在使用的过程中啊，其实还是会不断的出现这个不一致的现象。
41:29那么他告诉用户，就是我最终所有的这个这个这个聊天记录不一样。那么用户到底觉得这个东西在不在意重不重要呢？那就就看你的这个应用的这个需求，对吧？如果你是手机微信，
41:41那大家想想我们微信聊天记录稍微乱一点。那么大家平时啊看的这个消息其实也没有什么特别大的问题，对吧？我们这个微信这个这个反正聊天记录啊，我们就一一般一笑而过了，反正他发生的这个频率也不会特别多。
41:54 OK 好，行，那么在到这边为止，对吧？我们稍微简单总结一下。那么我们给大家介绍了一下，
42:02就是说什么叫做 consisteny model，对吧？我就问为什么需要它这个在分布式里面非常重要。尤其是当你的这个数据啊需要存存在在多分的时候，然后我们基于我们这样一个模特 vtion case，就是手机的这个聊天聊天聊天软件，
42:16对吧？我们说了我们一个比较好的这个 im model 是 iventual consenstence，因为它性能是比较好的 OK。然后我们介绍了 eventure consenstence 的一种实现方法啊，也是一种比较主流的实验方法。就是我需要去做这个这个这个这个这个同步，
42:32然后去排序，然后最终让这个消息变得一样。然后这里面的关键点就在于就是说我需要啊怎么怎么排序很重要。因为你如果一旦排序不好，你的消息呈现的不符合用户的这个预期啊，那可能就会比较糟糕。
42:44所以一般的现在系统它都会基于类似于这个 lamper prrod 对于这个消息做一个排序啊，我的时候的聊天记录最终同步出来的和家家的这个都是一样的 OK。那么接下来我们大家肯定会好奇问，就是我们说前面说候有很多的 o 个这次这些 model 对吧？但是但是我们其实说有有一些呃呃呃 evention 思肯定是属于比较弱的一种。那么我们有没有一些 concase 需要一些比较强的思词功能，
43:10其实肯定是有的，对吧？就比如说我们来看一个这个这个嗯 mot v 零点点三，我其实也是基于微信对吧？或者基于类微信这个应用，这个应用其实大家手机上也都有，
43:21对吧？就是我们手机上会有一个东西叫什么叫叫接龙，对吧？有个接容这个东西，然后呢，我比如说我发起了一个这个接容的这个请求，
43:30对吧？这个接容请求他做的是就是你第一个接上的人能够拿到一百块钱 OK。好，那么大家想想对于我们这样一个应用来说，对吧？它比较这个假设我有个场景，
43:43我用刚刚那个微信的这样一个啊 evactual consensus 实现啊实现的这样一个兼容情况下，会出会出现什么情况。那么大家想想，理论上来说，我这个应用 case 对吧？是我 alice 先发一个这个兼容请求。
43:55然后呢，他然后呢这个报去同时也发起了一个兼容请求，然后 alice 去读。那么理论上来说，对于 alice 来说，他其实希望看到的什么？
44:05他理论上应该看到的是， alice 是第一个接上龙的这样的一个情况，对不对？那大家想想看，我们之前讲的这样的一个 lamport，就 lampod prlog 实现了这样的 case 里，
44:18可不可能会出现这样的情况？就是爱丽丝，他一开始看到的是唉，我第一个看到唉，我有一个一百块的这个奖金，然后突然我再去刷新一下，
44:28发发现这个这个一百块奖金没了，然后就就就就就变成 boss 变成第一个兼融了。有没有没有，这有可能有没有这种可能大家其实在我们的这个微信里面，它其实是有这种可能可能出现这边就是啊这个是这个是就是我当时这个截的一个图啊啊比较较小，大家可以看 p 啊，
44:48反正 BBY 大家一看，对吧？这个图讲的是啥呢？就是当时这个我们在在接龙这个核酸对吧？然后这个时候呢，我去接了一个龙，
44:56我我发现我是第十八个第十八个接龙。然后这个时候呢我会发现唉，我同事又刷到了一条消息。另一位老师，李老师，他的接龙号也是十八。
45:05就是大家看我们两个，其实如果在我们这个例子里面就会发现，我第一时间我会发现我是第一个介绍我的人，对吧？但是第二时时间这个就李老师他的接龙的这个位置跟我是一样的。大家想想微信其实它就会出现各种各样的这个问题。
45:21那大家想想，那我们已经介绍了这个基于 lamper cloud 实现了这个基 evenal consiently 的这个 QS，对吧？不是 plus 这个呃微信的聊天记录，对吧？大家想想我们这个之前的这个实实可不可能出现这种情况呢？
45:35可不可能其实肯定是可能的对吧？因为为什么呢？因为我这边更新的时候，我的这个服务器对吧？它拿到的实际上是这个我这边的这个这个这个这个这个时间戳 OK。然后他发现我是第十八位。
45:49然后这个时候呢，我做了一次 siink。 siink 完之后呢，我发现李老师对吧他的这个时间戳比我的这个时间周期更小。那么按照我们之前的这个排序，他会把我本地的这个记录什么刷掉刷掉之后呢，
46:02哎他就是把这个李老师放在了更加前面，对不对？那这个其实在我们这个如果你是一个比较简单的这样的一个这个这个排序里面，它其实就会就会出现这样的一个问题。那大家想这两个这个问题的本质是什么？本质是在我们这样的一个兼容的这个应用里面啊，
46:21接容这个样子里面。因为我们这个涉及到第一，对吧？涉及到这个 order，这个 order 就第一个人，他实际上是有奖金的。
46:28所以说他这个排序其实是很重要很重要，对吧？我们不能够给用户呈现两个不同的 order，就在我们这个如果我们这个想用兼容去做这个事儿，对吧？如果你用一个 ivential process 的系统，
46:41你其实是没有办法保证我这个第一个人他拿到的这个排序一定是第一个人的，对不对？那这个时候怎么办呢？怎么时候怎么办呢？这其实时候就需要有两种有一般来说有两种死路程两种方法。第一个方法是大家想想我们之前说的这种兼容的问题，
46:59它可能会出现在什么？它出现的问题在于，我这个分布式里面有两个事件，就是我的 alice 和 bob 同时去做了一个 post 的这个请求。对吧然后我没有在系统里面，我没有任何办法去区分这个 a 在前还是 b 在前前，
47:14对吧？因为它们两个是并行产生的。但是呢我们这个的 laandpoclock 呢，它其实不管你的这个 a 在前还是 b 在前啊，它都会给你一个确定的顺序，然后让你去去做。
47:24所以就会导致说我们这之前的这样一个问题。那我们有没有一种方法去 detect？那那我们这个是 detect 哦，原来 alice 的 bog 对吧？是是并行的，再去发起这样的一个接龙。
47:36那如果发生这种情况新情况之后呢，其实我们直接让用户对吧去处理一下。比如说假设啊我们有一种方法，有一种方法让这个这个这个这个这个我们的系统 detegor 发现哎， alice 这个 pos a 和 bob，这是这个 post b 啊，
47:53它其实完全没有任何的这样的一个依赖关系。那这个时候我的系统什么他就不去做这样的一个这样的一个这个这个这个这个这个这个这个操作。他会认为说，你们这两个人得重新来一遍，因为你们并没有啊，你们冲突了，
48:07对吧？有冲突，你们我不能够确定时间时候，那这个其实就是我们这个应用。如果你要用这个这个 imagine ass 的 model，对吧？
48:14那么我们能不能做到这样这样的一点呢？其实可以做到可以做到。那么怎么做到这个事呢？其实我们需要什么？我们需要一个时间戳，它提供的是一个叫做 partial order 这样的一个概念。
48:29念么么做做 tial 呢？就是说我们前面说 total order。什么叫 total order？就是所有的事件对吧？我我都能通过我们的这个 lalamper pock 给他们排个序。那 pasture order 是说呢，
48:38如果在你这个系统里面 OK，如果我两个事件，他们确定了有依赖关系，比如 alice 在前，然后 bob 看到了 alex 之后再接龙。然后那么这个事情啊，
48:48这个事情这个这个这个这个我 bob 一定在后面啊，这个是是是叫做有 aleorder，对吧？我可以给你一个时间戳。那如果你的 i ter bog 是同时发生的，比如说我同时去发起一个兼容的，
49:00那么我这个系统的实验出来告诉你，这两个呢没法比较啊，我没有办法区分。那么我们只要有实现了这样的一个实验戳，那么大家想想我们是不是就能避免前面所出现的这样的一个问题，对吧？
49:14因为我们前面的这样一个问题出现的原因就是有我 s bop 同时发生 OK。然后他们我们也系统他也不管，对吧？我就是收到了，我就是给你你处理。那么我现在我告诉你这两个事情啊，
49:24我就不要老是我告诉你，这两个事情是是不能 comfiver，你你你得推导重来。对吧那这个其实就是我们叫做这个 passh order 的这样一个概念。那么我们能不能在实在满足我们这讲的 quarter order 这个前提下去实现一个这个实验戳它能够满足这个 parture ororder 呢？啊其实这个这个是可以的对吧？
49:44但它的的本它的这个最后的方法，其实就是这个叫做叫做 vex clock 啊，它实际上是这个这个 lamport clock 的一个这样的一个个变种。变变种，那变在在哪里呢？其实我们想想看，
49:57这个这个 lampod clock 它为什么没有办法比较这个两个分布式发生的事件啊，是因为我的就一个时间戳的这个安全，对吧？好，我们先休息啊。嗯是，
50:48一是你是嗯，一是是谢谢嘘。