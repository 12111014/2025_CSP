00:41视是天，那就是说好，我们继续。好，那么我们已经把这个文件系统的这个磁盘上的结构啊讲清楚。这个呃它最重要的几个数据结构，
02:03尤其是这个呃文件的这个文件目录啊，目录长什么样子，我们都讲完了。然后呢，接下来就是这个文件，它打开和是读取它时间线长什么样子啊，
02:15我们前面提了啊，这里有一个 data 的一个 bit map 和一个 i node 的个个 itm map。这两个 bit map 就是用来表示的一个一的。然后呢， root i node 在这儿。对吧这是 i notable 啊，
02:24这一片是 IT table，后面是 data。当我们打开一个文件的时候，打假设啊，我们打开叫 open 负杠 f 杠八的这样一个文件。那我们是 read only 以去打开的。
02:33那么我应该先读哪呢？整个词头就会先读 i node，对不对？读完 i note 以后，读到跟根目录对应的这个数据，把数据读出来之后呢，
02:45得到里面的 i know 的 number，对吧？负的 i know number，然后去读负读完负以后呢，从里面找到负的这个 data 的这个呃 block。找到 deblock 之后呢，
02:55读读完以后再去读 buar。 i know 这样读，完成一次 open 的这个操作，这个我们前面已经讲讲过了。接下来呢就是我们要去读这个文件啊，就是我 open 完了以后要去 read，
03:06我们是 open and read， read 的时候怎么 read 呢？我们先去找这个 bar 对应的 i note，对吧？然后呢，找到之后呢，
03:15就去找到一堆这个 i note 里面的这个号啊。 i know i note 里面保存的是 block number，对吧？ block blow block 的号，然后这个 block 呢我们又去到 bar 的这个 a 到零里面去读。然后读完以后呢，
03:30这里有一个 right i note 啊注意啊，这个地方有个奇怪的地方，就是它怎么会有 right，然后呢又去读读。这个时候就是读第二个 block，完了之后又 write 再读。
03:41第三个 glog 再 write 一次，让你读完。那么这六句方有个 right 呢，修改源数据啊，就是那个时间的这个它有一个时间，对吧？
03:52这个时间叫什么时间啊？ time access a time， a time a time 就是 access time。 access time 的话呢，其实它就是要记录一下最近的一次访问是在什么地方。然后呢，
04:04它确实是这个呃，确实是在在整个的文件手里面是很重要的。因为如果你没有这个 access time 的话，你都不知道哪个文件。最近最近四略访问，但是呢大家看我是一个 read only 的一个操作，
04:17操作的话，我还要做很多 write，而且每周一次做做 right 很麻烦。所以呢我们就有了一个叫一个选项，就是在 monk 的时候啊，可以给文件加一个选项，
04:26叫做杠。 no a time 能 a 碳。浓 a 碳本质上就是每次不要每次读完以后就更新这个 a 碳 OK，不要每次读完以后就更新 a 碳，而是把这个对于这个 a time 的更新放在 close 里面哈放在里。那当你关掉的时候更新一次，
04:48当你 cloclose 文件的时候更新一次啊，你读的时候呢，我就我就不管了。这样好处是什么呢？好处就是假设我读了文件，读了一万次，
04:56对吧？我 read 一万次，它只要更新一次就可以，确实我也只 care 最后一次，前面的我都覆盖了，所以我都不 care。
05:04好处是这个缺点是什么呢？这是什么不独一半 make close 断电了哈，重启了。那这个文件它的 a time 就一直没有被更新啊，就是就就会有这样一个问题，但你说我都出错重启了，
05:22对不对？说不定这文件都是出问题了呢，我一我就我就我就不要要求那么多了啊，所以呢什么时候会做这样一个 trailer 啊，做这样 tradoer。好，
05:32那么接下来呢我们就要看这个除了 i note 之外，有别的一些文件系统啊， i node 是文件系统的一种组织形式。 OKI note 的本质是要去组织 block OK 把这个磁盘里面这么多的 block 把它给统一的管起来。但它不是唯一的一种组织的方式。我们再看一个别的组织方式，
05:50就是这个 FATFAT 呢就是我们说这个数码相机啊，数码相机里面用的文件系统，常常就是用这个 fat，一般是 fat 三二。然后这个 fat 它的这个长成什么样子呢？其实它跟 m 的就是完全完全不一样啊，
06:09整个的如果我们做这样一个把它看整个 find 做出一个大的大的数组的话，它是这样。它前面呢有一个空出来的叫 FAT，后面这个就是北海，后面是贝塔。那这个 FAT 呢和后面这个 delta 呢，
06:26它有一个一一对应的关系。后面比如说这有个四 k block 四 k 的 pro，那么我在这前面就有一个非常想了一个这个是八百 t 八 b 的一个，我们叫这个 block 的 ID。然后呢，这里也是一个 OK，
06:48还是这样一个这样一个关系。那这里有多少四 k 这就有多少个八 b 所以呢它这这里的数组和这个速度是一对应的关系。 OK 前面这个呢就是叫 FAT five 表，后面那个呢就是 data 好好。那么当我们有一个文件，怎么去表示这个文件呢？
07:09你都说没有 i node 了，我们前面讲半天 i node，是因为一个文件名对应到一个 i note number，对不对？像你没有 i node，那你对应到什么地方呢？
07:18我们就对应到第一个这个文件的第一个 block 他的布洛芬糖粉。比如说你这儿有文件，这个文件它呢是这个第三十啊 block 零啊 block 呃，这个这个这个呃呃这个三十一就它它第一个第一个 block 是是三十一，三十一在哪呢？就在这儿，
07:42这就比如说三十一哈啊三十一号，那么在这里就对应了一个三十一对应对应这个地方，对不对？对吧？因为我们前面说了，这个和这个是对应的啊，
07:53前面的范表后面就对应的。好，那么第二个 block 在哪儿呢？第二个 block 啊，我们就需要靠这个地方去记 OK 这个地方呢，它会记说下一个 block。
08:06在比如说在这个地方假设是四十一，那么这里就会对应到四十一这个地方。 OK 这里面呢又会去记说下一个在哪儿，从而在这个 fat 表里面形成了一个链表 linked list 啊，形成了 inked list。你看来看就是这样这样一个图，
08:27对吧？它有一个 file number 三十一三十一表示是第三十一个 lop。然后呢，他就一层一层记下来，把通过这个链表把这个文件串起来， OK 通过这个把这个文件串起同样 free free 也是一样的啊，
08:44在整个文件系统里面的话，它没有一个叫 data 的一个 bit map。我们前面讲 i 弄的时候，我们说前面有一个 bit map，零表示 free 一表示备用，对不对？
08:54在这儿不是的，在这儿的话呢，所有的 free 它就个 list，就是一个大文件。 OK free 本身是一个文件，我会帮你初始化一个硬盘，
09:05初始化一个 SSC 之后，它里面只有一个文件，叫 free。这个 free 文件把所有的都串串起来， OK。好，
09:11当你想要去把一个文件从 free 转移到另外一个文件的时候，本站就是这个大三十一，它要再加一个加一个的时候，怎么加呢？那我们就要从 free 里面减一个，然后再加进去啊，
09:25后面问一下，那这么设计有一个缺点，有很大的缺点，什么缺点？设计考回来，他只能顺序访问他。
09:32如果你要访问后面的话，就是出错。 ok 呃，你说错了，如果你访问后面的话，你就要花很多时间，
09:38你要你要一点，如果我我不 care 这个文件的头头上面，我只 care 文件，最后对吧？那你要先把这个列表先遍历一遍，遍历到最后，
09:47然后才访问对应的那个 boook。在 i 那里面呢，因为它它就三层嘛，它是三层列表啊，最多就三层，最多当然也不是最多三层啊，
09:55它就三层或者四层，对吧？它的层度是有限。如果你要访问最后一个文件，文件，最后一块你只要访问几次三次就可以了，
10:04对不对？但是在这里又不一样啊，在这里的话，你要把所有的这个代表都访问一遍，这是第一个问题。第二个问题就是它一旦要是出错了 OK，
10:15比如说你在这个范畴表里面有个地方出错了，那就会出现这样的情况。大家看他这个不错，后面这个都都都找不到，为啥？因为你有一个地方止飞了，
10:27那后面所有东西岂不是都止飞了嘛，对不对？所以说他有我们以前拍数码照片啊，这个有时候一张照片坏掉就是坏成这个样子啊。如果你在 i node 文件夹里面，如果坏掉的话，
10:42它大概率不是坏成这个样子。他如果没有坏，在 i note 上面，他如果换掉贝塔贝塔的区域，那就换这么一小块，对不对？
10:51他如果换成 l 的那个区域，那整个就没了看。但是如果你坏在这个 fiat 里面的话，因为你有个 list 嘛，所以说你很可能前面还是好的，但从某个地方开始，
11:02后面就就坏掉。好，我们现在前面说，如果没有把这个文件再增加一些，怎么增加呢？第一，
11:12我们要找一个 free 从 free 里面拉一个出来，怎么拉呢？就是你当前 free 有一个头嘛，我把这个头变成它，对吧？这块就多出来了，
11:21然后把这块呢加到哪儿？加到这个文件对应的这个位置，就是刚才我们说的那个 fed，对吧？三十一号它本来是一块两块三块就没了，现在呢四块，
11:34这就会直过去，那这块绿的就变成了这个文件里面的一部分。 ok 好，这是我们说的 fat 可以看到啊 fat 和整个文件锁跟我们前面说的 i 维年所啊，是天上地别对吧？天差地别啊，
11:50它最后就差不多长成这个样子。然后呢，在嗯 nofachich 里边的目录跟的也不一样。 OK 在目录里面的话呢，它会有一个文件名到文件号码号码，就是第一个 block 的号码，
12:04对不对？它会有这样的因此关系。 ok 然后呢我们来具体看一个，这里有一个特点，就是 far 的排摄是是放在目录里面的 OK，它不像 l 的一样啊，
12:18放在一个专门的 l 的里面，在目录里面只记一个百度的到文件名的映射。它不是的，他是把所有的文件，就把一个文件，所有的 action 全部都放在一个目录里面。
12:30这是一个 case，还有一个叫做 quick brown 点 fox。然后呢， the kit brown 点 fox 呢，它其实主要是这一行，就是当我们有一个常用性品 fat 比较这个一个小小的历史的一个那个什么，
12:42就是它不能够存长文件名，就是它最早的时候是不支持长文件名，它只能支持文件名，大小是八个字。所以呢他遇到一个 the quick bround fox 这个文件之后啊，就是他会先把这个文件改名，
12:54改成把空格先删掉，对吧？然后呢从前往后，然后取六个字符，再加一个这个小蚯引号，对吧？
13:03再加一个一点 fox，它会把这个文件重命名一下，就变成了八点三。什么叫八点三？就是八个字符。文件名加三个字符的扩展名，
13:12中间加一个点，那变成八点三这样一个这样一个形式。然后呢，它就能够把这个记下来了。 OK，那你说我如果有一个 the quick brown 二点 fox 怎么办呢？
13:23那他就会把 the quick brw 二点 fox 这个文件先用同样的方法命名，命名之后发现重名了。因为已经有一个 the quick 杠一，他就会把这个一改成二嗯，改成二，如果又重名就把二改成三，
13:41如果还重名就一直往下加加到什么呢？加到加到九，加到九之后不够了，它要写十了，它就往前再挪一位，就把这个 i 删掉。
13:53那理论上来说最多可以加到 t 杠九九九九九啊， fox。那为什么是这样？那他之前就是这样，到 ss 的时候，就是这样，
14:02到四的时代的话，就是点点三见你。所以他后来你他一直一直延续了这样一个限限制，但我们用户依然是希望看到 the quick brown 点 box 这样一个常用点名。于是呢他就做了一个扩展，就是他把另外的两条，
14:16大家看这一条，这是一条，对不对？这是第二，他把两个文件的目录 entry，就是长时间水拿出来，
14:23专门用来放文件名啊。就是他把本来用来放文件，就目录项的这个空间拿出来去放文件名啊，就是为了支持这个长文件名，这个呢我们就不详细说了。因为这只是它支持长文件名的一种方法。
14:37这里的一个关键的重点的话呢，有几点就是我们就看下面这行就可以了。我们假设这个文件就是叫 the quick brown 点 fox 啊， one 一点 fox 假设就是。好，下面我们就看这一条。
14:50在这里话呢有几个很有意思的点。第一就是这里有一个 first cluster， first cluster 这个地方就是这个文件呢，第一个快在什么地方？就我们前面说的三十一找到第一个在三十一的这个对应的位置，就会这个 ft 表里面就会指向下一个，
15:10对不对？就形成一个列表了，所以我只要拿到第一个就可以了。好，这是它这个 first class 记得这个笔记。那么由于我在这个地方把文件名和 the first caaster 都记在同一个目录项里面了。
15:26所以带来了一个问题，就是它不支持音乐节，他为什么不是音乐节？大家想如果我现现在如果要给这个的 quick brwn 点 focus，再加一个硬链接的话，我怎么办？
15:45我就相当于是在下面把这个复制一份到这儿，对不对？复制一份到这儿，然后把名字改了，然后我这个不改，对不对？
15:52按照我们刚才的他说法应该是这样。但是大家看他这里记了什么，他这里记录了很多东西，对不对？他记了啥？他这记了这个这个这个 last modifive time m time last access time a time。
16:07然后呢， create data，还有就是这个 size fsisize 它接很多东西。所以如果你你复制份的话，这这东东你都得复制都得复制。于是呢你就你就意味着对于同样的一个 the first cluster 这样一个文件，
16:23你不仅有很多个文件名，而且你还有很多个文件 size，但实际上它只有一个文件， size，对不对？所以当你改了这个文件之后啊，
16:31你得把所有这个发赛斯都要更新一下。为什么？因为同样一个数据，它就相当于出现了多个备份多个副本。如果你不改的话，就会不一致，
16:41所以你必须要把所有这个文件的发散都改了，这个呢就很麻烦。所以呢他就不支持这个哈德语啊，这个不支持哈德语。 ok 这就是我们说的，对于一个 set 的文件使用来说的话，
16:59它的文件的文件名是文和文件的，其他的这个数据是保存在一起的，这个和 m 的不一样。 i 诺的话是文件的原数据，只有这些，从这边开始到这儿，
17:12文件原数据就这些全部通通的放在了矮弱的脸。 ok 那这个呢是放在目录里面，但是呢他没有有用的这样的数据结构，他也没有在前面预留一块 faci。 no table，他这个都没有，
17:27他就是把这个信息放在了目录里面。于是这个目录就成为了一个非常重的一个这个这个这个记录性就非常的多啊，非常多多了之后的话呢，这个这个就就失去了文件名和文件映射和文件就的映射。这种灵活的这种关系，它不能在给一个 IO 的，
17:49在或者说给一个文件有有多个文文件的这个名字 OK，这是我们说的 fat 是这么设的。然后 fat 呢，还有一个小的一个细节，就是这个发 cess 不知道 fat 啊。有时候我们去格式化一个硬盘，
18:02格式化一个 u 盘，格式化 u 盘的时候呢，他让你选选这个格式化的这个文件系统的类型，对不对？有时候你会默认默认的话，就是 fat 三二。
18:10当然现在 windows 可能已经变成 EX fat 了啊，但是在很长一段时间内都是 fat 三二。当你拿到一个 fat 三号的 u 盘的时候，当你去往里面拷一个很大的文件的时候，会告诉你文件太大了。 OK，
18:23比如说你要拷一个电影文件，十个 g 他告诉你对不起。你这个 u 盘不能拷十个 g 的文件，他只能考四个级以下的文题，为什么呢？这个四个 g 是由什么决定的呢？
18:34主要就是这个决定八概在这里是知到是这个这个这个三十二位三十二位最大是多少？三十二位还是四 g 的，对不对？所以这个发 size 它占三十二位这件事情就决定了文件的大小不能超过二的三十二次方，也就是四 g 对吧？就不能超过四 g 所以呢我们说其实当时觉得这个够了，
19:05现在看来是完全不够的一个文件，四 g 不是随随便便就就超过了嘛。所以后来 EXT 啊 EX fat，就是相当于把 fact 文件做了一个做了一个扩展啊，从而去支持更大的这个这个文件。好，
19:23这个是我们说的文件性，文件性。没什么讲完之后啊，其实大家会觉得好像也就那么回事儿，好像也没什么太复杂的东西啊，很多同学本科时候也稍微学过一点。
19:35那么接下来我们要去讲稍微难一点，或者说稍微复杂一点的东西是 crash consisence 文件系统最烦的，或者说最难的地方就在于说它保存的文件是我们非常重视的。我们绝对不能允许我们的电脑。有一天太平的文件坏了丢了啊，这个是我们是是是不允许的。
19:57或者这么说就是如果有一天当你写毕业论文的时候，对吧？然后写了一个月，每天写一篇文。然后第一个月零一天的时候，你发现这个这回就没了哦，
20:10我觉得这基本上所有人都崩溃了。同样在虚拟机，就比如说在云云计算的时候啊，我们都遇到过这样一个场景，就是我们开一个虚拟机作赖，对吧？
20:20很多同学开虚拟机作赖看，然后做 lab 的时候呢，你做做 OS lab，或者做做一些底层的 lab，做崩了，做崩了之后重启。
20:29反正你觉得我用虚拟机就是用于重启方闭，结果你发现它起不来了，那也许你起不来了，然后你代码还在还在里面，或者你的很多的这个环境和境象在里面，然后就会让很让人崩溃。
20:42但是当然这并不是一个 best practice，对吧？我们说代码始终要多个备份，对吧？不能只放在讯息里面，但是这确实是经常发生的一些情况。
20:51就是当一个文件在用的时候，突然断电或者系统 crash。当你恢复了之后，你重启的时候，你会发现这个文件啊它有一定的概率是出问题啊，一个 word 文件可能你就真打不开了啊。
21:08然后呢，一个这个这个这个我我以前哎呀，我想起我们我我我我读演艺的时候哈，我读演艺的时候，软件工程课让我们画 UML 的图，还再画过 u 文面吗？
21:23那个 UML 的工具是那个老师自己开发的，它有一个特点，就是有时候你保存了之后就打不开了。当时没有评价系统啊，哎我们实验室就是到处都是哀嚎声啊，时不时的传来声哀嚎完了开不了了。
21:46然后这个就不得不手动维护很多这个版本，这个会让人很崩溃。当然这个是他的是文文卷写写的问题。但是 file system 的 crash 这件事情的话，其实每个人都跑不掉，因为崩溃不是我们要的，
22:00对不对？但是也不是我们躲掉好，那么什么是 glsense，或者说是一致性呢？本质上就是假如举个例子，比如说如果一个文件，
22:10它的 size 那个字段写了一二四五，那么就意味着这个文件有一二四五个 by 保持在那里。因为这不是个很自然的一件事情吗？但是如果你反过来，你发现这个文件啊，它的 i note 指出去的这个 block 数下来发现一共才这个最多最多四个 block。
22:35你你做了四 k 那就是十六 k。结果呢他的 size 却告诉你，这个文件有几兆。也就是说你看他的，你看他的矮 node 指出去的那个 block 的数量，别人都是零都是零，
22:50只有前四个有效，别人都是零。前四个指出去有效的加在一块儿，最多最多十六 k 但是它的 m 的里面 size 那一项写的说我这个文件有八种，这就是一个叫 consistence，对不对？
23:07那到底听谁的呢？不一致不要我也感受了，我有三个哈德利三号类，那么我的 n link 或者说是叫 reference counter，就应该是三啊。这个刚才我没讲，
23:24 i note 里面有一个叫 n link，就是指向我这个文件的，有这个文件名啊，或者说哈登利水有多少个，为什么要记呢？很简单，
23:34如果删掉一个的话，我不能把这个文件的数量数据删掉。因为还有两个，对不对？还有两个指向我这个按钮呢还不能释放掉。那如果再删掉一个变成一了，
23:44还是不能释放，直到三个都删掉。我的 reference counter 或者我的 n link 变成零的时候，我才能够安心的把这个 inote 回收掉。但是这个 n link 等于三。这件事情意味着在整个文件系统的目录里面，
24:01有三个文件名指向我这一个 i note，对不对？那如果说我们反过来我的 n link 等于三，但是我遍历整个文件系统发现只有两个文件名，指向我这个 i note，那么会发生什么错误呢？
24:26这就意味着，如果那两个文件被删掉，我这个癌 note 还是不能被释放，对不对？这就是一个不一致啊，这也是一个不一致。
24:36此外，还有有一个 data block 说我是 free 的 OK，它前面有一个 p it map，对不对？对， data p itm AP。
24:42然后呢，这个 data block 假设是一百零一号一百零一号 block，它对应的 p itmap p 那个是零，表示示是 free。但是呢在文件系统里面有一个文件，它的 i note 里面就有一个指针，
24:56指向了这个一零一号 block。那提谁呢？有人说文从癌症的这个角度来看，就用了这个文件。但是你从 bit map 这个角度来看，这个布洛克应该是没有人用的那听谁的？
25:13所以还有很多类似这样的例子。那为什么会有这样的一些例子呢？为什么会有这样一些例子呢？注意啊，本质上是因为有信息的冗余。什么叫信息荣誉？
25:27我举个例子，现在我我什么我要有一个叫叫 link 这样的东西。 n link 我们前面说了，你有 a link 是因为你要记住有多少个文件，文件名指向了一个 i know 游戏。但是这个信息啊其实我们不一定要放在 a link 里面。
25:46我把整个文件遍历一遍，我就知道有多少个文件名，指向这个 i note，对不对？那为什么我还要存一个 n link 呢？为什么还要存一个利题呢？
26:01为啥是为了效率？我不可能每次在删掉一个文件的时候，对吧？我都去扫一遍这个文件，看一下它是不是最后一个文件，指向。
26:11我这个是我这个按色是不是可以被 free 掉，对不对？他不能每次都扫一遍吧，所以他需要有一个东西记一下。 ok 那需要有个地方记下来，这样的话呢效率也会更高一些。
26:23同样我对于这个 data block 是不是 free 这件事情，为什么我要在前面放一个 beflag 去记零和一零一零一呢？我把整个 i note 扫描一遍，对不对？我就知道哪些备用，哪些不备用。
26:36他之所以在前面记一个 mindman，也是为了效率，也是为了性能。换句话说，就是我们为了在分配磁盘块的时候，在创建文件的时候能够做的更快。
26:52我们把一些文件系统里面的信息把它给存在了。一个地方这个信息原本就已经在，只不过我们把它存下来之后，查起来可以更快一些。但一旦我们为了性能做这样一个 n link 这样一个像是一个 cache 一样的操作，对不对？
27:11 n link 本身你可以认为它就是一个 cache。那么我们就有必要去做什么事情呢？就是我们要去思考这个原始数据和这个 cash 数据之间的一致性，要保证它们是一致的。 ok 那么这个不一致为什么会发生呢？如果我们每次操作都是 OK 的啊，
27:34我加一个文件，我加一个的 harlink，我就把它的 n link 加一，加一个 da， link 就加一，减一个的 harlink 就减一。
27:42如果每次我听他保证这个操作是对的那我就不用担心它不一致的问题。那什么时候会不一致呢？就是为什么肯定事情会被破坏掉呢？就是我们现在说的非脸啊非脸，就当我们更新了一个事情，却没有更新另外一个东西的时候，
28:03对吧？它产生了一个非脸就产生就就就是产生了一个会议室 inconcerent。所以呢我们就要考虑这个这个这个怎么才能保证一致性啊，就是我要更新一个东西，我一定要把这几个东西一块儿更新了，否则的话他们之间就会不允许，
28:21所以要保证一致性。所以这是 crack crash consiency 的这个这个问题。 ok 一个文件的操作。比如说我们新加新建一个新加一个这个目录项啊，新加一个目录项，它就意味着要好好多个操作，
28:37对吧？我都不说 a time 了， a time 这个东西肯定也是要更新的，对不对？但是 a 碳如果你丢了，可能似乎也不完全影响正确性，
28:46可能就是你统计的时候可能不是那么准确，但正确性不会有影响。但是如果你不是仅仅是 a cam 的更新，你要更新 size，你要更新更新 i node 里面更关键的这个数据结构的时候，它就有可能会有问题。
28:59而一次文件操作它就是要更新多次磁盘上的数据，那么就存在着没有完全更新完之后导致的问题，就是在中间啊 crash in the middle 怎么办？对吧？那就会导致文件系统一半是新的，一半儿是旧的半新半旧啊，
29:20就是 not 特别是 ok。所以嗯我们在这里看到不仅是这个 data，我们关注一个文件，比如说数据在不在，你可能比较关心的是哎，我的照片在不在啊，
29:36我拍了照片在，你拍的照片在。但是呢它的 metal data 有可能出错了啊，而买 had 它一旦出错呢，它它的这个后果啊比这个文件数据出错还要麻烦。我们前面看到一张照片，
29:49它的文件出错，可能最后照片里面的某个地方有个马赛克，或者有一个随机的一个雪花。但如果他的目录他的文件系统的这个原数据，如果出问题的话，他甚至有可能会让你这个文件只到别的文件去 OK，
30:04这样的话就全乱了。好，这就是我们说的。那么为什么会有文件的性能和这个 crstmas 之间会者问题？就是他们之前之间存在的一个矛盾，很多时候性能往往比这个安全性啊受到的关注更多。
30:27我们为了跑的更快，我们往往会牺牲掉这个 crash consiency 啊，牺牲掉这个 secreure 这我们说系统方面的内容了。 OK 这不仅是在文件系统里面会有这个问题。 ok 我们举例，假设我现在要写一个数据，
30:44原数据我们都知道原数据这个东西啊很关键，一旦更新之后，最好就写到磁盘上，或者写在 SC 上面，为什么呢？因为断电之后它还在嘛，
30:55对不对？就像我们写代码的时候，或者是写写写写一个 word 的时候，时不时要按一下 CTRLS，就是道理，对不对？
31:03但是你有时候写不写吧，你你就忘了 CTRLS，或者你说哎呀，没错，按 control s 好麻烦啊。这个这个当我这个把我的写作的这个整个的这个思路打断掉，
31:13所以就不想去按 CQS。你不想把这个数据写到磁盘上。因为写到字盘上这件事情很慢，所以一下我就让它在内存里面，我就一直一直做，一直做，
31:25一直做，结果呢好处就是确实很快。缺点就是那 crash 之后，很多数据就都丢了，对吧？但是呢我们在一个厂商在宣传一个设备的时候，
31:39一个厂商在宣传他们的系统的时候， crash conlisten 这件事情是很难去宣传。你怎么宣传？你说 ifi ad 看好了，我现在有在做一个事儿，我拔电源，
31:54再插上去，你看哎什么数据都没丢啊，这个大家估计都睡着了，对吧？你说有雷军在演示产品的时候，会做这种这种 demo 吗？
32:04永远不会啊，他就会跟说跑分，你看我们现在跑分跑下来，比对对手快多少多少多少，比友商快百分之多少。他看看这个对不对，
32:13数据一下子出来了。你说我这个拔数据啊，拔电源啊，我这个 crash condiency 啊，我拔一百次啊，一次都不会丢数据，
32:22对方拔一百次会丢三次数据，人家心想谁没事儿给你拔电源呢，对不对？这种东西有什么好说的呀？我我运气这么好，从来不会遇到这种事情啊，
32:32大家都觉得这个事不会轮到自己身上。所以呢就导致了性能，它永远是比别的，包括安全，包括 crash 的 ence 更重要的一件事情。现实就是这样啊，
32:43我们说系统大的环境是这样，我们的系统很多时候也也不得不是这样，所以就让这个 crasstes 啊越来越慢 OK。然后呢，这个还有一个人人人人人的效应，对吧？
32:58就是这个由于在演示的时候主要看性能，所以谁把性能做好了，谁的工资就高，奖金就多，就吸引了更多的这个人去对比，对吧？
33:10做性能去了啊，那那有些没没没有人做的事，他的薪酬就很啊，你愿意去哪边呢？这个就就觉得更更更麻烦，就就导致一个导致一个这个马太效应对好，
33:27但我们依然觉得很重要啊，尤其是在一些数据的这个安全存储性是非常相关的。一个地方更重。所以我们来看看 case，就是当我们去呃 append 一个文件的时候呢，我们会写一些数据啊，
33:40这个跟这跟我们前面一样的啊，这个是 i 的 nobeata map，这个是 data beitbmap。 i know table 和一个 data block 的这个整个的这个 beatblock 这些东西差不多，整个算是长这样。那么当我们更新一个文件，
33:54我们要给一个文件，加上一块数据的时候，我怎么加呢？第一步第一组，我们要在这个这个 data block 这块啊，我给它加一块，
34:07 OK 加一款，这是第一第二。由于我加了一块，所以呢我对应的这一块要从零变成一啊，就是 data begline 要从零变成一，这是第二个。
34:16第三步就是我我我变大的时候，我的 size 要更改，对不对？所以我的 size 要从这个一变成二，然后呢我的 point 呢要在这儿要加一个差，不就是这样，
34:28就是我再本来是一的变二了，本来这个是 now 对吧？变成五了四，后面是五。然后呢，我这个地方本来是空的，
34:36现在我变成一了，本来是零变成一了。还有就是我这个地方本来是空的，对吧？本来本来没写的，现在我把它写上最新的这个数据。
34:46所以整个这个过程中一共有三个地方要写三个地方性，第一就是这儿对吧？这个地方要写，这是第一第二，就是这里要写。第三就是 i node 要写，
35:00 i know 里面要写好几个东西啊，这个和这个但是因为它都是在一个磁盘块上面，所以我们就认为是一次写操作。 OK 就是说更新把一个文件扩大。那么一个 block，就这一件事情我们就有三次磁盘的这个写操作。
35:16其中有一次磁盘写操作会写的东西会比较多，但我们认为是一次，因为它一次就是四 k 嘛，对不对啊？就就每次写写下去一个整体磁盘的最小读写，就是磁磁盘，
35:27就就是就四 k 好，由于有三次写操作，所以呢我们发给磁盘的消息就是三个。那既然我们发给其发消息三个，那么当发生断电的时候，我们就有八种可能哪八种可能二的三次方就是三个写操作都没写，
35:45对吧？三个写操作都写了，这是两种三个险操作里面有一个失败了，三个险操作里面有一个成功了，就是各三种，对不对？
35:57所以就是三加三加，我们前面说的就都成功和都失败，就是二，一共是八种可能八种可能呢我们来想，你们就回到这张题，这个是一对吧，
36:11这个是二，这是三。假设这个地方我先假设他写成功了，那两写失败了没写，没写，就原来的旧职，
36:21他成功了，会什么影响呢？对整个文件史会有什么影见呢？没有影响，为什么没有影响？我这儿写成功了，
36:36这个都没说会有影响吗？会什么？为什么没影响？为啥没影响？这里？对，
36:53为啥没印象？因为就是可以当做没有写，为什么可以当网员呃，他没有更新，前面的那没更新，为啥这个可以当成当做没问题？
37:06我可以当成一个呃，没写过 free。对，就没写，当成没有写的原因，是因为没有人指过来，
37:12对不对？没有指过来，你从文件系统开始便利，大家还记得我们打开一个文件，对吧？我们是要去从上到下，
37:19从根部中开始便历，由于没有人指向它，因为指向它的在在这儿，这个地方会指向他，对不对？这个会点点，
37:27我这个要没更新，因为没更新的话，就没有任何的文件可以指向这个地方，所以你改没改都无所谓。 OK 好，这是一次 OK 的好展现。
37:37假设这个地方没改，然后这个地方改了，别的地方都没改会怎么样？本来是个零，变成了一别人都不敢会怎么样，那应该就别人用不了，
37:54就别人用不了了，对不对？就是这块第五个 block 就没有任何人可以用了，为啥？因为他是它变成了一了，对不对？
38:03别人以为他在用，但其实没有人用，所以这个时候呢就导致了磁盘浪费了，泄露了啊。我说内存泄露也存在磁盘泄露，反正都没人用了。
38:12好，这是第二个，没人用呢，就比较麻烦，因为浪费了嘛，对不对？
38:16不好，但是呢似乎也不是那么严重。好，我们再来看，如果这个地方改了，另外两个地方没改会怎么样？
38:24大概这两个改了，但是另外两个地方没改会怎么样？会发生最严重的情况是什么？谁能跟我说最严重也有可能另一个文件用的那一块儿都被他改，另一文件也有可能用这块，对不对？
38:44它 bint 五指过来了也改了也用了，对不对？换句话就是一个 block，两个文件指过来，对不对？对，
38:51一个 block 两个人指过来，这个情况是非常严重的。你再想一个严重的情况出来，就我改了之后，你发现你文件被我改，对不对？
38:58这还不是最严重的，最严重的是我把这个 CSP 的这个期末考试，对吧？写在一个文件里面啊，期末考试的试卷写一个文件里面，然后你那有一个这个别的文件，
39:12你说哎怎么怎么我连过来了啊，正好连过了啊，看到你这个数据了，对不对？这个就就就有问题了。 ok 就有问题了。
39:21这一个还有呢就是这个这个呃我觉得这已经已经最严重了。所以所以我们可以看到就有三种情况，第一种情况是无害的。如果只有他写了是无害的对吧？然后呢，如果只有他他写了，
39:37那就浪费了，对不对？浪费一个啊问题不是很严重，但如果只有他改了，这个问题就很严重。因为他会指到一个不知道是什么地方，
39:44让整个文件访问出现一些不可预测的问题。他文件已经改了， size 已经改成二了， point，一下就改成五了。所以说他认为我这个所有操作都完成。
39:55但其实这个 block 压根儿还没有分配出去，里面的数据压根儿还没有初始化，它就可能读到未初始化的这个数据，未初始化数据是啥呀？什么都有可能，什么都有可能。
40:05那我们最坏情况就是他有可能会读到一些错误的数据，不该补报的数据等等。好，我们再来。如果说这个这个再还有三种情况，对吧？
40:17就是这个和这个都写了，这个没写会怎么样，就是这个 bit map 写了，这个也写了，但是 i know 的没改会怎么样？除了以后等别人都改了会怎么样，
40:41什么问题行啊，泄露的问题，对吧？因为他没改，所以没有人指指指过去，对不对？
40:47没人指过去，但是他又又又被用了啊，所以说他他他就是一种泄露的这个情况啊，这两个改了他没改会怎么样，除了他别都改会怎么样？会导致未初始化，
41:04对不对？读到未初始化数据也很严重，因为有可能是一些机密的数据啊，被你读走了。然后还有个就是他没改，这两个都改了会怎么样？
41:18也有可能被其他文件，也有可能两个人文件取到同一个 block。对，因为他明明已经被指了，但是却没有标记它费用。所以这六种情况里面我们会发现，
41:32其实啊它都很问问题都很大啊，除了除了那个什么之外，除了第一种情况之外，对吧？是有点耐的，后面要么就是泄露，
41:40要么就是未初始化的数据啊，然后都很严重。那我们怎么保证 crash 可多事情呢？我们可以 do nothing 就躺平，然后呢我们想着说哎说不定就别的事儿啊，这个呢这个也不是不行啊，
41:59我们很多时候做 lab，自己写东西可能就是这样。第二个呢就是 journal 就是日志，第三个是 copy， right，第四个是 soft update。
42:10好，我们来看这个整论是怎么做的。好，准备他的一个思路，就是我们要写一个日志，日志，
42:20你之所以会出现这个问题啊，根本原因在哪？根本原因在于你把一次，你把一个操作要分三次写操作，最后那当然会有可能中断了，对不对？
42:30那如果我能够把这个操作变成一次写操作，就一次写进去就写了，就成了。没写进去呢，那就不成。那么你断电永远是发生在我这个写之前和写之后，
42:45而不可能发生在我这个中间，为什么？因为我只有一次写操作 OK，我就一次性啊，那如果能够做到这个的话就好。于是呢他想了一个办法，
42:54就是我把所有要更改的地方全部都写到一个日志里面，写到一个日志里面。 OK 什么是什么叫日志啊？日志就是在磁盘的最后他多了一个出来，这款就是日志。我们今天很多都是这么做的，
43:15当然你也可能说我在里面放一个文件，就是日志也可以。但是早期的日志啊或者说简的的志志实现，就是把磁盘的最后一块预留出来，专门用来做日志，不跟别的东西抢。
43:27某些不是说这是 block，这是 i know the table 对吧？后面加一块 lock。当有这个 log 之后呢，我就把所有要做的操作，前面说三个都放那儿，
43:36然后呢一次性的写一个 commit。这样的话呢，只要我保证这个 commit 是原子的就没问题了。 OK。好，我们来看一个具体例子。
43:51现在我有一个枕的，然后呢，我在整稿里面写这么多东西，大家看一眼是啥？ size 一到二，旧数据新数据我都写 size 一到二，
44:08然后呢，还有是这个 quenter，对吧？然后呢， DB 数据长什么样， old 长什么样，
44:16 new 长什么样，我全部都写到这个日志文件里面， OK 而日志的这个这个区域里面。对，好，最后我在这儿写一个 commit。
44:31现在开庭写完 commit 之后呢，我再定定心心的把这个里面写的东西写回到，原来该在的位置，一个一个写。然后这个地方写了啊，这个地方也写了定立心心的写发生断电。
44:48没关系，所有要改的东西怎么改，我都放在日志里面。我只要恢复的时候，照着这个日志恢复就可以了。 OK 等我恢复完了，
44:56我就把这个日删了，就做完了，就把这个日删了。那这样的话不是所有的事儿都都搞定了嘛，对吧？好，
45:07这就是我们说的这个 joural journal 的问题呢，就在于非常简单非常非常简单的一个问题。什么问题？所有东西写两遍对不对？你有任何的写操作，你就写两遍，
45:25第一遍写在这个人报里面，第二遍再写会到他该写的这个位置。那你说吃不没骗，对不对？问题是假设我们下载一个比如说高清的蓝光的电影，十个 g 甚至二十个 g 对吧？
45:43你现在相当于是你要磁盘上写四十个 g，我们知道今天 SSD 那写的次数可是有限的，写多了挂对吧？数据有限，所以我们一来不希望寿命简短。二来我们也不希望花太多的时间，
45:59因为你毕竟写两次时间，成本都在于，所以呢我们就去思考啊啊，这也是当然是有 case 吧。如果你要下载一个游戏的话，那你要写四百六十二 g 对吧？
46:13也太多了。好，我们就想一个办法，就是有一个经典的一个结论，叫做效率和公平，对吧？
46:23大家上政治课高中啊，离高中有点远啊，我们以前叫效率优先，兼顾公平。大家记得吗？这个吗？
46:37效率和公平。有的时候是是有矛矛盾的啊，我们为了效率往往就会牺牲空瓶，为了公平呢往往就会牺升效率。反过来，如果你想要提高效率，
46:51如果你要提高效率，那么你就不能一视同仁。你要去找哪些更重要，哪些更不重要。你要人为制造非公平。当你把这个非公平性制造的足够的多，
47:05你就发现哎呀，机会来了，本质上就是二八定理，对不对？二八定理不就是一个不公平人，这二十个人占百分之八十的时间，
47:17对不对？二八定理就是一个典型的不公平。换句话说，就是我们要快，你就要去，不能让所有东西都一样。
47:25于是我到我的危险就是去想什么东西更重要呢？我们发现原数据显然更重要啊，对不对？你数据丢了也就一个文件的事，原数据如果丢了，有可能会指到别的地方方去，
47:37可能会影响别人等等。所以原数据的重要性远超数据。于是呢我们就想我们能不能够只用 journal 去保护原数据，而不用数据啊，不用 journal 去保护数据。对于数据呢，
47:53我们只写一次。对于原数据呢，我们写两次，由于数据的大小远超原数据。所以当我们写两次原数据，但只写一次数据的时候，
48:06本质上增加的成本就非常小了。本来是从一变成二，现在我可能从一变成一点零零一，一点零零一呢，这个跟一也没什么区别，对不对？
48:18所以说这个是我们提的这个这个这个 EXT，它的这个中间这个模式叫 order move。 EST 呢一共有三种模式，大家知道有三种模式，第一种叫做 journal vote， journal 的就是所有数据写两遍，
48:38数据约束器全解完毕。最后一个呢叫 write back， write back 就是说我就写内存，然后呢不保证顺序 OK，这个几乎就是摆平躺平了，就是躺平。
48:53断电之后你自自求多福，但是我性能好，上面这个呢是性能特别差，但是呢我尽可能多的帮你 preserve 数据发生断电数据能多少，保存，能怎么多保存就自然就多保存好。
49:07第二种就是 order the mode。 order the mode 呢就是我们默认就是 data 写一次 meter， data 写两次。好，我们来看 case 啊，看看 case 这个真正多的里面呢是这样的，
49:20就是首先我们有数据 meter data 和这个 data 两个东西 application 在写入一个文件，或者是增加文件大小的时候呢，他就会两个都改。好，接下来呢就是我改个文件，对不对？
49:37我不时说先写文件，对不对，先写文件啊，反正文件的数据写了嘛，丢了也就丢了，那就无所谓。
49:43然后呢，这个文数据呢就进到磁盘了。注意啊，这个是 application，这个是 OS 里面的 fastism，这个是磁盘，
49:50非常有人磁盘，写到磁盘了就 OK 了。好， jia mode 的话是说呃 ordinary mode 就是说我把这个写进去，把磁拍上面先写这个 data，然后呢再写一个 journal of meter data 啊，
50:05 journal metal data。然后呢这个 mac 呢就会进行停车。同学们说他先两次网，不对新电灯，然后呢再写一个 commit 什么意思？短机会这个时候呢我们做一次做一次数据的这个写操作啊，
50:25需要用的用的 data 和 meta data 都已经在磁盘上，所以我就可以放心的去 commit，对不对？可以放心的 to lete。然后呢，我再把这个 mac data 和这个是一样的啊，
50:40写到他该在的这个地方写，他该在里头就行了。这个是我们说的这个加了折扣之后的这个操作。好，我们稍微休息休息一会儿啊，切亲嗯，
52:34是对是是亲有意一嘘。