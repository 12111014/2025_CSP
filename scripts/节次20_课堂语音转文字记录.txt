00:10嘘行嗯，嘘电视是驰，对，是嘘是咦切嘘是是嘘，是嗯嗯一。好，
05:32那我们继续好吧。行，上节课我们讲到了，你要让 primate back up 要有这样的一个容错的能力，提供有的背体，我们需要有一个程序，
05:40对吧？就非常快的去做这个从把把一些 haback banackup，从呃从呃把一些 back ackcheck 迁移 pripriate 如如，他怀疑这个 primate 过来的话，但是我们说这个里面有个很关键的问题，就是你用程序来做这件事会有 spiting。
05:54 ring ing 是说我两个人人同成为了 primarate。这个时候如果果个 priprimate，你同时他他接接 clilient 的请求去做做消息的话，那它其实就会有这样的一个问题。那么我们前面说我们为了保证这个怎么切换的这个这个这个这个正确性，我们说我们用一个人来切换，
06:10对吧？用 view server 来切换，是不是能避免这个问题呢？其实我们看到并没有，你即使是一个 view server 来切换，仍然会出现，
06:18在于比如说它网络分区的情况下，对吧？也会出现两个人 s 一和 s 二同时成为这个 prime 的这样的一个 case。那这个时候怎么办呢？我们说 view server 啊，它虽然没有办法避免这个 spreing bring 啊，
06:32但是它给我们了一种方法，那它给我们它使我们可以区分哪一个 primary 是最新的 primary，什么意思呢？我们说你这个 view 啊，这边这个每个那个所谓的 view 就是谁 pripriy 谁不它干嘛，它附带一个版本号。
06:46就比如说一开始是一，然后呢，比如说我们如果要让这个这个 s 二变成新的这个 primary，这是是实话。我要先有一个更大的 view 号和这样一个版本。然后呢，
06:58我同时还有一个要求，就是我一个 primy，他一个请求要要确保做完的时候怎么怎么办？得让他这个 backup 去 accept 这样的一个信息。就是我这个 back up 必须认认同，你这个 priver 就请求我才能才能做。
07:13那这个 back up 怎么认同呢？它必须得跟这个 primary 在同一个这个 view number 啊啊 view review number 下。那么大家想这样的话，我们有一个这个 view server，比如说我 v view server，这个这个这个这个个看就二二，
07:26对吧？ view number 二 primage 二。这个时候我如果这个 prime s 二，它这个这个这个这个时候如果如果它变成 primary 时候 s 一。如果他发了一个消息，来来么这个 s 二它其实就能把这个请求给 reject 掉。
07:41这样的话这个 s 一就知道它不是最新的 primary 开什么，他就把自己退出这样的一个 group 啊，就能够确保这样的一个正确性。然后当然这个这个这个这个同样的这个这个这个如果有个 backup，对吧？他把那个请求转发给他妹妹，
07:58他妹也得检查一下，就是说这个是不是最新的这个这个这个是这个这个请求 OK。好，那么这个时候呢我们就就能看到这样的一个这个这个我们来看一下这样的一个处理，处理的这个整个流程。好，
08:11假设我们有出现一个网络分区，这个 s 一和这个 view server 对吧？它的这个这个通信断掉了。好，然后这个时候呢，我们的这个 VO server 就让 s 二变成了 primit，
08:23而这个时候 s 一仍然是 primit。然后这个时候 s 一它仍然给 s 二发了个请求。那大家想想在这个时候 s 二怎么办呢？根据我们之前协议 s 二是可以做 s 一的这个请求的，对不对？因为他们两个还是在同一个这个 view 下，
08:38但大家想这个时候正不正确呢？其实也没有问题，对吧？它其实并没有任何正确性的问题，因为这个 s 二这个时候它还没有变成 primary。但是一旦啊我们发现这个 s 二变成了这样的一个 primary 的时候，
08:54这时候我们就如果 s 一再发一个请求的话，那它其实会被 reject 减掉。我们就会发现啊并不会出现就是一个人啊，同时他成为这样的一个这个这个这个啊并并不会出现这样一种情况。就是说这个这个两个妹同时在做这样的一个这个这个这个请求 prio k 所以这边它会有一个这样的一个这个 view 切换的过程。也就是说，
09:16当你的这个 s 二他没有受到这个任命的这个请求，即只是即使是我的这个这这个时候，它的这个整个 view server 它这个有变化其实也没有关系。因为我的整个系统，它是 work 在一个之前的 view 一上 OK。然后当我的这个这个这个这个这个这个这个呃这个这个 SR 对吧？
09:37他收到了这个这个这个这个这个没有任命的这样一个通知之后，其实这个时候 s 一它就没有办法 work。所以我们这个系统里面最终啊最终只有一个这样的一个一个 primdatata 后。那么它有一个这个这个这个这个这个 switch point，就是说当当我的这个这个 SR 能啊啊那这个这个这个这个听到了这个 u 的这个任命消息息时候，那我们这个系统才能才算算切换 OK。
10:03那这是这是我们目前为止的这样的一个第一步啊，第一步就是说啊如果 primary 怎么办？挂了怎么办啊，我们有一个 view server 去保证啊，我即使会有多个 primary switch ring 的这个情况下，最后只有一个 primary 去 work OK。
10:20那么这边位挂了是我们能够解决了，那么剩下我们需要解决什么呢？那我们就需要解决你的这个白 priackup 挂的情况，对吧？如果白 ackup 挂了怎么办？我们前面说之前我们的这个一个 solution 是说我们为了保证任性，
10:38我的一个这个 primary，它必须得等到什么，等到所有的这个 backub 都回回了，我才认为这个请求做完。那这样导致一个什么好处呢？好处就是说我一旦这个 primary 挂了 OK，
10:48我只需要什么去任意的这个个 ackup 里面去挑挑个这这样的个这个这个这个个 acktuup 去 work，就行了。但是这样的的一套方案会有一个缺陷啊，就是我们如果有一台白 cup 挂了，这个时候我的这个 priprimer 能不能继续的去工作呢？它显然没办法工作作了，
11:05因为我这个请求得等到什么，所有的 backup 都给 ACK 回了，回复了我才我才能做对吧。那这个时候，那我能不能有没有一种方法？有没有方法就是说我我可不可以不用等所有的 back ackup 都回复我的这个仓位也可以去往下做呢？
11:23往下做呢？比如说最简单的最简单的就是我比如说我有十台机器备份，那我是不是其中等六台机器返回了，我就认为我这个东西是是完成的呢。大家想这个东西它它的关键点取决于什么？就是我如果一个 primary 他要给他他的这个决决定，
11:46这个操作做完，那意味着什么？意味着说我这个操作一定得容错，对吧？这个操作就是我即使这个 primary 怎么变，这个操作作应该在这个 log 里，
11:55对不对？那大家想想，如果我们这个这个假设啊，我们去随便的去挑这个 back up，比如说我有我这这有个 quarry，然后呢，
12:05我有一开始我有一些 back up，两个 back up。然后我这个消息，比如说我就给第一个 back ackup 这个这个这个这个发了。然后我第一个 backup 返回，我就认为这个一个操作做完了。
12:16然后这个时候我如果这个门挂，然后我直接用这样的一个 backup 去做这个恢复，会出现什么情况？这个 backup 它会没有这样的一个操作的这样的一个信息，对不对？所以这意味着什么？
12:31意味着说我们在挑哪些 backup 成为如果第我们要实回为那么部分的。首先我们一得得实现部的这个 bback up 返回就就就就要返回给用户。为什么？因为你如果等所有的 backup 都返回，那如果有一个 backup 的话，你这个系统就过了没有。
12:46那那么我们要等部分这样的一个 backup 去去返回。就就就做的话，那么一定得做一些事。就是我们当去这个 partner 挂的时候，我们不能够去这个这个把任意的一个这个这个这个这个这个 backup 变成 primary，我们一定要去选什么？
13:03一定要去选那个 back ackup 这个这个用 log 最长的，对吧？做的操作最长的。那么我们怎么去保证这个我一定能挑到这样的一个时间。比如说比如说我我前面就呃我们这样一个 case 对吧？我们这个这个这个这个啊就写一台一台机器。
13:23那这个时候我如果两台机器都挂了，我们就没有办法没有办法去去恢复这样的一个操作了吗？操错了吗？那么这个时候就得提到一个非常重要的概念，叫做这个 corred 嘛 correer 这都是也就是说我们其实本质上要什么？本质上只要我们这个挑的这样的一个 back hp 的这个机器里面啊，
13:46包含了这个我这个 primarate 服务的这个请求就可以。那么我们的 private 这个服务的请求，假设它服务的这个 q 个 RRW 的这样的一个机器，对吧？那么我们到底要看我到底要去从哪些机器里挑，我才一定能够挑到这样的一个写的这个机器呢？
14:06其实我们只需要挑一个 beq r 的这个机器，使得这个 QR 大于 NN，就是总共的这个 rapid 卡的数量就行了。大家可以想象一下，假设我一开始对吧，有一个集合对吧？
14:18我这个集合，然后我这个集合这个这个是我这个这个写的这个集合，就是我要写到这样一个集合。然后我恢复的时候呢，我去挑一个这个读的集合，我使得说我这个读的集合的这个这个写交啊的它的这个这个总数是大于这个这个这个总的 realfic 是吧？
14:36这意味什么？因为说我们一定有一台机器，一定挑的那台机器里包含了我一个写成功的消息，对不对？那么我在这个挑的机器里面，我们去挑它这个 log 最长的这样的一个机器是不是就可以了，
14:50是不是就可以了？所以说这里面就会有一个小 face。就是说说第一啊，我们的这个 primate 这个 forward，它不不一定不一定需要去这个所有的这个 backup 都有这样的一个这个这个 reply 啊，只要有什么也要有一个这个 QW 个机器啊，
15:10 QR 个机器去返回就可以了。然后我们恢复的时候呢，就得加一个限制，就是我不能所有的 back up，我不能随便挑一个活着的 back。就是呃恢复不行，
15:19我得什么？我这得至少去挑这个 ackq r 个这样的一个这个这个这个 backup，然后再在其中去挑这个操作啊，这个数据最多的啊这样的一个白卡才能恢复。那这样才能保证什么？我既能保证没 laday，
15:34又又能够保证 consus 啊，假设 BU server 不挂，假设 BUUB 不挂挂 OK。那这个时候呢，当然这个协鱼会有很多的细节需要垂，但这细节不是很复杂。
15:42比如说有些细节是我这个 primary。如果这边给一部分的 back ackup 发消息，那万一有些 backup p 没有收到这个消息吧，它可能会漏。比如说我这个 primary 第一个操作发给了二三这两块色作，然后另一个操作他发给了三四，
15:55那怎么办呢？我们其实就需要什么？我们就需要去把这个呃去我们需要恢复的时候啊，其实需要把这个所有的这个 QR 的这个机器的 log 都给收集过来。然后做一个拼接，做一个拼接，
16:07然后再什么再去重新这个过之后，我们再去恢复啊，再恢复。所以会有一些这样一个细节的这个操作，但是它本质上的原理啊不会有特别大的这样的一个复杂七好。那我们来做一个总结啊，
16:23首先我们要让一个真正的这个 primary back up work 啊，我们首先有几步第一步就是我们只有一个 server 啊，在同时只有一个 server 啊，能够去决定这个操作的这个顺序。然后这个 server 有谁这个这个这个这个决定呢，它是这个由这个 bill server 来决定。
16:40然后这个 server 为了保证正确性啊，我一定要把这个消息啊给 forward 给这个这个服务的给这个这个这个这个这这个这个这个所有的这样的一个这个呃给给个至少 r 个这样的一个 backup 啊，让他们去给 AACK。然后呢，我恢复的如果这个 prime 挂了，我要去挑挑这个 back up 的候呢，
16:59我得挑至少 w 个 backup。这个 w 加 r 一定要大于总共的这个 rabbit 啊，然后呢我得把这个这个 w 个这个 back up 里面的这个 log 全都给收集了，收集做一个这个拼接。拼接完之后，我去把它重新做完一次备份之后，
17:13我才能够让这个新的这个 primarit 啊变成这个接受请求啊，大概就会有这样的一个操作。 ok 那那到这边为止呢，其实我们就把这个这个 private 啊 back up 的这个基本的这个这个这个这个这个方法啊讲完了啊，方法讲完了，那这套方法其实非常非常经典啊，
17:32就是说这个技术现然很多数据据心啊，它基本上都会采用这样一套方法。为什么呢？这套方法它的好处是它做一个操作的。这个时间非常快，就是我做一次操作，
17:42它只需要等 r 的这样的一个这个这个这个 backup 给 ACK 一轮一轮 long trip，一轮一轮网络王 trip 就能做完了啊，只要你这个 VO server 没有挂啊，我们后面介绍的方法，它基本上至少是需要两个龙雀本啊，或者说很多时候是需要两个狼雀的餐做，
17:58那它的这个系统还会更大一点，但是更大家更强一点，更强一点。好协议。那么我们现在啊讲完这个协议之后，我们其实可以看到唯一的问题是什么？
18:08唯一的问，就是说当我的这个刘斯策挂的时候怎么办？没斯斯乐挂的时候，我不是没有办法去判断，对吧？到底哪个这个色色色，
18:18这我就停止去哈，闭着，那这个时候怎么办呢？怎么办呢？我能不能保证这个协议呢？那么现那么另另一个今天我们要介绍的非常经典的方法啊，
18:28就是 pacthons 啊， pacthas 是能够保证啊，即使是我的这个这个这个这个啊这个这个这个没有用 server 的情况下，没有这个 primary back up 的这种情况下，也能够保证这个 consistency 和这个那个啥的 OK 请尽量 pythas 得还是得啊浓墨中笔的介绍一下，对吧？
18:49因为他是这个有有一个叫大一个大佬，对吧？拉来自于 lampod，不知知大家有没有听说过，现在啊大家已经听都有什么黑 hinton 之类的这样的一个名字，对吧？
18:58那但在啊我们那个年代对吧？这个这个大家听的最多的还是这个 lampod 这样的一个这个这个这个名字。然后蓝的话它是也是一四年的这种托理奖得主，对吧？托里奖得主它在分布式系统里面，基本上我们听到了很多分布式系统的这个技术啊，
19:14都是这个这个 lesson lampp 的这个这个老爷子提出来的。比如说啊我们可以看一下，这是他在一三年这个得奖的图灵鸟的这个这个这个这个这个这个词，对吧？我们可以看到一些很经典的概念。比如说我们今天这节课讲到的 repiiccy machine，
19:30对吧？像这个 qusalality，我们讲这个 eventually consistency 和就是我也有提到过，包括这个 logical clock。其实我们也提了 lapop，其实就 lapoical cclock，
19:38对吧？还有这个 sevl consistency 很多的内容说我们其中做推广。好，那么 lap pod 它其实非常有名的一个贡献之一啊之一是这个 pasxas 这个协议，这个 pythons 协议它能干什么事呢？它干事就是我有一个数据一个值，
19:54就一个数据值啊， replicate 带来很多的这样的一个 server 上。这个值可以是我的这个 view server 的这个 view OKOK。然后他们说呃蓝的发现啊，就是说你在一个分布式系统里面，完了所有的这个 server，
20:09在没有一个 view server 的情况下，我让所有的人去去同意。这个是最终市场，这个也是一个很难的这样的一个这个这个这个这个这个这个这个问题。好，一旦把这个问题解决了，
20:21我们就可以基于这个协议去实现任意的这样的一个这个 replicate 四角性。 OK 就这样一个观察 OK。好，那么我们来具体细化一下呢，实么叫做 agreree on a single value 呢。其实就是说我们这个这个问题啊，
20:36这个变量一开始是没有设置的。然后这个 VA 呢，我们为了容错我们把它给这个存在了很多台 server 上。然后我们对于这个 v 我们看着的操作就是什么呢？我就是我去设置这个某一台 server 的这个 VA，或者说我希望去读取这个 server 当前设置的 VA。
20:54然后我希望能达到条件，就是一旦我这个系统告诉你这个 VA 设置好了， OK 我就看一看，看到怎么看都是同一个 VA，不会出现另一个 VA。然后我看着可能会很多啊很多个人去并行去设置 UBA。
21:07 ok 看上去这是一个挺简单的问题，对吧？它难点是什么呢？难点在于我如果有两个人看一下啊，当然难点有两个。第一个是说我们要保证 variabty 什么意思呢？
21:18就是说我这 n 个 server 啊，其中只要有大部分的机器是好的，就 majority 就是它超过半数的机器是活着的那我就希望这个这个系统能够给我能正确的去做这个这个这个写入和这个这个这个这个这个这个读取的这样的一个操作啊，就是这样，这是 variability。然后所谓的这个这个另一个难点呢，
21:38就是说我的这个不同的 hde 可能会去并发的去设置在不同的机器设置这个 VA 这个问题其实就已经稍微有点 tricky，对吧？如果我不同的这个看 t 要并发的在这些 server 上去设置 VA，我怎么保证这些机器设置是同一个 VA？而这个 VA 它可它是容错的。就是说我即使我设完了这台 server，
21:58这台 server 挂了，然后我这个我这个往往往后还能读到同一个指标，都要分子的那怎么解决了这样的一个问题？我们现要先把这个问题简化简化。大家想想我们现在讲过的 primate acpup 里面，它其实有一个技术点已经能够帮我们解决一部分问题。
22:15什么意思啊？就是说我们大 pripriback k 的核心什么？就是如果我只有一个，我我知当当前的个个者者谁谁，对，就是我知道 primime 是 primary 是谁，
22:26我就是通过这个 view 来确定。我知道这个 serprime 是谁之后啊，我其实是能够通过我们前面讲的这个 column，就是这个多数学的方法来保证啊这个这个这个这个这个这个这个 availability。什么意思呢？就是我一个写我写写超过 QW，
22:42写 QW server。然后呢，我读的时候，我只要读 QR 的这样的一个 server，那我就一定能保证你虽然有机械化，但我一定是能读到我当时设置的这个值。
22:52只要我这个值是什么？这这个值是在 QW 的 server 上写成功了，对不对？而且而且呢我这个这个这个场景，如果我就一个写者，如果我有一个 public，
23:02但是不可能会出现我这个 server 会被写两个不同的值的问题的，对不对？对不不对？大家这个个其是是很简单的那所以 paxas 它的难点在于哪呢？难点在于，那如果我我的这个 writer，
23:16它没有办法确定，就我没有 view server。因为你想 view server，本质上来说，它也也可能会出错，我也需要 wrriver。
23:22对我如果没有 wrright，我没有这个个 view server 了，决决定谁出来呢？任意的人都可以成为 writer，这个时候怎么办怎么办？那所以 paxas 协议里面的后半部分，
23:36其实就是我们前面讲的这个要写 QW 的这个过程。然后它的前半部分实际上是在确定谁是当前这个系统里面能够写入的这样一个这个这个写者 OK。所以我们从这个角度，我觉得啊我个人觉得啊在这个理解 paxas 上面可能会简单一点啊，当然我我不知道有没有其他更好的想法，但是我觉得这个是可以来的。
23:59好，所以基于这个的话，我们再来看一下这个算法，我们就会发就可以稍微的去理解 paxas 的这个算法它到底包含哪些部分。好，首先我们可以看到第一这个我们的目标还是去统统一一个 VA。
24:13然后呢，我们的假设是呃大部分的 server 是好的，就是说我不是呃有 server 是可能会挂的，这个是你没法避免，但大部分不可能所有 server 都挂好。然后呢，
24:24在 paxas 里面它有三个角色啊，其中最重要的是 proposal 和这个 accept。其中 accept 就是说它会去决定这个 v 到底写成什么值。然后 proposal 它的作用就是这个这个这个这个我们前呃我们前面讲的就是我先要去确定啊，我是当前这个系统里面能能写的那个人。因为一旦我们确定好这个当前系统里，
24:46只有一个人能写的时候，大家想想我们就可以用前面这个 colun 的这个机制去保持正确性了。 OK 这这就是 passas 的这样的一些一些这个这个这个这个这个这个这个它的算法的这样的一个状态。然后我们的目标就是我们希望最终啊我看一看不同的看能够发起这个写的这个请求。但是只有一个人能成功，而且一旦一个人成功了啊，
25:09我们最后怎么读啊，都是那个值。然后这个值就可以是比如说我们之前讲的这个 view OK，那这就 pythas pythas。然后他的这个然后有了这样一个是我们可以具体再细化一下啊，具体细化在 pythce 里面的 correct 啊，
25:27就是负责发起请求的那个人。而 proposal 就是我们前面讲的这个这个这个这个这个这个这个协调者啊，他相当于是协调一下啊，当前这个系统谁能写。然后 accept 是当你的这个协调者啊，协调出谁能写之后啊，
25:42他会去具体的写这个值啊，最后 learn 啊就是会把这个协调出来，这个值写到系统里面啊， leve 其实不是特别重要，重要的是前面三者 OK。然后这三者啊会在这个放在这样的一个三台机器上，
25:56三台机器上。好好。那么我们从接接下来从这个具体的那从高层的这个方方法学，然后再到具体的实现啊，我们去来梳理一下这个 packel 怎么做的那 pathon 整体的这个协议啊，在正常的情况下，
26:10其实就是两步。第一步。我就是这个这个看呃一个一台机器 proposal 收到了看 rent 请求求后，他他会去发起一份协议啊，去判断一下他是不是当前系统里面唯一的这个写者。 OK。
26:24如果他拿到了这个当前系统里面唯一的写者这个这个判断之后，然后他去把这个要写的这个值去写给这个这个所有的 accept 而 accept。如果告诉他就是有一个 majority，就是大部分的这个机器啊，都 majority 都已经写完了。好，
26:42那么这个 leader 就认为这个 proposal 就认为这个事情做完了啊返回，否则啊这个这个这个就重重试啊，直到这个操作成功。好，那这边就会有第一个问题。第一个问题就是当我一个 proposal 要去写的时候，
26:58他怎么知道当前这个系统里只有他一个人在写的。大家想我们的 kind，比如说对吧？我们这个在这个这个设置里面，我一个看 ent 可以发给这个 propose a 然后另一个 kind 可以发给这个 proposal c 对吧？我们到底怎么判断这个这个这个哪个人是唯一可选的。
27:17那么这个大家想想，我们其实如果就跟我们 view 一样，如果你没有一个编号，没有一个 ID 的话，其实这两个写者是等价的。所以我们并不能区分出好坏。
27:26所以在 pssas 单里面，它有一个假设，就是我每一个写都有一个叫 propose how proposal。然后当前系统里最大的那个 propose 号的人才能够才能够写啊， purpose 有这样这的一个假设。但有个问题是，
27:43我们怎么知道你一个人是当前系统里面最大呢？就比如说我们有 n 台机器，对吧？我做什么操作才能够判断。我声音最大呢？其实只能做什么，
27:53就是我要把我的这个 purpose 号发给当前的这些所有的机器，然后去问我是不是当前最大的那如果是啊，他们就给我个反反馈，如果不是啊，他就不他就告诉你不是。那大家想想看，
28:05在什么样的一个情况下，我们能能确保在满足 availability 的情况下，确保这个这个这个这个这个机器，它一定是我这一定是当前这个序号最大的，就是我一超过半数的这个机器，它返回告诉我你是最大的，
28:22对不对？因为大家想想，这个时候如果有一个另一个并行的人，他的写者他的 propose 比我小，因为是不可能。如果他要访问半数的这样一个机器的话啊，
28:31我是不可能去拿到一个更大的这个 ACK 的。为什么？因为他一定会拿到一两个两两个两个科瑞形容的这个机器一定会有交集，那个这个交集一定能分出一个胜负，对不对？所以基于这样的话啊，
28:44那它在 python 十一里面我们就会发现，第一，它每台机器有一个 purpose number。就是我如果收到一个请求，我到底要以什么号发？然后呢，
28:54这个每台机器啊，它一定有一个叫什么一个叫 NH 的。这个值指指的是什么呢？就是说我当前看到的最大的这个 purpose 号，然后他看收到一个这个 propose 的这个请求之后呢，它会把这个 propose 号更新 OK。
29:09所以这是 panthons 目前的这个两个基本这样的一个这个这个这这个请求。好好，这个就剩下这两个，我们到之后再看啊，我们先看这两个，这两个是是我们现在做的一个事儿 OK。
29:22好，那我们来具体有了这样的一个概念之后，我们来具体来看我们怎么去确保谁是当前系统这个 wait write 这第一步啊，我们就看 lient 这个请求发给这个 proposal 啊。 proposal 呢它会自己创建一个 pro propose number n 啊，他希望尽可能会跳一个大，
29:37但不能跳更大也很大。因为你挑个最大的话，你这个系统肯定没办法握合。对吧你所有人都挑一个最最 maxmode 值。好，那挑完这个值之后呢，
29:44他就会把这个 n 发给这个 accept 啊，发给所有的 accept。 or 然后呢，他去看当前是不是这个系统里面有没有更大。然后这个 accept 每每个 accept 到到的时候，它就会先看。
29:56这个是 ID 是不是比我当前看到的这个 urpose 都大。如果都比我大好，我就告诉你你是当前最大的。当然它这边还有会带一个 value 啊，这个 value 我们之后再看是什么东西。好，
30:09然后呢他不仅答应，然后它还会它会有个 promise。什么呢？就是说呃你比我如果我收到一个比我更小的 purpose 啊，会比你这个 n 更小的 propose al，我就不接受它了。
30:18但大家想这意味着什么？但是想如果我这一个对吧？他收到了这个 majority 的这样一个值，就是我通过多我我大部分人都告诉我，你是当前最大的意味着什么？就是说我至少我在这个点一定是最大的，
30:34要么就是什么有一个更大的，他还没有还没有结束，对吧？他他还没有做完，但是至少在我当前这个时间点点，我一定是当前这个 purpose al 的最大。
30:43所以他就拿到了什么呢？他就拿到了这个当前系统里这个能写的这样的一个值，对吧？能能写的这样的一个权利权利，对吧？当我拿到这样一个能写的权利之后呢，
30:54我就去什么，我就去挑一个值，挑一个值。然后呢我把这个值去给这个这个再发配到超过半数的这样的一个机器。然后这些半数的这个机器呢，它看一下，
31:08看一下说什么呢？就第一，如果我你确实仍然是当前最大的这个 proposal，那我就把这个值给写写写入。如果不是的话，我就我就我就拒绝。
31:17因为大家想这个是什么情况，就是我一个 write 他，比如我当前五号是最大的。然后我我收完这个我 check 完之后，我再去写的时候，是不是可有可能会有另一个比，
31:27比如拿六号对吧？去把你这个值给覆盖掉，所以我写的时候一定还得再 check 一下。就是说我这个是不是一定一定能那个这我是不是一定是这个这个这个这个这个当前仍然是最大。所以第一有没有这样的一个 check？然后呢，
31:42大家想想，在这种情况下，如果我的这个这个这个这个这个这个这个这个 leader，他这个收到了这样的一个半数的这样一个请求了，半数这样的一个请求了。好，
31:56这个时候这个时候大家想，基本上我们就是不是就可以认为这个 value 能写回来。为什么？因为你不管以后你怎么去问啊，你这个你只要问超过半数的这样的一个这个这个 accept，他就他就会这个什么 ID，
32:09就会给一个就会把你之前注册的时候给读出来，对吧？那么这个是是我们这样的一套企业的这个基本流程。但是它有一些需要注意的点，就是大家你看第一我们看这里有一个两个这样的一个 value x highest value sector。就是我这个当前它会记一下当前这个协议，
32:28以及我这个每次我在这个收到 propose 的时候，我不仅要告诉你，你是当前最大的，我还得把这个这个注册的号也给发发回去。为什么会出这种情况？因为大家家想想，
32:39我们如果有一个 propose number 五的人写成功了，对吧？那么这时候我如果有一个 propose number 是六的人，他是不是用我们刚如果你不考虑之前这个 value 也能够写成功，那么我们为了保证一致性，我们得保证什么。
32:52就你这个 value 一旦写成功，它就不能被变对，不那怎么办办呢？我们需要要做一一操操作。就如果我一个 propopose 的的人写成功了，我们只是成功，
33:00就是我在超过半数的这个机器上都写筛写掉。那么我 propose number 是六的人，一定他要写的话，一定得用 purpose 五的这个 number 的人的值，对不对？那怎么做到这件事呢？
33:13一定我们就是对这个选择的这个 value 有一个限制。什么意思呢？就是我一个 writer，他在写的时候啊，他不能够随意挑选自己的值，什么意思？
33:26如果在 purpose 的时候相当于一个读的操作，我读的时候发现这个系统里面超已经读到了一个已有的这个值了。那么我下一次写的时候就不能够用这个这个这个我的新的值去覆盖，我已经得什么么挑这个已有的这个值去去写。那这边会有个问题，就是我有可能会不同的这个 right，
33:46对吧？比如说我有十台机器，有一个 right，他写了一个值二，有个机器写了一个四对吧，我有看到很多的这样的一个值，
33:52怎么办呢？那 pathas 它要求什么？就是我要选择这个 propose 号最高的，就是一定是 propose 号最大的那可那这不是这样的话就避免了这样的一个歧义。好，所以有了这样的一个东西呢，
34:03我们再去看他的这个协议里面，就会有这个这个这个这个这个 VA 和 NA 这个部分啊，这个部分就是为了去把之前已经写写成功的值给读回来。然后去确保我下一次写入。一定是用这个之前已经写成功的这样的一个值去写，而不是什么，
34:20而不是我去挑一个任意的这个协议值 OK。好，那这个为止就是这个呃 patthers 的这个完整的这样的一个大概的这样的协议。那这样的有了这样的一个基本的这个理解之后，们就可以去具体的啊去看一下这个里面的各种步骤，各种步骤。
34:39比如说啊我们我们可以来看一下具体的伪代码啊，我们具体的代码就是第一啊，我们一开始做的话，就是我 leader 干什么事呢？就是我先挑选一个 proposal，这个 proposal 要比我当前看到的最大。
34:50因为你比当前看到的不大的话，其实这个相对来说没什么意义。然后这个然后后这这这 propopoproprosal 他收到这个 proposal，他就会去看啊，我这个 n 是不是比我当前的这个 NH，就是我当前见过这个 proposal 更大。
35:02如果不是的话，然后他就告诉你你这个 propose 失败，如果如果我确实是最大的那我就把这个 NH 更新一下，就说明你哎你确实是当前最大的，然后他会什么？他会把 o promise OK 以及这个我当前这个这个注册的这个值啊这个 NA 啊，
35:18这个 VA 就是说我当前这个已经写过的值，如果有啊，如果有的话，写上去 OK。然后这个 leader 呢他会会去看，如我超过半数数的这个机器都告诉你，
35:28我是你是最大的那说明什么？在这个当前我这个系统中啊，一定我是我是最大的啊，一定我是最大。然后呢，这个这个时候我就去挑，
35:36我就去选择要写的这个值啊，这个值啊，不能是看一下任意选，他得这个 leader 得去看一下，就是说之前的那个叫什么这个这个 server，他有没有写过一个值啊，
35:45有没有写过值，就是不是这个这个这个就是是不是浪啊，是不是有个值是浪啊。如果不是到的话呢，它就是这个是个啊去挑一个当前这个这个这个写的这个这个 proposal 最大的这个人的这个这个值 OK 挑一下，挑一下这个值。
36:00然后呢他就去拿这个纸，去让这个其他人去 set 啊啊 set。那如果他没有拿到 majority，他就认为这次操作失败了啊，我就不是当前最大的 renger，所以我就重来重来。
36:12好，那么每个 accept 呢，他去拿到这个 acact t 就希望能写入的这个操作呢，他会先看一下你这个人当前是不是仍然最大的啊，你就是你的这个 NH 是你的这个人是不是仍然是这个最大。如果不是好，
36:27那我就直接就就就把你 accept 表告诉你，你当前不能写好。如果是的话，我就把这个值啊给写过去，然后告诉你这个 OK。然后呢，
36:35这个如果我这个 leader 啊，他从大多数人就半超过半数的人这边拿到了这个 act TOK，拿到了 accept OK 啊，我们就认为这个值啊写成功了。为什么要有一个大部分人这个概念呢？因为大家想想，
36:50一旦一个 leader，对吧？他在这个一个 writer，他在这个超过半数人，他都写成功了。这个值之后，
36:57你后面不管再有什么 write，我们都可以用类似这个 core 的这个值，它一定会在 propopose 用上把这个值给读回来。那这样的话，我的这个这个这个值他就不不可能再改变了啊，根据现在的这个 pxel 协议对吧？
37:10好吧，这个就是啊我觉得我觉得就是说这个用这种程度来啊方式来理解这个 python 可能比较的这个清楚一点。好，行，那这边可能我待会儿看起来比较抽象的吧。我们可以拿一个这个这个这个这个具体的这个执行图啊，
37:27可以带大家看看一下大家。比如说想想我们这个一开始对吧？一开始这个我们说这个数据这个 v 啊是这个 replicated 的 VA 啊，但是这个这个为了保证这个这个正确，为了保证性，我得去记一个什么，
37:39就是 NA 和这个 NH 啊， NH 就是我当前见过的最大的这个 propopoal able。然后然后 VA 呢是这个这个这个我我准备的的值 OK 啊。一开始比如说我这个当中那台机器啊想要去 purpose，那我就先把我自己的号加一对吧，然后去发几个呃 propoprom purpose 的这样的一个这样的一个请求 OK。
37:59然后这个是有两台机器，它会发现这个当前没有任何的 purpose，对吧？那么它都会给它做一个 promise OK 这样的一个事儿。然后呢，我再去把这个我挑挑的一个值一啊，
38:09你一个 accept 这个请求写进去。那如果这个当前最大额呢是 n 一的，就是说当前这个 writer 还是这个这个这个人啊，那我就直接去这个啊，直接去就就去把它这个这个写入 OK，那就这样这个结结束啊，
38:24做式比赛 OK。好，那么这个就是这个整个这个拍的流程。那但这套协议呢虽然看上去啊看上去比较的这个啊相对来说闹一点，但是他其实非常非常厉害。就是说这个协议能够在这个不同的这样的一个 pythcase 上就成立啊成立。
38:41比如说大家想想，如果我们有很多个人同时在写这个在这个 python 里面可不可能会有两个人同时达到这样一个这个 majurity，就就是两个人同时写成功呢？比如同时写成功呢？大家想他们能不能有两个人，能不能同时去过这个 prepare face 啊？
38:59不，这这 propose 的 face 对吧？大家想其实是啊不可能的，只有一个人的才。这当然我们得假设他们的这个 proposal 是不一样的啊，这如果 proposal 一样的就有问题。
39:08如果他 purposal 不一样，对吧？它只有一个人能成功啊。好，那如果有网络分区怎么办呢？如果网络分区这个东西有问题吗？
39:15那 pacthse 它假设什么？它假设是我只要有 majority，就是大部分的机器。所以只要你什么你你这个发起请求的这个 proposal，它是在一个大部分的人所在那个网络分区，那这个 pasass 其实仍然是不能成功的那如果我一个 leader 对吧？
39:30他跨学怎么办？如果我这个比如说我在 accept 的过程中啊， propose 就无所谓，对吧？因为 propopose 还没写，那我在 accept 的过程中，
39:37我在写的过程中，如果这个 leader 挂了怎么办？那么其实就会说我有一个少少部分的这样的一个机器，它会这个这个这个这个这个少少少部分机器可能写的只大部分机器没有写。那这个时候大家想这个数据其实仍然会被可能会被覆盖掉，对吧？
39:53因为我如果有另另外一个人，他如果拿了一个号更大，他去跟剩下的这个机器通信开始就覆盖掉。但这个时候大家想是没有问题，为什么？因为我这个这个一个数，
40:02它只要没有到达这个大部分的这个机器，这个数值其实仍然是是是是不会被这个这个这个这个能确保啊能恢复的。但在 pyython 里面只有什么？就是说我一个一个值，它在呃超过半数的这个机器上写入啊，它才能够恢复 OK。
40:17那最后就如果是我这个在超过半就写入了，这时候我挂了之候怎么办？就是怎么怎么办呢呢？这个时候其实我只要什么，我只要再发起一轮这个 purpose，我就能够把当前这个这个这个值都都在脑定。
40:29所以我们可以发现啊，这个这个这个 taxas 啊是一个其实是个非常这个这个这个啊这个这个这个这这个呃应该说熔度非非高的的事啊啊非常拢固非常高的协议。而且它这边很多的这样的一个这个设置，都是说都是都是这个这个这个这个比较合理的。比如说为什么这个 pythons 有很多的呃 ception 呢？就是说你即使有这个一个 suception 挂子啊，
40:54我其实也能够去做。然后这个这个为什么这个他不他的这个 purpose 的号是一直在变的？就他只是假设说我这个最 propopoal 最大的能成功的是因为你一个人 propose 这个人可能会挂，比如国内的可物挂。那我们需要在什么？在普行内的挂的情况下啊，
41:12这个这个这个这个也是能够握痕啊，那我这个如果这个这个这个这个这个这个有很多个 leader 在那边投票怎么办呢？我们这本说他也没关系的吧，只有一个人能成功啊，能成功。好，
41:25那么在 pacsts 里面呢，我有个非常重要的概就是就跟我们这个存在跟象。就是说它有一个叫同的 point，就是说我什么时候啊这个这个值能够确定被写入呢？那么这边其实有三个这个问题，对吧？
41:36来可以看一下，比如说啊这个这个这个 leader，他说到了 majority 的这个 promise 的时候，这个时候这个值被写了吧。其实并没有。因为你这个拿 promise 的这个过程，
41:46本质上是确认我是当前这个系统唯一一个能写的人。对吧这样过程，所以说他他只是确定我能写，但他并没有把没这个操作，已经写入了 OK。好，
41:55那么大家想想第二个问题，就是我如果 majority 的这个 accept 拿到了这个 accept，这个时候不能这个这个时候我我的拍这个值能不能确定呢？这个问题其实稍微具体一点，我是一个一我们前面一直在讲到，如果我这个 majority 的这个人收到了 set OK，
42:14然后我这个这个时候是不是这个值一定会被呃之后的这个 purpose 给看到呢？但是它这个有个前提，有个前提是什么？就是我这个 accept 的这个值啊，它一定要持久化的写入，什么意思？
42:27就是我收到了这个 accept，但是我这个如果这个 accept 在这个时间点挂了，那是不是等其实等价于我这个这个 accept 没有收到，对吧？你是没有办法区分这种这种情况的那只有我们要确认什么？就是确认你说这个 accept 这个这个值啊，
42:44他超过了这个就半数的人，他一定能持久化的这个写入了哎，我们这个时候才能够算算算这样的值。所以这意味着什么？意味着说我们在 passas 里边有一些东西是要持久化写入的。比如说前面我们刚刚讲的这个，
43:00我收到的这个请求不够，我还得保证什么我这个请求能得存下来，得存到磁盘里，得用 log 存下来。为什么？这如果你没有用 log 啊去存下来。
43:09这个时候如果我的这个机器 crash 了啊， crash，我这个这个这个我不就相当于我这个机器又能又又又能去 accept 新的值嘛。这个其实是不允许，所以我得去记这个这个 NA 和 DA，然后我还得记什么得记这个为什么？
43:23因为否则的话，如果我有一个这个相当于投票嘛，就比如说我的这个这个这个有有一台呃有一个 proposal，他的 proposal 是六，然后另一个 proposal 号是五。然后六的这个人，
43:36他拿了 propomajority 的这个机器的这个 ACK 了。然后这个时候如果有一台机器挂挂了。然后这个时候五大家想想这个时候如果他没有 GNH 的话，会出现什么情况？你的这个这个这个这个这个另外一个这个这个这个这个这个 proposal 是五的人，然然时时会拿到这个 majority writer，
43:55对不对？然后这个时候这个 proposal 等于五的，这个人还是会有可能去覆盖掉这样的一个 purposal，等于六个这样的一只。那这个其实是是也是有一问，因为他他违反了我们这个这个这个这个这个原则，
44:08就是说我在这个时候里面只有一个人啊，只有一个人能够能能够写入 OK 啊。所以说我们说在 pythas 里面还是要记很多的这样的一个这个这个这些这些东西还是都得 persist 出，只有你自己 propose 的这个号啊，还是不用 persist OK 行。那呃为了加深大家理解，
44:28对吧？我们可以啊用一个例子对吧？大家可以思考一下，这是其实也是 pythers 里面今年会去考虑问题。就说比如说我两个并行的这个 writer 啊， writer 可不可能会出现啊？
44:38虽然在某一在他的某一个 writer 视角，他用通过 proposal，他是当前唯一一个写的人，但会不会第二个人把第一个人的这个写去给覆盖掉呢？那他们在 passis 里面其实是其实是不会的啊，其实不会的那比如那我们来具体看一个例子，
44:55就假设我们有三个这个 accept ABCOK，然后 a 和 b 是 proposal。然后呢，这个这个我们下面这个事件啊会不会在这个发生呢？下面这件是说 a 啊，他首先先 prepare，
45:07然后他的呃 proposal m 是一好，他 prepare 成功。然后呢，这个这个 a 啊他就去给 a 和 c accept 啊，然后都成功了。然后他们的这个呃 accept 是负负 FO 这个值。
45:19然后呢，他的这个时候这个这个时候 a 挂啊， a 挂啊， BB 挂 b 挂。然后这个时候 a 突然挂 AA 突然挂，然后 b 恢复了啊，
45:28 b 恢复之后呢，他想要去，因为他没有收到 accept 嘛，所以他要去写一个新的值，所以呢他这个 prepare 的一个是二啊，他他他是我因为他他得是一个最大的这个值的 writers wrghers 啊，
45:42然后呢他这个这个这个就就就就就就从 b 和 c 拿到这个 promise OK，因为二确实是当前最大的对吧？那这个时候呢， b 发起了这样的一个霸这样的一个请求之后，我希望能够把霸这个就写掉。因为这个对这种情况，
45:57大家想想会不会在这个 taxas 的这个协里发生呢？我们可以举体来看一下。比如说一开始啊一开始这个 a 呀 a 它写的就是说这个这个这个这个 purple al 是一啊， propose 是一。然后呢，这个这个这个这个这个时候它这个一的这个东西啊，
46:15它就发给了这个这个这个 c 这台机器，然后他也想发给 b 这台机器啊，这个时候呢 b 这台机器挂了啊，挂了的话，然后他就没收到没收到。那这个时候呢，
46:27因为 a 他也给自己发了一下嘛，所以说 a 和这个 c 他本质上 a 是收到了超过半数的这个两台机器，我们超过出了两台这个机器。好，这个时候呢， a 他就给自己和这个负这个请求发到了 c 这台机器。
46:41然后成功了之后呢，他认为这个负已经写成成功了。好，那这个时候 a 挂了，挂了了后呢， b 的时候恢复了，
46:48 b 恢复了之后呢，他也收到了，看看前面又看 a 挂了嘛，就看着他并不知道这个当前写的值是什么。所以呢这个 b 啊他就会呃接替到这个 a 的上面啊去发一个请求。然后它这边的 propose al 就是二啊，
47:02就是我希望拿二这个 to propose。好，大家知道这个时候我去 b 和 c 啊，这个时候也能 propose 成为了。因为二它是当前最大的 proproposal，所以 b 成为了当前这个系统里的这个唯一的这样的一个 writer。
47:15好 wright ter。但 AA 因为 a 已经挂了， a 已经挂了。好，那么大家想想在这个时候， b 可不可能根据我们刚刚的算法，
47:25 b 可不可能再发一个这样的一个这个这个这个的这样的一个 buexcept，就给它自己和 c 呢？可不可能会出现这样一种情况啊，可不可能会出现这种情况啊，我们说不会，为什么？
47:38因为在 pythons 里面它有个限制，就是我要选择的这个 value 啊，它不仅仅是要 counite 值，它的 counite 发过来。这个 value 其实优先级并不高，它优先级最高的是什么？
47:49是当前统里面已经达成 majority 的这个 value 了。就是说系统里现当前达到 majority 是什么？是这个负这个值。对吧因为负这个值在 a 和 c 都已经存下来来，那怎么么实现我这个这个这个这个要写入的这个值，一定是当前这个系统已达成共识的这个这个值呢？
48:11在这个 b 的再往 c 发 promise 的时候， c 会告诉 b 就是当前我这个系统里面已经同意了一个值叫负。然后呢，这个 b 啊他在选择这个值时候，一定要选什么？这个当前系统里面已经同意过的值，
48:27只有如果没有，他才能选自己值。所以他在这边 seb 的时候，它会用这个负这个个值，而不是八这样的一个值啊去做同步。所以我们可以看到的一点就是在 pasthons 里面，
48:40只要我什么一个 value 啊，在这个超过这个半数的这样的一个这个基金上，对吧？我都获得了这样的一个这个这个这个这个这个 accept OK 啊这样的一个一个一个一个状态的话，其实这个值就会被永远保留了，永远保留。
48:57因为你你之后，无论你你要成为一个 right，你要成为一个 right 的前提是什你你就得先去看一下这个这个这个这个这个这个这个这个系统点赞。在这个 case 里面其实就是啊就是这个负这个值 OK，所以你怎么写啊，它其实都是一个负了。
49:12好，行，那到这边为止的话，我们就啊讲完了这个这个我们讲的一个经典的事情，叫做我们叫做啊 single 啊 decreree python 什么意思呢？就是说 pythons 就是我有一堆啊这个 rap case 的这个机器 OK。
49:26那这个机器呢我能够让他们说我不同的看一看去发起这个写的请求啊，但最终只有一个人成功。而且一旦他成功了啊，这个人这个这个这个人都都都能够啊这之后的怎么读，他都能够返回。而且我一旦成功就会出现一个什么事情呢？
49:41就是我的这个值啊，它是不会变的啊，就是说它它是不会变的。它它当然这个是卡斯斯要求，它还有很重要的一点就是 avilidating 就是在 passas 里面看，大家看所有的步骤，
49:53它都不是要求这个所有的人都成功，他才成功的，对不对？他都得要求，都什么都是这个 majority 的这个操作做完啊才能做。行，
50:03那我们再再休息啊。意 band，这是我是一个确定嗯，是是嗯，你的是就是这个是一天走，是行，
54:10我不说，如果了实行是是一个十刻的爱。