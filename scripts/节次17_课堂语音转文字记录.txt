02:31是嗯飞不会啊，我们继续 OK 上节课，我们讲到就是说你要判断对吧？一个并发执行是这个这个这个这个呃 select 的呃 seleariity 的啊。通常来如果你通过找一个这个这个任意的这样的一个线性调度，然后去枚举的话其实比较困难。
05:49所以一种比较好的方式就是我们用这个 confit graph 去指导我们去找这样的一个创新模式。然后 comfort graph 里面告诉我们什么呢？就是一旦我这个 transaction 里面这个 comfort graph 它是无还的 OK。那么这个并行一定是能够等价成某一个这样的一个线性的执行的那什么叫做 conflict 呢？就是说我如果两个其他就根据 rase condition 来定义，对吧？
06:13如果我两个这个传参线访问同一个数据，一个是写那么啊就有一个 conflict。那我们可以用一些具体的例子，对吧？来看这个其实在这个知识中其实是 work 的很好。比如说啊我们有两个 transaction，
06:25对吧？这两个 transacaction 一个是读 x 写 y 啊，另一个是这个啊读 x 第一个是读 x 读 y，然后写 y 然后第二个是写 x 和写 y。那么这两个 transaction 本质上是 config。那么我们这两个 transaction 如果是串行调度的话，
06:39那它其实就是呃有两种嘛，第一种就是 t 一在前， t 二在后对吧？第二个就是 t 二在前 t 一在后。好，那么我们可以看你假设我们有两种这样的一个并行的执行。
06:51比如说我一个并行执行是 t 二先 right，然后 t 一 read，然后 t 二再 right 在这种执行下的话，我们可以看到它的 conflict graph 是么？是其其实三三三三 conflict 向 t 吧。那第一个 conflict 边是 t 二指向 t 一。
07:05因为 t 二先写 t 一透读，所以是 t 二指向 t 一。然后第二个呢，其其也是 t 二啊， t 二指向 t 是什么？是因为 t 一它读到了 t 二的值，
07:14并且把 t 二 t 写指覆盖掉，所以也是有一条边。所以你刚可以看到它的 bof 里面只有一条边，就是 t 二指向 t 一。那这种情况下的话，我们可以看到它的最后的这个结果。
07:24实际上是对的，因为它那个二十和四十吧，等价于我们前面的，就是说 t 二在前 t 一在后的这个执行，对吧？大家像这个如果一开始时候是零的话，
07:33那么我们执行出来就是就是 x 等于二十，因为是 t 二写的，然后 y 是等于四四十，是这个这个在三十的基础上加十啊，这就对了。但是右边这种情况下，
07:45它其实有环，它其实就不是一个 CRSO。虽然它最后也是对的，比如说这个这个这个这个这个这个这个是吧？ t 一 read t 二覆盖了 t 二的这个 read，所以说是 t 一指向 t 二，
07:56但这边 t 一又指向了这种 t 二，它实际上是意味什么？因为 t 二指向 t 一它就是一个环，这个环它其实并不是一个啊 CRS 过的情况。因为你因为如果如果是这个这个这个我们假设 t 一在前的话， t 一在前的话，
08:10那么最后的这个这个 t 它读到的 x 呃读到的 y 应该是什么？应该是十，对吧？但是在这个情况下，读读到是三十，对吧？
08:17这是。那么如果是 t 二在前的话，那也不对， UT 应该要足到二十，对吧？所以说啊我们可以用这个 confit graph 能够很方便的这个这个判断出这个这个这个这个这个这个传载，
08:29是它到底是不是这样的一个呃这个一个并行的执行，到底是不是啊等家要串起来 OK。但是呢这边其实会有一个问题，就是说你 conflict graph 是一种帮助，我们快速找到哪个串执执行的这种方式是如果 conflict graph 的有环，它一定代表的说你你你没有办法做这个串行的执行嘛。
08:50其实不是的，我们其实来看一个这个例子，对吧？我们这个例子里边我们是三个线程并行执行，然后第一个线程是先读 x 第二个线程再写 x 然后第三个线程再读再写。然然后最后第啊不第一个线程再写 x 然后最后是 t 三去写 x。
09:07好，那么大家想想，我们根据这个能不能画出 conflt confet graph 的。首先我们可以看到对吧？ t 二是写了 t 一的然啊， t 一没有看到 t 二的值。
09:15所以我们应该有一条边什么是 t 二，在 t 一的后面对吧？ t 二指向 t 一 OK，然后呢，但是 t 一随后又把 t 二的这个这个值给覆盖了，所以我们又有什么？
09:25又有 t 一指向 t 二，对不对？然后最后这个其实本身就就是一个环环，对吧？所以我们其实不需要去看这个这个这个这个 t 三的这样的一个场场景，对吧？
09:35因为他们其实 t 三最后都应该是在他们的这样的一个这个后面。对，好，那么有了这样的一个 case 之后，大家想这个图在 confic COS wach 里面，我们就发现他他用这个 config graph 理论，
09:47我们会发现找不到一个创新执行。所以是不是我们能够认为这样的一个执行不是 COS broup 呢？其实不是的，因为我们可以来考虑一个最就是比如说我先跑 t 一再跑 t 二再跑 t 三，大家想想我这个病情的结果是不是等价于先跑 t 一再跑 t 二再跑 t 三呢？啊它其实是等价的，
10:08为什么？因为如果是先跑 t 再往 t 再把 t 三号，那么意味什么 t 一它读的是一个最初的数据状态。那么其实大家看这个 t 一，其实 VDX 它读的确实是一个最初始的这样一个状态，对不对？
10:20然后 t 二和 t 三他们因为没有写任何东西，所以说他们的这个顺序其实不重要，重要的是吧就是最终这个系统最后的这个状态是不是一个等价于创新值。那么我们说在这个系统里面，最终的状态是什么？是 t 三就 right x 对吧？
10:34就是我最后是 t 三写的这个那么在我们这个 b 型执行里面，最后的 x 也是被 t 三写的对吧？所以我们会发现一个东西，就是说这样的一个执行的话，它其实是符合 CCLS bility 的。但是如果它是在 conflict COS ability 的话，
10:51它其实不不会允许它执行。或者说它它不是 conflict。 c iliability 意味着什么呢？其实 view COS bility 就是我们前面判断判断最终等价的这个 view cesibility ility 是比 conflict COS ability ility 是更强的一个一个啊，或者说更加它允许更多的这样的一个并发场景出现。那么允许更多的并发场景出现，
11:11它意味着什么？意味着说你通常意味着说你你你会获得更好的性能，因为有些有些并发，对吧？你在 conflict ciixibility 是不被允许的。如果我们有一个系统实现了 conflict serisibility，
11:24那么这个系统它其实不会允许这样的一个并发出现。但是在 view seriarisibility，如果你跟系统实现了 view serisibility，它实际上是允许出现的那在这边呢会有一个很大的问题，就是你 view seriibbility，对不对？
11:38虽然它允许很多并发，但这个东西它没有办法去真实的去实现啊，是实际上是没有办法去真实实现。因为我们前面看到你判断 VUCSS ability，这个本身这件事情是 NP hard OK。那么所以现在人们用的最多的，
11:53我们叫做 CRSB ility ility 它其实本质上什么是一个叫做 conflict CRS sibility，为什么呢？因为第一它很好检查，很好检查又是什么？我们就可以证明某一些方法，它是实现这个 v conflict CRS bility 的。
12:06那么我们哪些方法是实现 conflict？ sibility ility 就是我们前面讲这个 to feace **king 对吧？ to feace slocking 那 two facebking 我们再回顾一下对吧？这个它的规则看上去是稍微有些奇怪，虽然它是为性能考虑它的规则什么，就第一我的这个拿锁是 on demand 的。
12:23就是我碰到一个数据的时候，我去拿这个数据对应的锁 OK，这这是这第一点。然后我可以提前放锁，只只要满足什么，只要满足说 OK 我放锁的时候，
12:35我过去再拿新的锁就可以了。那这个就是 tuface stolocking 这样一个方法，看上去是有点奇怪。因为我提前放锁意味着我一个 transaction 的这个中间数据是有可能会被相应看到的。但是我们说根据 view CE sibility 的这个啊不根根据 conicicc cisibility 定义的话，我们可以严格的这个证明这个一个 two fic slocking 下执行的结果，
12:57一定是符合 conflict CI sibility 的。而我如果不符合啊，对，一定一定是符合的。那么这样的就意味什么？就是我的这个 tufic stolocking 啊，
13:05就一定是对的。那么我们怎么证明它是一个满足 conconflict， sue sibility 的那但是啊我们要证明 conflict possibility 得证明什么？得证明一个 to feace loloky 执行下，对吧？它不可能会出现 conflict growth。
13:20那么我们其实我们可以用反证法来证明，就是看看如果出现了 conflict growth 对吧？它的执行会出现什么样的情况，对吧？那么我们根据 conflict sucispility ility 就我们能够反证法对吧？我们来证明，
13:33如果你要有个这样的一个这个这个这个这个这个这个这个这个这个这个如果如果你要呃如果你你你是不满足 complex acsoluity，那你一定会出现一个环，这个环会把这个操作，对吧？它是 t 一指，根据 complete 关系指向 t 二指向呱呱呱，
13:49最后得回到 t 一对吧。这是我们前面知道的一个事。然后那么我们怎么把它跟 two pace stoloking 联联系在一起。大家想想我们一个 conflict 呢，它一定会访问到一个共公共的这个数据，对吧？
14:02我们可以认为这个数据叫 x 那有了 x 之后，我们其实就可以什么就可以把它跟拿锁联系起来。为什么？因为根据 two face stolocking，我们定义我们在拿要在访问 x 之前，对吧？
14:14不管是 read 还是 right，我都得去拿一把锁，对吧？那这样我就可以把一个 two face stolokking 接起来。好，那么有了这样的环之后，
14:21我们就能画出一个 schedule，对吧？在 two pece loopking 下执行的 schedule。我们我们其实后面会看到，在这个 schedule 下，它是不可能会在 two piece open 里出现。
14:30所以我们能证明 q pese lopy ge 问题。那么具体来说，怎么这个 confiiccicisschedule 什呢呢？就比说说我们可以看到这个环代表什么？就是 t 一和 t 二在 x 一上 confit， t 二和 t 三在 x 二 confit t 以此类推 OK。
14:44那么一旦 confit，那么我们根据 confit 定义是说，如果 t 一指向 t 二意味什么？意味着 t 一先执行先执行在 two pece loping 意味着什么？意味着 t 一他先拿到了 x 一的 lock，然后 t 二再拿到了 x 一的 lock，
14:59对不对，对不对？是不是这样的一个一个事情 OK。好，行，那么我们看如果说 t 二他拿到了这个 x 一的 lock 意味着什么？
15:12意味着 t 一他在执行完这个拿路拿手机，他一定是 release 的这个 lock，他一定得把锁放了，对吧？因为我们根据锁的定义，你这个锁只有同一个人才能去拿 OK。
15:21那大家想想这样一个执行展开之后，大家会发现有什么问题啊，有什么问题啊？就是我 t 他 release a lock 之后，他在后面他又拿了一下锁，对吧？
15:33那像这个东西在 two face shopping 里面会不会成立呢？ two face lopping 说什么？就是一旦我拿到了这样的一个锁之后，我一旦放锁之后，我就不能再拿新的锁了，对吧？
15:42这就是 two face shopping 的定义。那大家想想看，那么如果说这样一个环 concept block 里面有个环意味着什么？意味着说我的这个 t 一定是先拿放了锁，然后后面又去拿了锁。那这不就是违反了这样的一个 socking 电影。
15:57那所以说这种情况下在 two face blocking 里是不存在的那意味着什么？意味着在 two face blocking 里面，它是不可能会出现这个这个 confit graph 的这个环的那我们就意味着什么？意味着 two phase blocking 你这个执行下来的结果，一定是等价于某一个串性的执行 OK。所以我们就可以用啊这个这个 confit graph 去证明一个方法啊，
16:16它一定是 CI abase 的那这套方法学其实非常重要。像现在的这个 data base 里面，对吧？它有很多 fancy 的这种啊这个这个并发控制方法。他们所有的这个据我了解啊，所有的这个证明它是正确性的，
16:29基本上都是用类似的这样一个反证法。就我先假设 OK 它有个环，然后证明在某个协议下不存在。所以这个其实大家比较到了 OK 行，那到这边为止的话，我们其实梳理到这边我们就讲完了。
16:42就是说基本的比如说我要确保对吧？并行执行提升吞吞吐下，怎么保证这样一个正确性。我们得走到一个 two ace ace loloking。但是关于 two p ace slogking 的话，还有两个两个东西需要注意啊，
16:55需要注意就是呃我们在 two v ace talking 里面，它保证正确性的一个非常重要的前提是什么呢？就是如果我有两个操作有 conflict 对吧？那么它一定得拿到同一把锁，对不对？但是如果有两个操作，
17:11有荒废，但你没有拿锁，你漏拿了一把锁怎么办？这个时候其实大家想想，其实很很直直观的讲度较张来说，它其实也也也不是也没有办法保证正确性，
17:20对不对？那这个例子其实非常非常经典。对于拿锁来说，尤其是你是这样一个心理读所这样的一个 case。比如说我们来考虑一个具体一点的例子啊，比如说啊我们去实现一个这个软院的这样的一个幺幺五，
17:33现在应该没软软啊，就是计算机学院对吧？我们实现一个这个发薪水的这样一个系统。那日系统的话，它有两个操作啊。第一个操作就是他把这个这个这个这个部门里的所有的人的这个这个这个薪水啊去做一个更新啊 a group。
17:48然后呢，第二个就是他会把整个部门的薪水都打下来，满足条件打下来。然后呢，以及我们去增加或者减少这样的一个这个这样的一个这个员工 OK。那么这个系统我们如果要实现的话，
18:01我们其实在内存里很容易实现，对吧？我们可以拿一个这个 list，对吧？我们就拿一个列表或者说 b 数，我们把所有的员工都存在存在一起，
18:10都存在一起 OK。那么在这个里面的话，我们说因为你大家想我们这一个操作，它得得有多个这个用户，对吧？所以说为了我们把为我么实现这个 be ofafter，
18:20我们加了一个限制，就是每一个操作员对吧？我们每个用呃每一个这个这个这个 mployer，我们都会有一个这个这个这个 lock 这样的一个 field，去保护这样的一个这个这个操作。然后我们采用就之前所说的这个 q face walking，
18:35就是说我们每访问一个雇员的之前 OK，我们都会去拿一下这个雇员对应的这个锁。然后呢，直到什么直到说然后放锁的时候呢，我就不去拿新的这个雇员操作了。好，
18:49我们来看一下这样的一个一个操作，一个操作 OK。我们假设有我们一开始啊这个所有的雇员有两位老师，对吧？海海波老师和这个陈老师然然后啊我们有两个这个这个更新的这样一个个 ansaction 啊，两个传的两个操作。
19:05第一个操作呢，它是说 anso k 我要把所所有的这个这个雇员里面，它这个薪水大于这个三千的雇员的时候呢，我就把他的这个这个这个这个啊这个这个这个薪水给给给给打出来。啊啊啊可以给他他的薪薪水，这个这个这个这这个这加薪薪啊加薪。
19:24然后呢，打完之后他再会会再便利一遍这个所有的这个雇园，把这个雇园里的这个这个这个这个薪水大于三千的给给给放转。然后呢，第二个事物呢就是说我会加两个新的雇员，对吧？
19:37一个是我一个人以下 OK，然后我们来看一个可能的执行流，对吧？第一个执行流就是我先便历一遍这个这个雇员列表。然后呢，我们把当前这个雇员里面的，
19:47比如说海波老师和陈龙老师，对吧？我们把他的这个锁拿好 OK，然后我去把他的这个这个这个这个这个钱给 update upupdate。这个时候呢，我们往这个这个这个里面去去加了这入这这个这个雇员。
20:02 OK 插入我和夏老师啊。这个时候呢，我在 t 一再去执行这个 print 这个操作时候呢，它就是再去把这个数据全都给读一遍，对吧？把如果如果没有拿锁的话，
20:12他就拿个锁，但海波老师他不用拿锁来，因为你前面已经拿了锁了。好，拿了锁之后呢，哎这样这样全部都做一遍 OK，
20:20这样就就做完了这样一个执行结果。好，那么大家想一想这个这个这样一个执行结果，它符不符合 CRS 变变，就是说它符不符合某一种情况，要么就是 t 二在前执行，
20:32要么就是 t 二在前执行啊，它符不符合呢，那我们符不符合。我们其实在这个 case 比较简单，对吧？我们可以啊，
20:39我们可以去这个这个这个遍历一下。说如果你 t 一在前意味着什么？意味着你后面这个 print 这个东西，它应该 print 出来的只有两位老师，对吧？它不应该 print 一位老师啊，
20:49不不应该 print 四位老师，对不对？如果你 t 一在前的话，那好，那如果你是 t 二在前的话，也有问题题，
20:56为什么？因为你 t 二在前，你的这 upupdate 应该是 update 四位老师，而不是两位老师，对不对？我们会发现你怎么排他，
21:04这个肯定就不是一个 theisible，那那那那有个问题，那大家想它符不符合 to face walking 呢？那我们前面说你在访问这个每个操作这些我都拿了锁，对吧？ t 一 t 二它显然可以这样执行。
21:14因为 t 一它在执行完前两大部队的时候，它其实并没有拿到新的雇员信息，所以他并没有拿新的雇员锁。那么我们 t 二当然是可以以这种方式执行，对不对？那么大家想想它的这个，
21:27那为什么会造成这种情况呢？我们说 to pace se locky，它是从理论上啊，我们是能够证明它是符合这个这个 CS 配置。那为什么你实际跑出来它却没有 COSB 背件呢？因为核心原因是什么？
21:40核心原因是你 to face locky，保证这个 CSV 的原因是所有的 conflict 都会被 truack。但在这个我们这样一个很简单的这个实现里面，它有一个 conflict，没有 truack，就是我插入列表这个过程跟你这个读取这个列表这个过程是没有是没有用一把锁去保护的啊，
22:00是没有锁锁去保护的。所以这个问题在这个 locking y 里面是是个很经典典，在数据库里面啊叫做一个 fatton，就换一个问题吧。但是它实际上是一个更加普遍的这样的一个问题。它的问题是什么呢？
22:12就是你有两个这操作，他们有 conflt，但是你却没有一把对应的锁去保护它。其实本质上是这样一个问题。所以如果我们要去实现，不管你用 to face soooking 也好，
22:26你用范老师也好，你要去保证严格的这个正确性的话，一定得保证什么一定得保证。就是我所有的这个 data item 这样一个 conflict 都得有一把锁保护。然后这个 data item 实际上是非常非常抽象，就说它可以是具体的我某一个 KPS 做的值，
22:42那它也可以是一些更大的概念。比如说我们前面说的这个这个整个雇员的这张这个这个这个列列表对吧？那么在数据库里面，它其实就是我一张整张表对吧？整张表它的这个范围的操作其实也是有可能会有冲突的。 OK 那这个东西的话，
22:58它会比我们之前的发包 OK 要稍微更难实现一点，为什么呢？因为如果我们之前比如说我们这是一个 PYS store，对吧？那么我们其实给每个 TPS store 加一块这个锁就可以了。但是你为了避免这种一些复杂的 confiict 操作出现，
23:14你得去引入一些什么高级的锁。比如说我们刚刚那个问题，其实什么高级实际上是说我这个前面一个 t 一对吧，他在访问这个 salary 大于的，就是工资大于等于三千。这个操作的时候，
23:26你其他人不能够插入一个这个工资大于等于三千的这样的这样的一个人，对吧？它实际上是这样一层关系。那这层关系呢，在数据库里面他们就会定义一个东西，叫做 predicicate lock 啊，
23:38就是说就是基于这种谓词的这样的一个啊基于这样的锁啊储回包。但是谓词的锁它会有一个问题，就是你你如果的谓词变得更加复杂了，是吧？你就不是大于等于你是一大堆这个这个这个这个这个这个这个这个这个位位置。连连接起来的话，
23:54那那它其实判断的开销其实非常大啊，所以通常情况下呢，也不一定也也也也是得看情况用。那么还有一种避免我们刚刚那种情况呢，就是说人们会发现就是其实很多时候我们对于这个这个这个这个这个这个范围的这种或者说这种比较大范围内查找的，他其实都会涉及什么都会涉及到这个这个这个索引的这个访问。
24:17比如说我们为了为了快速的去查找这个这个这个大于等于三千的这个人，对吧？一般来说我们会在这个金呃那个三就是就是金呃工资啊这样的一个这个条目上，我们去建一棵别墅。那这样的话，我本身我再去查找这样的一个过程中，
24:34我会去访问别墅。那理论上来说，大家想想我如果有个人要插入笔墅，有个人要读笔竖 scan 笔墅，那么它本身也有冲突。那这个冲突其实什么我可以通过这个去拿别墅的锁，
24:44致我把别墅的这个索引也当成一个 finguand loft 的这样一个部分。那其实就可以去避免啊上面这样的一种这种情况。当然还有一种方式，就是很多时候你因为你这种检查实际上是太过复杂了吧。所以啊一般来说也也可能会被这个这个就是不用了啊，就是我正常跑的程程啊，
25:03我就就是不不管它，那也是有方法。但是但是在怎么解决，反正是不同场景数据库有数据库的方法，对吧？笔触有笔触的方法。
25:11那我希望大家呃要这个就是说这在在用锁保护的时候，一定要注意，就是你锁一定要准确的 track 到你的这个 risconvertion tion。就是你这个 conflict，它其实啊远远比我们今天讲的这样的一个你就简单的读和写，对吧？
25:24要要稍微稍微复杂一点，那要复杂一点。对，行，那么除了这样一个这个我们要明确这个这个锁啊，它它那个叫什么要锁到呃确切的这个数据时候呢，
25:36在锁里面，它其实还有一个啊很重要的这个一呃问题要解决。这其实也是现在这个基于锁的这个系统啊，都会面临的一个问题，就是就死锁对吧？那么死锁它是什么呢？
25:47就是说我我一个揣家症，他比如再说为了保证真实性，我在访问数据的时候，我我我得去拿锁，他会不会有一种情况？就是我拿锁的时候，
26:00他就拿不到，怎么办怎么办？就是我是这个锁锁锁拿不到，而且这个锁他他是不大家锁你，可大家可能会想，就是我锁拿不到，
26:09对吧？他其实可能会出呃，出现原因就是另一个人他并没有放锁，那么我等他放锁不就行了吗？但是我们说 two be sworking 他的协议什么？就是他跑的过程中，
26:19他这个这个他是 on demonand 去拿锁，就是我碰到一个数据我再去拿锁。那会不会出现一种情况？就是我另我另我在等另一个放锁的那个人，对吧？那个人其实也在等锁，
26:30那不就如果两个人互相等，那这个事情不就是永远等下去，他就没有办法终结了嘛，对吧？这个事情其实你如果不考虑这个拿锁的这个顺序啊，其实是很容易出现的。
26:41我们可以来啊举一个例子啊，假设我们还是一样的，用 face ace walking 去保护这样一个东西。然后当 t face bcking 干的事情什么呢？就是 OK，我在这个访问数据前，
26:52我先拿把锁，然后我到这个所有数据操作完了，我再把所有锁锁放了，对吧？很直接。那么我们说这样一个锁，
26:58如果正常执行，比如说我先是 sred 零先访问 b 然后 swede 一先等它 b 的这个锁放完的话，它其实是是没有问题的对吧？它是可以严格正常执行下来的那这个时候我们把这个顺序啊稍微改一改啊，我们说 swead 零它先访呃 thread 先先访问了 a 啊，这个其实也很合理。
27:18因为 welead 一它这个拿锁实际上是可能是根据一个循环，对吧？读读哪哪个数据的时候，它就去拿因素。那这个会出现什么情况呢？那大家猜一下，
27:28我们假设一开始 thread 零，对吧？仿拿拿锁 b 哎， thread 零可以做，然后 thread 一他去拿锁 a 啊，他也可以做好。
27:37这时候我们他们两个独的数据做操作。那这个时候大家想 thread 零，他要把这个账户转给 a，所以他得拿 a 的锁。然后呢， thread 一他又要去审计这个 b 的数据，
27:47他又要拿 b 的锁 OK。那大家想想，当我们出现这种情况下，对吧？就没有一个人啊，没有一个人去去可以可以去这个这个解决这个问题。
27:57那这个就是在这个拿锁的这个这个情况下，你会出现一个很厉的问题，叫做叫做叫做死锁。 OK。那死锁的话是你基于 q 非 socking 对吧？实际上是不可避免的。
28:08那么怎么去解决这个问题呢？那有两个词，有很多协实能能够发明发发明很多所对。比如第一个首选。就是说啊我锁能不能以一个确定性的顺序拿锁，就是说我我 thread 零它如果先拿 b 那 thread 零一定也要先拿 b 就是说我对假设我们两个传载器对吧？
28:25要访问数据啊，但对于他们公共的这个数据，他们一定是以按照同一个顺序拿拿走。那这种情况下，它其实不会出现这样的一个这个这个死锁的问题。为什么呢？
28:37我们假设 t 一对吧，它这个这个 t 二它们分别其实我们也可以用这样的一个这个这个这个图图来表示。首先在大家想想，我们如果出现了一个死锁意味着什么？意味着其实就出现无非出现一种情况，就 t 一等于等待 t 二，
28:56然后 t 二等待 t 一。这个我们用用一个叫做 weight pss 就等待图来说明，对吧？那么假设 t 一等等于 t 二，那么一定他们会等等在什么等在一个数据上 a 上。那么如果 t 一等 t 二意味着什么呢？
29:09意味着 t 二它先拿了这个 a 的锁对吧？然后然后然后一样的，如果 t 二等于 t 一意味着什么？那么它肯定是等于另一个数据，我们叫做 b 那意味着什么？意味着说这个这个 t 一一定是先拿了这个 b 的锁，
29:24对不对？那这个有就有问题啊。因为你本身我们定义说大家拿的这个锁的顺序是要一样的，那么意味着什么呢？如果是 t 二先拿 a 的锁，那它在等 b 的锁意味什么？
29:34意味说它的顺序是 a 和 b 但是如果反过来的话，其实对于 t 这样的 case 呢，其实就是 b 和 a 那么说明什么？他们拿锁的顺序实际上是不一样的啊不一样的。当然所以说我们可以发现，就是如果你用一个确定的这个顺序去拿锁，
29:48其实是没有思索这个问题。当然这个是一个非常简单的这个证明啊，这个这个具体的证明其实跟那个那个 two face locking 那个实际上是证明是一样的，用用啊啊 rap 来证明。但是我们说这样的一种问题，有有一个什么样的一个缺陷的，
30:03或者包括所有的发出来 loking 都有缺陷陷什么呢？就很很时时候你一个个子一个个操作作要访问，哪些数据是不知道的。就是说他读写集的人不知道，比如说我有一些数据对吧？他是根据我执行的这个结果。
30:17比如说我读了某某个数据之后，我我去根据这个数据的这个结论去判断。比如说我要找工资大于等于三千的这样一个人，对不对？然后那我不去，或者对我不去读你的这个具体的这个工资，
30:29我是不知道我的这样的一个读写集。那这种情况下的话，我就没有办法通过提前提前去排序啊，去把这个问题解决。那怎么办呢？还有一个方法就是说啊其实其实其实我们也前面也看到，
30:44你如果会出现这样的一个死锁，一定会出现什么？就是是一个循环在那边循环等待，对吧？那么这种循环等待的关系，实际上就是可以用这个图找的图的这个这个这个环的这个算法去找到了，
30:58对不对？我们这比如说我们知道 t 一再等 t 二，那我们就可以画一条边。然后 t 二在等谁，我们也可以画一条边。然后这条边出完我们就可以得到一个完整的这个 with with with luh。
31:09然后我们如果找到了一个环意味着什么，一定就有个死锁。那么这个时候怎么办呢？我就把其中的一个喘塞器给它抱下来，就我让它不做啊，把它那不做的话，
31:18你环不就打打破了嘛。那么我我把所有的环都打破，那不理论上来说，我就可以没有死锁。这个开销对不对啊？我就没有思锁这个问题。
31:28那这个这个这个虽然是一种解法啊，但是它其实其实还是有两个问题，还是两个问题。第一个问题是说你去构建这个还这个事情啊，本身是很慢。大家想想我们的目标是什么的？
31:40目标是在你几百几千个字段上，我去并行跑这样的一个操作。那么跑这个操作，我要在这个几百几千的这个这个操作里面，我们去去构建这样一个 grss，对不对？
31:50大家想这个开销如果让你你实现这个的话，展家想这个开销肯定是不低的对吧？那第二个问题是，它其实并没有从根本解决问题。为什么？因为你它可能会有一个我们叫做 life of 客户。
32:00因为什么？你一个揣塞线，贝尔抱住贝尔抱住了怎么办？你得去重算，对吧？那个重算它一定会保证他不会再死守嘛，
32:08也不会对吧？所以说他其实也并没有完整的完完完整的去啊我去完全的去规避啊这样一个问题。当然现在用的最多的这种方法，比如说 mysql 这种用的比较多，数据库 mysql 或者 marria DB 对吧？他们其实用的是一个 huristic 的这样的方法，
32:26就是通过避免去构建 dialolog 的这个 graph 啊 way photograph 来去呃判断我这个是否这个系统里面会有 dialog。具体来说的话，他的方法很简单，就比如说我一个 transaction，对吧？他等了很久等了很久，
32:41有没有拿到锁，他就又他就猜了，他可能会遇到这个 dialog，那他就把它就可以了。那这种方法的话，它其实会有一些这个 false positive。
32:50就是本身它判断我们判断是你的这个这个这是是是是是是是死索，但实际上它没有思索。那这种里面有 boss 点，你的性能就会变差，对吧？包括你这这个它会来做，
33:00就就是你这个这个这个这个东西没有办法一直做完 OK。所以我们可以看到就是在 QV stocking 啊里面，它虽然有这个这个 to 它理论上说它把锁时间很短，然后呢它的这个这个这个这个你能保持任性。但是啊它因为 deadlock 的这样的一个问题啊，所以说它其实还是这个这个这个在实实在实际应用的过程中，
33:23还是有很多需要注意的地方。出了这样一个分层的问题。 OK。那么这个时候人们就在思考了。那既然我这个 tubace log 有这个 dialog 问题，对吧？
33:32那我们有没有办法避免 dialog 呢？那么大家想想， dialoog 是怎么产产生的？它根本原因就是说我为了保证这些事情，我了保证没有 waace 件性。我在 lotufbslock 在每一次访问数据前都得什么都得去拿一个锁，
33:47对吧？这本身是一个悲观的操作。因为本身你这个数据它不管有没有这样的一个这个这个这个 reace 条件，它它其实都得压缩。但是如果你没有 reace 创件，其实我这个提前拿锁这个事情是没有必要的对吧？
34:00它实际上实际上是个悲观的防御性的这样的操作。那么如果我们这样的一个系统里面，它的这个 restgletion 其实发生很概率很低的情况下，那我们是不是可以不用悲观的拿锁。比如说我们去乐观一点的去执行这样的一个 transaction。那么这边的话就引入了另一套就是 transaction 的流派，
34:21叫做这个 optimistic conrots control。那么 optimistic concurts control 呢，它其实就规避掉了 TVS opp 里面的这样一个 dialog e 问题。然后它的这个核心思想就是我在跑我这个操作的时候啊，我我先不打锁，我不打锁就没有 dialog 了，
34:36对不对？然后我做，但是不打锁会有一个问题。就是我这个做的这个过程中，它其实是会会可能会这个这个这个这个这个会会因为 this conclusion 造成问题，其他具体问题嘛就是我一个传家去读了一个数据，
34:51另一个呢把我写了，对吧？这就是这个 race 性里面一个最经典的这样的一个这样的一个在基本上的场场景。好，那么所以在这个乐观的做法呢，他就说好，
35:01我有 connerease 抗没没关系。那我在执行过程中呢，我去留一点，这个原数据使得说什么呢？使得说我在这个提交前啊，我去检查一下。
35:11如果我这个检查发发现没没有遇到行性，那我就提交，如果有，那怎么办？我再去处，我就去出，
35:18我就退退出工作。那如果我这个 ace 性发现概率很低的话，那大家想在乐观病发控制里面，它大部分情况下实际上是不用拿锁的对吧？那这个其实就 conliwork 的还是会比较好。所以这个乐观并发控制在呃做一个这个比较经典的这个方法，
35:34对吧？自从这个一九八一年以来，对吧？它其实也是用的就就比较多啊比较多，那我们就代么。那么大家想我们实现这套方法，
35:42它的核心在于什么？就第一乐观病方，我怎么去有效的检查出这个这个这个 riace 抗震性以及第二对吧？那我怎么怎么怎么保证？就是我最终的一定是一个正确的跟 TPS cking 一样的执行结果，对吧？
35:57好，那我们就来具体看一下。那么 OCC 的话，它这个执行这个传载值啊，它就分成两个阶段。第一个阶段就是执行阶段，
36:05执行阶段其实它就是跑你这个一个揣载值，或者说你的操作里面的这样一个所有的操作。那它和 TP ace socking 有三点不同。第一点就是它不打锁，它执行的时候，我就是直接读啊直接读。
36:18然后呢，但是它第二个不同，就是我读的这个数据啊，它会把它记录到一个这个 read set 里面。 read set 里面，就是说它会记录这个，
36:28就是说我会记一下啊，我到底读哪些数据，为什么要记呢？因为大家想如果我不记的话，我原么去检查一个你的这个这个如果做完了后，是是否我在我这个执行过程中发生了一次考虑写对吧？
36:39我得得记这个东西，所以说它会有一个这个额外的这个 read set 记录。然后呢，第三点就是它的这个所有的写啊，它不会直接写到你原本的数据里，它有点像我们这个啊这个 QQ。
36:51讲过 omin 一样，它先记到一个其他的地方缓存里啊，我们叫 luack buver。为什么有这个操作呢？因为原理其实也很简单，但是如果我直接写会怎么样，
36:59万一我这个喘息安全遇到了 recocondition，对吧？被掉了，那你这个写写你不是要擦去，但你一旦擦除，这数据据是是有可能会被别人看见吗？
37:08所以因为这个数据它并不是一个这个这个这个这个确定的种东西。所以我们得什么？我们得在这个这个这个且啊在在这做的过程，我们现在把这个写给缓存住 OK。好，那么当我这个操作做完了，
37:25 OCC 就会去检查一下啊，这个这个这个这个操作它是否符合 CRSBT。那它的检查的这个方案很简单，就是我这个执行过程中对吧？到底有没有预常？就是我在做完了之后，
37:37我会看一下我当前读的那些数据啊，到底有没有被人修改啊，都对是吧？如果有被人修改啊，虽然他可能也会满足 CRSBT，但是因为我们也没有一些更好的检查方法，
37:50所以我这个 OOCC 就认为就是直接那直接报它，直接 boss 掉。如果这个有数据被修改，就要保它，这其实也很符合很符合这样的一个直觉，对不对？
38:00那如果没有数据被修改意，为什么？就是我这个在这个存载性做的过程中，没有遇到任何的这样的一个啊 race condition。那那这个时候我就直接给 abort t 掉， bot 掉。
38:12但这个时候的话，其实有两点，当然有一点大家可能好奇，对吧？为什么我只检查 read，我不检查 right，
38:18对吧？因为我们说根据 race condition 的定义，你如果两访问两个数，你至少有一个是 right，那到它不是本身，也也有可能实际上是一个这样的一个这样的一个微斯考虑性吧。
38:32那这个时候其实是出于两点考虑，就是第一就正一般来说正常的那个叫什么访问流是什么？就是大家一般访问数据不大会出现。我是比如说一个操作，我只写一个数据不大会了。一般什么呢？
38:43它比如说 t 一是什么？是一个 read x red x 这样的一个形式，所以就我先读一下值，然后根据这个值去修改。比如说我们之前加起来，那这种情况下，
38:53我如果 t 二只有个 right x 的话，那么它的这个这个这个比如说我在这个这 gvalization，那么这个时候的话，其实是是 OCC 的这个 read set 的检查，实际上是能检查出来的对吧？这是第一点。
39:05第二点就是如果有一些极端的情况，对吧？我这个 traction 它就没有这个 red x 它就只有 ride x。那我我不检查这样的一个 x 有没有被修改，有没有关系呢？其实没有关系，
39:16为什么？因为我这个它并没有读任何的数据，它只是在这个 commit 阶段去去做一个 update，对吧？所以你这样的一个 plan 呢，它其实也也其实是符合这样的一个这个 ranresponuntion。
39:27所以我们在检查的时候，我们只需要检查什么？检查你的这个 redit 是我们没修改。其实因为你的 redit 实际上是在这一质量改的，你并不是在这个执行过程中改的啊，当然这边就会有一个要求，
39:38就是你的 validation 和这个 commit，它必须得是一个原子的。就这两个本身也你不能说我刚刚 validation 过了，然后有有修改了，这是不对的对吧？那么这个时候我们还是所以还是需要一些啊并发控制啊，
39:51这个时候我们大家会说啊，这是 OCC 实现比较 trick 的一点啊。好，那么我们来我们当然前面是一个 high level 的这样的一个思想，对吧？思想很简单，
40:03但是它在实现的时候，就像我们前面说你就亏个三十了嘛。它其实有一些啊需要注意的地方，我们来具体看一下那个它每一步到底怎么走的。比如说假设我要实现这个 OCC，对吧？
40:20那我们说它跟 QPL 不一样， two PSO 片不一样一样。就是第一啊，我一开始我得初始化一个 VUI set，对吧？记录一下这个这个很直观，
40:28比较确定的点是当我去读一个数据的时候，我需要去记录这个数据的值，对吧？以去判以以使得我在这个提交阶段去判断这个东西有没有修改，那这个记录会比较 tricking。那大家想想看，
40:44我这个记录该怎么记啊，该怎么记？它其实有有有一个 tricking 点就，我能不能我我我我是怎么去判断我这个 transaction，对吧？它在这个执行过程中，
40:55有没有受到这个 with condition 的这样一个影响？大家想想有没有有没有可能这个这个其实是表示出我我如果一种方式是什么方式，就是我记一下。比如我当时读的 x 是等于一，是不是？比如说我 t 一我这边记录一下，
41:10我这个 x 等一，它是这个叫 face e 对吧？ face 一 IX 等 e 然后呢，我 YI 这些的时候，我就判断下来，我是 AX read，
41:19对吧？ x read x read 是否等于是否和当前的最新的这个 x 一样。如果一样，我就认为它这个这个这个这个没有没有这个这个 reconlection 这个方法，对不对呢？这个方法是吧对不对？
41:34这个方法其实不对的，它会遇到一个经典的叫做 ABA 的问题，什么意思呢？就是比如说我这个 t 一，他在 face 一的时候读到的 x 是一，我们要干的是什么？
41:46检测出我在个安连线阶段，这个一会不会这个 x 有没有被人修改过，对不对？就是说如果有一个 transaction t 二，它在同的 bface 里把 x 比如改成二。然后这个时候有另一个 transaction，
41:58他又把 x 二又改成一对吧。这个时候大家叫为什么叫 BB 啊？因为 x 是一二一，它又变回来了，它又变回来了。这个时候大家想想，
42:08我们站在这个 t 一的角度来说，如果我们只是通过这个 value 去判断有没有 rease condition，它是判断不出来的。因为其实是有 rease condition 为 t 二和 t 三是写了这个 t 一的这个数据，对不对？所以通常我们再去检查这个东西的时候呢，
42:24有两两个考虑。第一个就是我在读这个数据的时候，不能有人在写，就是不能有任何人在写，就比面样原子这个还相对来说比较好像我可以用一个翻译官状状来实实验或者其他方法。第二个呢，
42:36就是说我这个读的时候啊，我一般不能够直接以这个数值来判断这个是否是否有 rease 函件。我应该是什么。一般的做法是我用一个叫版本号，就是我会 read set。它应该是等于比如说 x 和 x 的 version，
42:51就是 x 的这个版本，它会读这样一个东西。然后我每一次扩灭，它这边读回来的就会变成 x 等于一，然后 version 等于等于一。然后我每一次 commit 的时候呢，
43:01我们会把这个这个这个 version 加一。比如说这边就 x 等于二二，然后呢 x 等于一三啊，这是它的版本号。这个时候呢，我最后是 ization 的时候，
43:12判断什么判断的实际上是这个这个 x reset 的这个这个版本对吧？一是否等于 x 的这个一就是它相当于是个个是个是个是个降降速，速速啊，通过这样一种啊判断方式啊，才能够规避掉之前所说的这样的一个这个这个 ABA 的问题啊，通常这样。
43:31所以我们在 OCC 里面，我们去判断这个 rese 可能性，实际上是要是要注意这样一点的 OK。好，那么对对于 read 啊，我们需要去注意一下这一点。
43:42那么对于啊这个这个这个这个 right 的话啊，它其实就是相对来说简单一点，对吧？我们就直接去啊更新一下这个东西。当然这边稍微有点需要注意的，就是说如果我有一个这个喘参性里面，
43:53对吧？我我是再读了一次 a 怎么办？那如果你是根据 CIS blation 的话，那我一定得读到自己的写。所以说我一定得更新一下这个 real set 里面的 a 啊，对吧？
44:03就是说相当于这个这个是比较直观的 OK。好，那么最后口碑的时候我们就做两件事。第一件事就是判断啊这个我这个 read set 里面所有数据有没有变判断方式，就是就是用我们前面讲的这个用版本号，而不是用数据的值。
44:22然后如果版本号变了，那怎么办？那我们呃版本号变了，我们就要报了，对吧？如果版本号不变，
44:28那我们就把这个当前的这个所有的这个 right set 里面的这个数据啊，全都全都写回去 OK。那这个就是一个比较完这样的一个这个 OCC 的这样一个具体的实现。那么除了这样一个前面我们说的这个 read，就每读一个数据，我们需要考虑这个 NBA 的这个问题以外，
44:48我们还需要考虑一个点，就是这个 validation 啊和这个 right，它本身也需要满足一个 behlor。就是说我一个 transaction 在做这个 validation 的时候，对吧？跟它有 rease condition 的这个 validation commit，
45:02不能够在它当中有一个这个 internet 的实现。因为这样的的话，如果你有 internet 就会出现，就我这个 y daction 过了，这个时候另一个人也另一个人把我的这个这个这个修改。那它本质上不是还是会有一个这样的一个 reace colalition 嘛啊我们可以来看一个具体的啊非常简单的这样一例子。
45:23咱们假设啊我们有这个两个 transaction，对吧？就是 a 呃两个 traction 都干一件事，就是我给 a 和 b 都加一。然后我第一阶段啊，我们这两个 transaction 读的都是啊最初的版本 a 它的版本是 t 零，
45:38然后这个 b 他们也是七零 OK。这个时候大家想想，如果我们的这个 face 二和 face 三允许分开执行。就比如说我这个 t 一它 valieate a 和 b 之后， t 二也能 varieed a 和 b 冲突。大家想想这是会走出现什么情况？
45:52按照我们现在的协议，这个 a 呃 t 一和 t 二它都是能够 variation 过过，对不对？好，那大家想想一旦他 t 一 t 二都 valieine 过了意味什么？意味着说 t 一它会把这个自己的这个写就是 AT 零加一写回去啊，
46:07 t 二会把自己写进行加一些。只是说我这两个 transstion 各执行了一个 a 加二等于一。那最终 a 被加了什么？最终 a 只会被加一次，对吧？那这个显然不是满足 CRSB 减，
46:21所以我们怎么避免它呢？我们得避免，就是说得把这个某一个 validation 得移到这个 communment 之后，对吧？大家想想，一旦我这个 t 二的这个 valid，
46:30它是到这个这个 right 之后，那这个时候它其实就会 abort 掉，为什么？因为它这个里面没有读到这个 t 的这个修改，对不对？所以这这就是 OCC 里面一个实现啊，
46:43另一个需要注意的地方。就是我的这个 validation 和这个 committer，它实际上也是需要呃一个 before after 的一个原原子性呢，就是我们需要原呃我们去实现原子性的这样一个系统啊，本身也是需要一定的原子性的。好，
46:59那么我们怎么去实现这个二和三的原子性呢？那么其实我们能不能再用一次 OCC 呢？那这肯定不行，对吧？因为这就无限递归了，那怎么办呢？
47:08那其实我们就可以用到啊上一节课讲讲的对吧？就是我们可以用基于 rocking basase 的方法。那最简单的方法其实就是我在 vdicate commbit 的时候，我加一把锁，对吧？加把锁，
47:20只有一个人同一个系统里面只有一个人它它能能能做 valdcommbit。这个实现其实看上去非常简单，看上去很有问题，对吧？但是它其实用的非常多，很多 OCC 的这个实现啊，
47:31它都是都是在 vdit combit 拿一把锁，你知道一把锁。那这时候大家肯定会想一个问题，就是哎那你这个不就会出现之前所说的，这个它会退化成单线程的的情况。那那么 OCC 里面为什么它会允许这种这种 case 呢？
47:47其实它的一个核心原因在于 CC 啊，它它这个做操作过程中，它其实里面只有很小一部分会拿这个做。大家想想 OCC 总共是三个 face，对吧？ face 二和 face 三其实是很短的，
47:58因为它只对这个传塞程做验证和这个提交它大部分的时间。什么是花在 face 一？那么在 face 一的情况下，其实不同的这个线程它是可以这个并行的做。所以你在 OCC 里面， OCC 里面啊，
48:14其实用一把大锁，其实在很多时候也不会特别大特别大的问题。当然我们其实也可以用 to face loloclocking 去去去保护这样的一个 auteracity，对不对？那这边就会有一个问题，有个问题，
48:27什么问题呢？大家想想我们这个这个前面说了 to pace ace locking 啊，你有思索，然后我们要提出这个 OCC 啊，它没有思锁，但问题是我们这个 face 和 face 三要保证原子性，
48:39原子性怎么办？我只我也我也得用这个这个这个问个这个拿锁，那不又递归了吗？你这边不是还是会有一个 deadlock 嘛，对不对？那大家想想，
48:49我们在 OCC 里面，如果我们在这个 mamazination，然后这个 commit 这个阶段，我用这个 q be scking，有没有办法去避免思索呢？避免思索。
48:59再来想想我们避免思索的有哪几种方法。第一个方法是经历我们讲的地方是吧？是说你要只要保证每个人拿锁的这个顺序是一样的是吧？那它就不会锁。那么我们拿锁顺序一样的，前提是什么？
49:12就是我得知道这个这个这个这个我一个传呃一个操作，它到底要访问哪些数据的哪些数，对不对？那么大家想在 OCC 里面，我们可不可以知道这件事呢？我们可以看这段代码，
49:25我们其实会发现现 two pace ce lolocking 不一样， OCC 在做 valization 和提交的阶段，它其实是是知道 rewrite set，对吧？你 to face lock acking 是不知道，因为我跑的是用户的代码，
49:36但是 OCC 它的这个代码实际上是他都是知道 rewrst 为什么他只知道因为这个 rerese set 是什么，是你这个 face 一执行过程中去发现过来的。那么有了这样一个发现之后，我们就会发现啊，我拿锁我要拿锁，其实在 OSC 里面是非常确定的那有了这样一个确定之后，
49:55我们其实什么我们其实就可以在一开始啊我们先把 real al set 把它做一个合并，然后把合并后的这个 set 我们去做一个排序。排完序之后，再按照按照某一个确定的序，比如说数据的 key 的大小，对吧？
50:08去拿锁。这个时候我们其实就可以规避掉在 OCC 里面去。这个这个这个我们之前说的在 OCC 啊，这个 key stopping 死锁的这样一个问题，我先休息一下。有一千块哦，
50:33没没有，是不是一嘘是是是有短系进，你是的，为什么？就我们一楼一楼室六忘了是识别东西在前面。对。