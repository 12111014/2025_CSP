01:02嗯嗯嗯嗯嗯，嗯嗯，我是好，我们继续啊，我们继续。那前面呢我们就讲 CPU 虚拟化了，
05:44对吧？我们的引入的问题是说一行代码作为一个特权指令是如何跑在非特别急啊，朋友们看我们讲两种方法。第三个方法是 terrible solution，就是我们说的这个节目，然后他是要把这个特权的这个指令删掉，
06:07但你删是肯定不能直接删的，对不对？你删掉的话，怎么 work 怎么 work。所以我们需要把这个特权的这种指令啊，尤其是那十七条指令转换成 hyperor code，
06:20他直接主动的去产生这个 track。这就是我们说的这个 parale anslation 就做。那么最后一种做法的话呢，就是这个硬件的这个支撑。载一塔呢他最早就提出了一种新的一种模式啊，就是说这个东西我们就改不了了，
06:43我们就要加一层 interrection，加一层套一层套娃，或者说这个套壳对吧？套一壳也进一步证明计算机里面的问题都可以通过加一层加一个层次来解决。那么传统文化呢我们知道有运零和运三，那既然你解决不了，
07:04所以呢我就在前面加一个 root，就变成了 root 下的瑞 ing 和 rin 三和 non root 下面的瑞名和 ring 三啊， non root 在这儿 on root。所以呢传统的 application 和 host OS 就变成了 root 模式，下载瑞明和三。而在虚拟机里面呢，
07:23就变成了 non root 模式下的 ring 和 renside。这两者呢它的关系就是我在 root 模式下可以起多个囊 root 模式的这个虚拟机。这个是我们说的这个当时做这个意义。有了它之后呢，第二方面就是所有的应用程序在盖括各洞里面啊，再告诉你们，
07:48如果跑一条十跑那个十七条指令之后就触发一个 remaxed，然后呢这边就可以做 imilate，所以这个就变成了 trap and intervenit mente 完了之后再返回回去，这个是问题，这个没有第四种。好，
08:04那就是我们说 CPU 的这个接下来呢我们来讲 violalamemory 的这个 versulation memory violation 呢，它的核心是要去把这个 MMU 把它给关。好啊，六六个，那 MMU 怎么管呢？我们说这个 OS 啊，
08:23这个时候就要去做这个，我们知道这个我复习一下，简单复习一下的话就是 processors 啊，他在每读一条这个 cash 的时候啊，或者说每读一个 memory 的时候，都要去做这个 VA，
08:38就 go address 到 physical address 的这样一个翻译，对吧？那做一次翻译，这个翻译就是由 MMU 来做的。翻译呢是要用到列表，列表呢就是由 c 加三来指定啊，
08:48这里有一个 pay able，这有这些。然后呢，如果说转换成这个 physical dress 之后啊，然后呢我就先去读 cathe catch，如果中了就直接回 catch 不中。
09:01那我再再读真正的在这个过程中呢，其实是我们把这个虚拟地址和物理地址的转换，以及 cash 和 memory 之间的关系啊，我们把它画到一起啊，把它放到一块儿。在这个这个 MMU 是 CPU 的一部啊，
09:21 CPU 的一列表，我们就要复习一下，页表比较简单，对吧？每个进程都有自己的页表页表去记录了。不同内存页啊是如何映射到这个虚拟页？
09:32每个页呢都有一个不一样的一个 permission，比如说有读有写，还有一个可执行。为了去虚拟化这个页表，或者说我们首先为什么要虚拟化这个页表？原因很简单，
09:45是因为列表这一个啊，一百九一一个 CPU 只有一个 c 加三。当你运行的时候呢啊这或者说这个 MMU 整个系统这个 CPU 只有一个，那我们就需要去虚拟化这唯一的一个，否则的话就会打架，对不对？
10:01你说我要这么干改一点，他说要那么改一点，就会打架啊。这样的话呢我们就可以把这个打架的问题把它给解决掉。在虚拟机里面的话呢，有三种地址，
10:13对吧？分别叫 GBAGPA 和这个 HPA。其中这个 HPA 就是原来的物理地址啊，跟我原来物地是一模一样的。这个 GBA 和 GPA 呢算是多出来啊，它是运行在 nonroot 模式下才有这个这个问题。
10:31然后呢，我们来看一张图，在这个图里面我们可以看到啊这个加三在这儿。然后呢，他需要去把这个 GPA，对吧？
10:43我们说 GPA 要翻译成这个 GGBA，要翻译成 GPA，再翻译成 HP 啊。因为页表有一个自己内部的聚家，有自己内部的这个页表啊，因为它叫金融融前的逻辑嘛，
10:57所以它内部有一个页页表，对页表显示的假页表。然后真的列表呢或者说这个 CR 三这个硬件上的这个 CR 三指向列表只有一个。所以这个问题就来了，就是我们现在虚拟机里面有虚拟地址和物理地址，虚拟机外面呢有真正的物理地址，
11:15这三个地址要去做翻译就很麻烦。因为我的这个 CR 三上面的这个列表只能翻译两个地址，就是从一个地址翻译成另一个地址，它只能翻译一次。但是我们在真正的虚拟虚拟虚拟机里面的话呢，需要翻译两次，
11:31分别是虚拟机里面的虚拟地址和虚拟机里面的物理地址，再到物理机上面的物理地址，也就是 GVA 到 GPA 到 HP。那我只有一个列表，七加三只能指向一个列表，我怎么才能够翻译两次呢？
11:51对吧？我只能翻一次，但是现在我却需要翻两次，怎么办呢？这个时候就需要把这个 GPA 和这个 HPA，也就是 guest 内部的列表和 host 内部的页表，
12:03把它给整理合在一起，叫合二为一，两个页表变成一个页表。那两个列表怎么变成一个页表呢？原因很简单，就是我们要把每一个这个 guest 列表中的 GBA 先去找到对应的 GPA，
12:21再去通过这个 host 的列表找到对应的 HPA。这样的话呢我就生成了一个新的列表，直接从 GBA 翻译成 HP，直接从 GB 翻译成 HP。这样一来的话呢，就能够解决啊，
12:38我们前面说的一个列表只能翻译一次，对吧？只能从一个地址翻译到另一个地址，但实际上却有三个地址的这样一个问题，就是具体的这个翻译的这个方法。如果我们在构造一个这样的一个新的这个列表的时候呢，
12:56大家看对于从零到二的二十次方，这写的这要是是这个上标从零到二的二十次方里面所有的 GPA，然后呢去找只要它的 p 位啊，只要 guest page table 里面的这个 p 位被至少表示它是 prepresent，确实是有效的。我们就通过 guest page table 的级别找到了 GPA，
13:18再把这个 GPA 传到 hopapage page table 里面去找到对应的 HP，然后再把 shalw page table 里面的级别设成真正的刚刚找到了这个 HP，然后把它吸回去，这就是我们说的这个构造，下入培训的方法。也就说这两张 guest 内部的 page table，
13:37 host 内部的 page table 合二为一之后就变成了一张 shallow page table。为什么叫它 shallow page table？原因很简单，是因为 shadow 嘛，就是看不见的，对不对？
13:49在真正的 guest 想要去看页表，看到的是什么？页表注意啊，他看到的是 GPA， host 要去看页表，看到的是面表。
13:58注意，它看到的是 HP，所以这个 shdow pay table 其实是他们直接看 get 文页码，或者 post get OS 和 host OS 都看不见的东西。那什么时候它能够被看见呢？就是当发生切换的时候，
14:12发生切换的时候，所以呢我们当时呢就有一个问题，就是说如果现在有十个虚拟机，对吧？跑在十跑在一个机器上，每个虚拟机里面呢有十个应用程序。
14:23那么当前一共有多少个限额配置？由这个问题的话就比较简单了，对吧？问题就比较简单，为什么？因为 shadow page table 是 per application 的啊，
14:45是 per application 的，为什么是 per application？因为每个 guest 内部的列表都要生成一个对应的销道配置。所以说 guest 内部有多少应用程序，它就有多少医疗，它有多少列表，
15:03它就有多少 shadow 配置 host。 paytable 呢是 prevent 啊 gueas， paytable 是 prevication。好，接下来又出了这个这个第三种，就是这个 harveway support 啊。
15:18就是你第一，我们前面说的这个 shelw， y shaable 是一种在硬件上不用改变的一个方法，为什么呢？因为这 CPU 的意见，然后呢，
15:29这上面有个 c 加三，这是页表寄存器，对吧？页表基地址寄存器它只有一个，所以直播去了。那么如果我们改意见的话会怎么样呢？
15:50好， OK，我们改应这个方法放到后面再讲啊，是作为这个呃下一个第三种这个方法，我们这边还是持续在这个这个这个销售 page table 里面去。好，
16:02现在我们已经有销售 page table 了。然后当这个 guest OS 啊，它去改自己页表的时候，就会发现一个问题，就是没效果，为什么呢？
16:12因为我们还是看到前面这张图，对吧？就是当 guest BM 上面某一个应用程序在运行的时候，真正起作用的也就是这个 CR 三真正指向的这个位置。其实 seleictable OK 继续销售配置结果。然后呢，
16:28当我这个 guess OS 他去改列表的时候，改的是这个 guest 配置，结果改这个赔盖死赔西朵其实是没有用的，为什么没有用？因为真正起作用的是这个下道退退的，所以我们必须要形成一种联动。
16:42就是当 guest 改配 ace get pastable 的时候，这个对应的 sherapy y saver 也必须要做相应的更改。这就来问题了，就是我们作为一个虚拟机来说的话，我怎么知道 guest 改了自己的页表呢？有一种办法，
17:00就是我让我在这个这个 guest 每次在写内存的时候，就判断他写的这个内存地址是不是页表地址，这是一种办法。如果是我就改一改，不是我就不改。但这种情况毫无疑问就会让这个 overhead 非常非常的高，
17:18对不对？你每每每改一次内存，你要判断一下我改内存到底是不是再改一改就很慢。所以我不能这么做。那我们最后怎么做的呢？其实也很简单，
17:29就是我们要把 guest paytable 设成 read only，这是动西那。你说 cassppical 它不是 read al 的呀，它不是的问题没关系，我们在 reshadow pastl，因为这个是我们们可以控制 shadow page table 是 have weather 可以控制的。
17:49我们在 shadow page table 里面把 guest page table 所对应的物理也设成 redoing。这样的话呢，一旦有人要去写的时候，就会产生一个 page force，对吧？就产生一个 page faut t 这 papage flt 就可以被认为是 trap，
18:05我们就可以做 emillate trap and immilate。然后呢， VMM 就去处理这个配置 force，一看哦，你 get 要改列表，那就判断一下你为什么要改一个。
18:16而且啊你确实要改列表，因为你马上要改切切换，或者说你要你要去做一个 memory 的这个 map，所以你要改的列表，然后呢， VMM 就替 guest 把这个相配配 table 把它给改了。
18:30 OK 同时也把这个他自己的 guest 配结我改，就把这两个一起改，然后再刷一下 TLB 就可以啊。就是 guest 本来要去改这个 guepc 股，现在变成了 read only，所以呢它就一下子就 trap 出来了。
18:47 check 出来呢，我 VMM，我 VMM 是什么都可以写的啊，你设成 v ad only 我也可以写。所以呢 VMM 就把这个 SPT 和这个 GPT 两个就同时把它改掉。改掉完了之后呢哎就继续执行这样的话呢这个 guest 对于它自己的 page table，
19:04这是改动，也会起作用。为什么？因为 shadow page table 也跟着一块儿改。好，接下来一个问题，
19:16如果一个 guest educution 访问他自己的内核的 memory 怎么办看啊？这个问题其实也是一个新的一个问题。为什么会有这样一个问题呢？是因为现在 application 和 guest OS 都跑到用户台了，都跑用户台啊。注意，
19:34我现在还没有提这个硬件的改动啊，我们还是可以还是假设硬件是不改的，硬件改动。我们后面作为第三个方板来介绍，在不改硬件的情况下，应用程序现在和 OS 内核都跑在非特权级，
19:50也就是用户台。这样一来的话呢，他如果真的要去改，以前只有内核才能改的那些地址，那些物理内存就会成功哈，以前是失败的，
20:01现在会成功。为啥我们平起平坐了？我们两个我是 application，那你是内核，我们现在都在用它，我们的权限是一样的。
20:09那就有问题了，怎么解决问题呢？一种方法是我们把 shadow page 啊呃 shadow page table。刚刚我们说有一个 shadow page table，对不对？我们把 shadow page table 一分为二变成两个列表，
20:26那为什么要变成两个列表呢？第一个表是 guess OS 在跑，既然该 OS 的跑，那这里所有的这个对于 guest 来说，所有的内存页它都是可以访问的，它自己的所有内存页都可以访问。
20:41所以呢它它它的页内存页里面就包含了内核的映射和用户态地址的映射。但是当 application 去跑的时候呢，就把上面这块把它给删掉啊，把这个这个这个这个这个列表或者说这个一半的列表把它删掉，或者就设成一个不合法的一个值啊，就是那个不合法的一个值。
21:08为什么这么做呢？是因为当用户在跑的时候，他不能够去访问内核的数据页，对吧？这个是天经地义的。所以呢就需要在这两个列表之间拿回去切换。
21:21那你说这两个列表这个切换的话，什么时候切换呢？那就是进 guest kernel 和出 guest curerl 的时候要去做这个切换，这样的话就保证这个区域是用户太没有办法好啊，那好有点像是这个我一个客户的一个应用程序，他进内核对吧？
21:46进内核的时候，给他所有的权限出内核的时候呢，我只给他没有映射内核地址空间的那个页表。那你说我能不能够把这个列表改了，这个列表不行，这个列表删到培训结果它没法改啊，
22:00应用程序没有办法去改，删掉的培训结果只有 py 了才可以改，对不对？这点比较容易理解。好，那我们刚刚问过的一个问题，
22:11再问大家一下，对吧？假设有十个虚拟机好在一台物理机上，然后呢每个虚拟机里面呢有十个 application。那请问现在有多少个个 shelpacciple 啊？刚刚我们说一百十乘十就等于一百，
22:26现在我们可能还得加一点加什么？你每个应用程序或者说每个现在其实都是都已经有这个两个列表了，对不对啊？都有两个列表。那所以说其实你的列表还要乘以二哈，你列表还要乘以二，
22:42就变成了两百的仪表。当然这只是我们说从这个逻辑上简化环境，得到这个页表。在真实的产品下面的话呢，比如说在 up 上面 arm 的话，有两个这个寄存器的这个净离子寄存器，
23:00可以认为有两个 CR 三，一个 CR 三指向用户，一个 CR 三指向内核。所以对于这个 arm 来说，一个应用程序，它本来就是研究者，
23:11所以呢就这个问题就不是就就不太一样了啊，就不太一样。对于 f 八六来说，它只有一个 CS 三，所以它只有一个列表，所以呢它大概率是有两个列表才行。
23:22那 arm 的话就稍微有点不同，但这只是小的细一点。好，这是我们说的第一种方法，叫做 shadow page table。第二种方法呢，
23:32我们把它叫做 direct region，它也是一种 parroof virtualization 的方法。我们前面提过 para of viittualization， paris 就是半虚拟化，它是要改 guess OS。那么当我们想要使用 direct 配置的时候的思路是什么呢？
23:49其实也非常简单，就是我们为什么还要给 guest OS 一种假象，好像他拐着一一段连续的这个物理内存呢，我们能不能够不要给他这个假象？换句说啊，我们以前的做法是一个应用权。
24:07一个 OS 启动完了之后，用 guess OS 启动完之后，对吧？假设我整个电整个计算机有六十四 g 内存，然后我给第一个八 g 进去八 g 但这个八 g 可能是分散在很多地方的。我们学过内存的管理，
24:22我们知道巴 g system 啊啊这个 slop 算法啊等等，内存它不一定是连续的，对不对？好，我现在呢启的第一个虚拟机，它有八 g 内存。
24:33然后呢，我们的前一种做法是，我们假装告诉这个虚拟机，你有八 g 连续的内存，但实际上这八 g 内存不连续。所以呢我们就需要再做一次映射，
24:46把这个八 g 内存的这个幻象映射到真正的物理的这个内存里面去。从而给 guest OS 一个假象。什么假象？你有八 g 连续的内存，而且是物理内存啊，而且是物理内存。
25:05但是为什么要维护这样一个假象呢？我们能不能够就真实的告诉应用，告诉这个 application，或者说告诉这个虚拟机，我真实的告诉这个虚拟机，我给你八 g 内存，
25:16但这八千内存是不连续的，它分别在这儿这儿这儿它的地址就是真正的物理地址，也就是 HP。这样的话呢，就这个作为这个 OS 来说的话，它会有一个困难，
25:29就是它的管理起来很困难，对不对？它本来连续内存好管啊，现在你这儿给一块，那给一块，那管起来就相对来说难度会更大一些，
25:38但也不是不能管，对吧？无非就是稍微稍微复杂一些，那它的好处是什么呢？它的好处就是中间的这一层，所谓的 guest，
25:47 physical address 就没了啊。以前我们是有一层叫 guest physical dress，对不对？现在 guest physical dress 就没了，他看到的直接就是就是 host physical dress 和和 guest virtual dress 啊，那么他要做的事情就是我怎么样在 guest will address 和 physical 和可这个 host feeld address 之间去做这个页表，
26:09也就是他直接就去管类似于我们前面所提到的 shadow page table 的这样的一个数据结构啊，他直接就管了，不用再做一次转换。那么这么做呢，其实是有一些风险的啊，是有一些风险，
26:24什么风险呢？第一个风西，就是他现在能够看到真实的 physical 的这个 host， physical 的这个 address。那么如果说一个恶意的 guest 或者一个不受信任的 guess，他把一个不属于自己这个内存范围的这个 HPA 写到这个列表里面去会怎么样？
26:49是不是就意味着它可以跨越虚拟机的这个边界去访问自己。原来没有没有权限访问的这个内存单，我们只能说有这个可能啊有这个可能。所以呢每次去真正的去设列表的时候，不可能让这个虚拟机自己去设列表。它只能够告诉 OS code 告诉 OS 我要把哪一块 VA 和哪一块 PA 做一个映射，
27:18由 host 去决定啊，或者由 headvisor 去判断说，你给我的这个 physical address 是不是在我刚才分配给你的，那若干块 phythal address 的范围之内，如果是我就让你做，如果不是，
27:35那我就不让你做。这个逻辑其实是非常啊是非常清晰的啊，这个逻辑是非常清晰 ok 啊，这个是我们说的这个这个这个 direct patient 的这样一种方式啊，第二 page 方式。那么它的好处的话呢，
27:51就是由于我已经打明牌了哈，我不玩不玩虚拟化的这个这个游戏了，我就告诉你 application 呃应用那个 gueas VM，你就三块内存合在一块，也就八个 g 啊。因为是在这儿这儿这儿三块啊，
28:05别的地方你你你问我别的地方干嘛了啊，你别问你就是给别人了，这也没关系。它的好处就是说它这个打平牌，所以呢实现起来呢相对会简单，这是第一。
28:16第二个是它的性能会更好一些，为什么性能会更好一些呢？是因为它都改了嘛，对不对？它都改了，所以呢他就干脆改的好一点啊。
28:25比如说啊他会把这个 application 啊这个这个 guest OS，他不是一次一次一次去做这个页表修改工作，而是一次性把所有要对页表修改的工作合在一起，打个包 bh 一下。然后呢就去做这个去做这个这个事。完了之后去做这个呃做这个 bcsco o 这个这个这个这个 hibco 啊 haper co。
28:51这样的话呢就能够解决我们前面说的这个频繁的去改列表，会导致频繁的切换到 have weather 啊这样一个这样一个问题。把这个危害的把它进一步降低缺点缺点的话也是很很很明显的。第一， OS 要改，不是透明的，
29:11不改就用不了。所以像早期像 windows 这种就用不了啊，临 x 的话你可以改一改，可以，这是第第二 guest，知道的太多了，
29:21知道太多了。比如说他发现哎，我是你这个内存，一共有一共有多少 g 我不知道，但是我知道你给我分的的是是这个一 g 到两 g 对吧？然后三十五 g 到三十六 g 对吧？
29:35还有是这个六十一 g 到六十二 g 你给我分了三个 g 啊，根据你跟我分的东西，我就可以反推出一些信息。比如说我可以反推出，你这个内存至少有六十四 g 因为你把六十二到六十三给我了，但你内存至少六十四 g 对不对？
29:50这是第一个，它可以反推出当前的这个这个这个呃内存有多大。但是说你反向内存多大有什么用呢？它还可以通过 HPA，知道谁在谁的隔壁，对吧？
30:05就比如说他如果自己知道是一到二对吧？然后是二点二点五到三点五对吧？然后是这个四刀，那么中间有些空的地方，他一想肯定是被别人用了。既然是被别人用了，
30:23那我就可以去想我能不能够通过像我们第一节课的时候讲那个 rohammer 这样的攻击，对吧？通过频繁的读取一块内存去干扰旁边的这个内存啊，反正我知道我在这儿，那我我就知道我的隔壁在什么地方啊，他就可以通过这种像有 hammer 这样的攻击去这个做坏事啊，
30:45去做坏事啊，这是我们说的它的一个缺点，暴露的信息太多了。第三种方法就是我们说的 harry support 啊，就是这个硬件支持硬件怎么支持呢？它也是经历了一个阶段，
31:01早期的这个虚拟化。有了这个之后啊，还没有直接支持这个内存的虚拟化啊，呃先有 CPU 虚拟化才有这个内存的虚拟化是吧？我们就回到前面那个页里，就是当时我们说啊这个 CPU 它只有一个 CSI，
31:17或者说只有一个液表寄存器，但是呢我却有两层列表，对吧？一层是 guest 内部的 PT，还有一层是 host 里面的 PT 啊，它有两层。
31:26那你有两个列表，那你只有一个列表，寄地 g 粒址寄存器，那就产生矛盾。其实方法也很简单，对吧？
31:32就是我直接再加一个页表基粒址寄存器就可以了。这种问题解决。所以就很多事儿就交给哈罗尔去做的话，就变得很简单。有了这个两个页表之后的话呢，页表的翻译就从原来的这个线性。
31:52对，这是原原来线性对吧？我们 CSI 指向一个列表，表表里面呢呢根据据个你的这个个呃这个叫某某呃虚拟地址里面的某几个 bit 找到一个偏移。然后呢加上去之后呢，又找到一个页表啊，
32:07然后呢就一层一层往下，最后有四层能够完成这个操作，能完成地址搬运操作，这是以前的。那么在虚拟化里面呢，它变成了一个两维的对吧？
32:19因为你有两种地址，一种是 GBA，还有一种是这个 GPA，对吧？还还有 HP 三种地址，我们来看第三句是怎么翻译的啊，
32:34传进来一个 GBA 大 GBA，然后呢还有一个 guest 四加三和一个 nested， nested 就是真的就后四首 meis jasa。那那在这个盖茨 c 加三呢，要先经过它是盖世 c 加三，本身是一个 GPG 呃，
32:49 GPA 短 GPA。这个 GPA 要经过四层，才能够最终翻译成 HP。翻成 HPA 之后呢，就找到了这个下一个。下一个时候呢，
33:02又继续要找四个四个，四个，四个，最后一共要找二十次，才能够把这个一个地址翻译完。所以呢，
33:11当时在一九九五呃，二零零五年的时候呢，当时这个 VMV 就写了一篇论文，写什么论文呢？就是说你英特尔马上要推出这个，你看你做一次地址翻译，
33:21居然需要二十次的这个这个这个这个这个这个这个这个仿真是吧？这每次都仿真太慢了，你看我 VM where 多好，我 VM where 用 shadow page table 的方法，对吧？我只要一次保存就可以，
33:36你要二十次保松啊，远远有上升的，必须下次飞机。对，就是 shadow pay c table 也不是也不是就一次保存啊。我们这面 shdodopay c able 的话，
33:46它其实就是就是这个啊就是相当于是五次保存啊，但是呢我这个五次保存显然是远远好于你这个二十次保存，对吧？远远好于二十次。好，这个是我们说的这个内存虚拟化。
34:01内存虚拟化呢其实啊你从某种角度来看的话，在我们的整个的这个虚拟化里面的话，是呃最应该说是这个这个研究周期啊，是是是是是应该说是这个相当长的，不能说最长啊，最长的是 l 直到今天虚拟化的 l 依然是一个问题。
34:21但我们今天几乎几乎已经很少有人去研究这个呃内存的这个虚拟化了，为什么呢？因为内存这句化在通过这个这个之后就解决了。你说哎等等，你不是说这个二十次内存访问有点多吗？你这不很慢吗？
34:40你怎么问题解决了呢？在今天我们的这个两级或者说两维地址翻译，它加入了很多 cathe 啊，加了很多 cathe。所以呢这个这个就把中间的一些常用的一些很容易就做了这个 cathe hit 常用的一些翻译，很容易做 ch he in 就 cash 翻译这个这个这个翻译，
35:01这就是我们说 TRB 啊 TLB 的这个作用。今天我们 TRB 也是越来越大了，而且呢有多级多多级 TLB，多级 TRV。这样的话呢就进一步的节约了这个加大了 GLB hit 的这个这个力度，从而减少了这个在做地址翻译的时候，
35:20对内存或者说对物理内存实际啊访问的这样一个这个这个次数啊，从而增加了这个性能啊，从而增加性能。就是我们说的这个呃内存的这个内存的这个相应的一些呃这个这个这个虚拟化的这个过程啊。好，那最后我们来讲一下这个 IO 虚拟化，
35:43 IO 虚拟化。那么 l 型的话呢，其实它有个目标，就是它需要能够把这个这个 device 啊，这个这个 multiplus 什么意思呢？就是我有一个虚拟机，
35:56我有一块网卡，那我这个虚拟机我可以有一百个，对吧？那网卡我只有我就一个，那我怎么样让一个虚这个呃一百个虚拟机共用一块网卡呢？这其实是一个很严峻的问题，
36:11因为它不像 CPUCPU 说，你说反正大家十分服用，跑完了我就给你，对吧？你跑完了给我啊，大家能轮流轮流使用啊，
36:20十分服用啊，通过调速器做一个切换，它也不像内存，因为内存的话是空分富用，对不对？这块内存给了你啊，
36:29那么另一块内存给他，你们两个同时用都没事，但设备的话就不一样了。设备的话呢，如果你要十分富有，那相对来说就会麻烦结构下。
36:38因为你要把这个你要保证社会本身没有状态，给你用完之后给另一个人用。那前一个人用的这些残留会不会影响到第二个人呢？会不会有些数据他没清理干净，结果让第二个人看到了呢？这个都是我们说这个这个十分复用带来的问题。
37:00空温复用也很难。对于一个设备来说，比如说一个网卡，那它怎么空温复用？在没有硬件的支持的情况下，他很难做到这个。
37:09后来我们看到了有一些方法，比如说在网卡上有很多队列，分别是这个接收队列和这个发送队列。然后这个监督队列发布队列呢，这个这个这个这个我们就可以把这个队列单独拎出来了。这一组队列给虚拟机一号，
37:29这组队列呢给虚拟机二号啊，从而实现大家一起去使用 OK。对，这也是一种方法啊，也是一种方法，这个就需要硬件有支持。
37:37如果硬件没有那么多队列，或者说这个队列不支持发给发送给，或者说呃分配给不同的人，那这个事儿就办不下去， OK 这个下去。好，
37:50那么 IO 虚拟化一共有几种方式呢？差不多也是四种第一种，就叫做 direct access，第二种叫做 device。 mulation 就是用软件的方法去模拟第三种， paraparvertialization 跟我们前面说的是一样的啊，
38:08要去改东西。第四个就是哈维直接帮你把虚拟化管给做了。好，我们先来看第一种。第一种方法的话呢就是这个 direct access。 direct access，
38:22顾名思义啊就是让应用程序呃让虚拟机直接去使用某一个硬件。比如说一个最基本的例子，就是如果我这个一台服务器上面有十张网卡，插了十张网卡，然后呢我有十个虚拟机，那我完全可以让每一个虚拟机都独占式的去访问某一块显卡，
38:47或者某一块这个网卡，对吧？独占式访问。这样的话其实也是可以的，完全可以没有任何问题。但它的有个缺点哈，
38:54就是说万一我有一百个虚拟机，那我只有六七个网卡，那你怎么办？不够了啊，就不够了，这是第一个问题。
39:03第二个问题呢就是我们来看这个看这条路，对吧？看这条路，这个是 CPUCPU 上呢跑了一个 guest OS。 guest OS 呢它独占了一块网卡，这是一块独占的网卡。
39:17然后呢，他就可以通过给这个网卡发一个 DMA 的一个请求 DMA 大家还记得吧？ direct memory access，然后呢，这个网卡呢就会直接去访问这个内存，直接访问内存啊。
39:34这个网卡可以直接访问内存，一旦网卡可以直接访问内存，就意味着这个网卡可以访问所有的这个内存，它可以绕过 MMU 看到吗？这里有个 CPU 的 MMU，它可以绕过 MMU，
39:46就访问所就是因为网卡访问的内存。换句话说啊，网卡访问内存所使用的地址是物理地址啊，是物理地址。那既然你是物理地址，对你那列表的限制就没了，
39:58对吧？什么可读、可写，可执行，什么用户态能访问、内核态啊，
40:03内核才能访问，它，不能访问等等，这些都是由列表来界定的权限。在此就都不作数了，都没有用了。
40:09为什么？因为网卡通过，因为可以直接访问内存的物理地址是，那怎么解决这个问题呢？或者说这是到底意味着多严重的一个问题呢？就意味着我假设有一个虚拟机啊，
40:24我有个虚拟机，我这个虚拟机就可以通过这个网卡啊，通过这个网盘直直接去把所有的内存全部都读出来。这显然是很可怕的一件事情，对不对？根本就没有任何约束了。
40:37总觉得这个问题呢，你发现最关键的就是那为什么说 CPU 它就没这个问题？你到了网卡就有问题，就是 CPU 出来的要经过 memory，对吧？经过 MMU，
40:47经过 MU，经过 MMU，就意味着 MMU 可以去做权限的这个管控。但是呢从网卡上来呢，直接就是未的值，问的是不过 DMA 不过 DMA 呃，
41:00不过 MMU 不过 MMU 的话就意味着它没有办法啊去做权限的控制。所以方案也很简单，就是我们要在 l 的这个通路上加一个 MMU，在 l 的通路上加一个 MU。意味着所有的设备，当他们要去通过 DMA 去访存的时候，
41:19不是直接拿着 host pay physical page 的这个 address 啊， host physical address 去访问他。不是的啊，他拿的是另外一个地址。这个地址要经过 IOMU 的翻译，才能够变成真正的这个这个这个这个呃 host physical address 啊，
41:40去访问 mk。这就是我们说的这个 LMU 的一个一个作用啊。 LMU 作。就是还有一个 LMU 之后的话呢，可以看到预备要做访存，都要通过 LMU 去保存，
41:56做 SD 地址的翻译。 CPU 本来就通过 MVU 去作为世界的例者翻译。那么这两者协同的话呢哎会变得非常有意思，对吧？他们列表之间有一些也是可以做协 ing。有了 IOMU 之后，
42:13我们就可以放心大胆的把这个一块这个网卡或者一个硬盘，这个物理设备交给一个虚拟机，他再怎么访问，也访问不到属于别人的这个内存，或者说那个 DMA 这个内址。好，
42:30这第二第二。有了这个 LMU 之后，我们看哎它这个所有东西都要经过 LMU，对吧？都经过 LMU。好，
42:38那么这么多的好处是什么呢？这么多的好处就是非常快。因为面的话呢，他们就好像是用本地的设备一样去用这个网卡。因为这个网卡是独占式，对不对？
42:52独占给你啊不要来来回回做这个切换。就所以我们说这个这个这个啊 VM 的这个运行的这个性能啊会啊会快很多啊，会很多最低。第二个呢就是缺点是什么呢？缺点就是硬件的接口百分之一百的暴露给了 guests。这个呢依然是会有些问题。
43:13比如说在做虚拟机迁移的时候啊，这个为什么叫 migralation 就很麻烦。比如说我一个讯机跑的好好的，现在我这个物理机要关机重启维修，我要插宽，插一条新的内存，
43:25或者加一个新的硬盘，我要把电脑关掉，把机呃把服务器关掉，那你就服务器怎么关呢？我就把这个服务器上面的虚拟机迁到 migrage 啊，迁移到别的服务器上面，
43:40让他们再先跑一会儿，等我重启完了之后再迁回来。但是呢这就有个问题，就是你有些网络连接的这个设备是迁不过去的啊，因为你的网络连接依赖于这个 physical 的这个 device，比如说你说我迁过去。
43:57但是我的我的这个网络的这个所有的这个这个队列都在原来这个服务器上面怎么办？这就导致了这个迁移本身很麻烦。所以呢我们有一个办法，就是我们能不能够让一百个虚拟机每人用自己的这个网卡，对吧？我们就一百张差一百张网卡啊，
44:21但这个就太多了，后面我们会看怎么样能够做到这一点。但是目前来看的话，你做不到做不到这个一百多万，他做不到这个好，接下来就是这个第二种方法。
44:34第二种方法呢就是用软件的方法来做了啊，第一个话其实是偏硬件的对吧？我把整个硬件都送给某一个虚拟机，那就够够慷慨的了啊，够慷慨。第二块就是我硬件没那么多，
44:48我就软件来凑。现在我们用的包括我们的这个 VM way 啊，用的就是这样一个技术。大家如果打开 VM way，装一个虚装一个虚拟机，打开边部以后后装个虚拟机。
45:00然后呢，你去看你的设备的型号啊，看设备型号，你会发现在当然现在可能看不到啊，在早期的时候啊，你的你的虚拟机里面的那个网卡是一个叫八幺三九的网卡啊，
45:13八幺三九八幺三九为什么是八幺三九这个网卡呢？原因很简单，就是因为八幺三九是当时用的最多的网卡，所有的计算机里面都默认安装了这个八幺三九的这个网卡驱动。所以对于我这个虚拟机监控器来说，我只要用软件把八幺三九这块网卡的所有的交互逻辑全部都写出来，
45:39全部写出来。那么一个虚拟机，比如说 windows 虚拟机，它自带的那个八幺三九的驱动，就可以和我这个虚拟出来的八幺三九直接对接，从而不需要有任何的这个改动。
45:53 ok 这就是我们说的虚拟化。虚拟化他不要新接口，它只要旧接口。在我们刚刚那个例子里面，旧接口是谁啊？就是八十三个这个网卡为什么是八十三九啊？
46:06就因为它是用的最多的旧接口 OK，所以我们说这个这是我们说的这个这个 emill euating 的 device 这样的作用。那因为现在怎么做的呢？还是在 host OS 上面，这里有个 guest。对，
46:20然后呢，这里有个 device emulator， device emulate，它是一个独立的一个呃一个模块，你可以认为它就是一个独立的进程。那当我这个 guest 想要去发保播包的时候，
46:32他自己当然没有发广告包的权限，对不对？那么它所有的对于这个网卡的这个操作，比如说八幺三九这个操作本质上都是 track and usuate 啊，都会降下来。降下来之后呢，
46:47 OS 一看，你是因为某一条 l 下来了，你要干嘛？然后呢，回去一看哦，原来你要发发包啊。
46:55好，没事，然后呢，我就把你这个八幺三九的这个这个命令就发给了这个 DYS mumulater 这个地 y 四有没有认识的，他就去负责八幺三九的活动。然后呢，
47:08他就发现啊原来你是要做这个事情。好，我先记着啊，我先把这个配置啊先记着，等到你真的要发的时候啊，我再一起用这个配置。
47:17于是呢这个 guest 又发了一个，他又记下来又发了一件。好，最终要发数据了，把数据就没有发出去。发出去时候显然也会产生一个 trap and imunate。
47:26然后呢，又又到这个 device in unate device muunate 一看，你要发包了。好，你把数据我看看你有发什么数据，再把它根据前面的一些配置全部一起啊走这个网卡，
47:38走这个网槛走下去，然后就完成了。这就是我们说的这个 trap and imunate 对应的这个这个过程，同样不仅是这个网络，对吧？串口也是一样的啊，
47:50我 get 里面去直接对串口做一个修改，它就是一条特权操作，一定会产生 trap。然后呢产生 trap 之后呢摸一下就知道了。你要干嘛呀？你看哦原来你在设这个串这个这个这个呃呃串口串口串口的这个对应的这个波特率，
48:09然后呢把它设成八幺九二零零零，类似于这样，然后呢这个 monitor 就把这个记下来了。 OK，然后呢就把这个相应的这个命令呢发送给了一发送给了这个 device in lata 里面的串口的对应的这个这个这个虚拟的模块。当然大家可以记住了。
48:29记住之后呢，那如果我这个串口虚拟模块真的要对接到某一个串口设备的话，我也可以也可以对接，也可以直接把这个呃里面的一些行为啊，通过这个呃对串口的这个操作啊，直接映射到外面来。
48:45 ok 这样来的话呢，我们说这个就能够解决这个这个设备的问题啊，这个是 VMV 啊，早期就这么做的。它的这个好处的话呢，就是整个平台非常的稳定，
48:59对吧？非常稳定。比如说我有一个平台啊，我上面就是一个虚拟的八二三九的这个网卡。然后呢，我换到另外一个地方去，
49:06它也是一个虚拟的八二三九的网卡，那是一模一样的。所以它它的整个的这个兼容性没有任何的问题，没有任何的问题。 OK，然后呢它迁移也很方便，
49:17对吧？你迁移你八幺三九，你说啊，我也没有八八幺三九里面有些数据我这个迁不过来，你的八幺三九就是个假的，就是个虚拟的，
49:24就是个软件做的，对不对？软件做的东西状态在哪儿啊，当在内内存在软件里跟着一块搬过来不就行了吗？所以说它的所有的硬件的状态很容易打个包，就从一台机器迁移到另外一台机器。
49:38所以它的好处就是它的整个的这个 migration 这个阶段可以做的特别的好。但是呢它也有缺点，毫无疑问最大的缺点就是慢，对不对？听上去就很慢，为啥你要用软件去实现一个硬件的八幺三九。
49:55那这个想想都觉得啊，你要写很多这个代码才能够去做这个解释，运行的时候，也会带来不少的这个危害。所以我们今天啊啊已经不怎么用这个虚拟嗯虚拟这个这个方法啊，模拟模拟模拟的方法，
50:10今天已经怎么么？我们更用用的更多的是接下来我们要讲的是来自这个这个方法啊， paraverparapage 我再休息一下，涉及到这个到五十五，谢谢嗯。