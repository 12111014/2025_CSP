00:27对我就升级，这啥尤其是谢谢，为什么呢？起床了呀，嘘，对吧？
04:00是你先给我这个，没就差不多这个电话辩论意见，这两件不对，更加的珍惜。这的你好。对了，
05:36那个就我们是不是还没有见过课程群啊？是的啊，那我们要不要不现在先建一下，以为因为提前那个我们 PT 也好，那个这个这个这个这个那个是那啥，都都提前发群里，
05:50大家有问题可以问好吧。那个要不我们就呃来个这个面对面建群，那么就零四幺二，我们教室是四幺二行，那我们就先那个我们先加一下，好吧？
06:03好，这后面我会把助教的同学留给他。行，那么大家这群同时那个我们可能就这个这个接着上啊接接接着上节课的这样的一个内容。那上节课我们其实提到说这个这个这个我们为容错对吧？那容错的话，
06:21我们一个组件它它要飞裂，然后它飞裂的时间如果不不定，那场景下我们怎么办呢？我们只能够把这个服务去做一些冗余，对吧？那么怎么冗余呢？
06:30一般来说是呃有两种方式，一种叫空间上冗余啊，就我是把这个服务备份几遍，那那我只要我不会全部很倒霉，对吧？所有的都挂掉，
06:39基本上也不大会。那这样的话，我的啊我的服务就可以接着可用了。那么我们说过空间上冗余一个很大的这个问题，就是说我会有这个这个这个这个一致性的这样的一个问题。所以我们有很多的这个相应的技术点，
06:55这节课也会展开啊，就包括这个 case 这么写。那除了空间上的冗余以外，空间上冗余其实大家想想有什么问题，就是说我的这个这个这个这个这个这个资源的消耗是比较大的对吧？但很多时候对于一些错误，
07:08如说说网络断了，或者说我这个服务器短暂的不可可用了。或者是短暂升功的一种情况是说我可以做一个 VSQ 的重新再来。就比如说我一秒钟对吧？没有响应，那我再做一次两秒钟，
07:19没有响应，假设我的 SS 三秒钟，那我做三次，对吧？我期望上三次都不那个叫什么都不响应的，这个概率是非常低的对吧？
07:27所以我也可以通过这种叫做 reexcute 的这种方式去做冗余。但是 reexcute 本质上什么，那本质上是一个时间上的这个冗余。就是说我在这个前啊一百毫秒没完成的时候，我可以 deleay 一下再做。因为你本身 SL 属于一个时间线程，
07:43那么大家想一一在 r excute 这样的一个方案里面的存不存在这个一致性的问题呢？我来举个例子啊，比如说我先用 GPT，对吧？发了一个 API 请求，然后他给我吐了五个词，
07:59然后我发现他告诉我服务断然啊。这个时候我手动的我没有在拍照脚本，我写了一个个键程啊，我让它去串。我我用同样的 t 大家想一想，我这个 GPT 吐出来的后五个词会不会跟我这个前面那五个词一模一样。
08:14大家有没有想过这个这个一样的话，就是应该是一致的对吧？如果是不一样，就可能会不一致。因为有一些应用，它可能就是说我通过你你现吐出来的词去做一些做一些后续的操作，
08:25对吧？如果你这个不一样，那我做的操作不一样样，那么在 rescucute 里面，它可可不可能出现这种不一致呢？其实也是有可能的，
08:34也是有可能的。但是下其本质的问题，就比如说在大模期推理对吧？它的本质的问题就在于我有两个同样的 count。我比如说把它 tempiture，就是它的随机性设成零，
08:43它有没有可能啊？我两次推的结果是不一样的。其实在真实的这个推理中是是会出现的。大家可以去试一试啊，它呃它的核心原因在于这个乘乘法这个叫做浮点的那个计算，是不满足这个这个这个这个结合率的啊，
09:00就是在实际实现中啊不符符合啊。当然这个其实有啊这个其实也是最近挺挺火热的一个操作，对吧？在这个你去后训练的时候，其实有很多优化啊，都会导致它的这个这个这个这个这个 VSVS cute 的这个准确性有问题啊，
09:16所以说啊这个本身啊你不管是哪种程度的这个冗余，其实都会啊都会有这样的一个，这是这些问题需要解决。所以说冗余本身啊是一个很通用的方法。但是在具体的这个应用到某一个应用里面啊，它的这个遇到的问题是不一样。
09:33 OK 行。那么那么就是说那么前面我们提到了对吧？就是说哎我们要要实现 availability availability，那么 vailability 的一个很大的挑战是 consenstence。那么一个很自然的想法是，我们能不能在实现人 vvate 的同时又能够实 consistency 啊，
09:57这个事情在现在的这个物理的这个网络互联条件下啊，理论的计算学家告诉我们啊是做不到的。做不到原因是什么呢？因为现在的这个集群里面会有 naturk partition。我们前面讲过 naturk partition 大家在回忆啊什么，对吧？
10:13那么在有 natural partition 的情况下，我们是没有办法实现 sisistency 和 avarivation，这也就是经典的这个 CAP 的这样的一定义。那那这定定义其实在不同实际系统里面，其实啊都有这个体线，对吧？
10:29比如说我们假设是以一个这个还是一个电商，对吧？但是是一个这样的一个这个这个这个这个这个亚马逊，然后怎么样是因为亚马逊的跨国业务比较多，它容易发生 neatural partition，对吧？
10:42那所谓的在亚马逊这个场景下，它 netial partition，就是美国的用户连接，连也访问不到了欧洲用户的那个数据中心。那么所谓的 consistency，就是美国的用户和欧洲的用户看到的商品数量是一样。
10:55那所谓谓的 vibility，就是我这个服务能够在比如一秒内获得这样的一个响应。那么为什么这个这个 CAP 没有办法同时满足呢？这个其实里里面的理论证明是非常大复杂的。但是啊从描表现描述这个表象来说，我们其实只要就需要举一个反例，
11:14对吧？举一个反例来证明，证明这个这个时间达不到就行了。那么我们这边其实可以举一个很简单的这个非常 informal 这样的例子。比如说假设一开始对吧？我有 s 一是比如说是亚马逊在美国的这个机器，
11:28然后 s 二是亚马逊在欧洲的机器的话， c 是一个 kind t。那假设我一开始运气非常不好，对吧？有一个这个这个 level of partition，导致我的用户只能跟美国的机器 s 一通信。
11:41那这个时候我为了保证高可用，对吧？假设我们要高，我们是同时满足 CAP，我要保证高可用。那我比如说我的数据更新就只能更新在这个美国的服务器。
11:52那这个时候如果我突然发生了另一个 partition，对吧？导致我这个用户只能连欧洲的服务器了。那大家想想，这个时候我如果要保证高可用，我就只能读一个欧洲服务器旧的这样的一个数据。
12:04那么这样的话它就不满足 consistence，对吧？因为我更新的数据我没有看到，那如果我要等我要读到最新的数据，那我就什么我就得等这个欧洲的服务器更新了这个美国数据的这样的一个结果。那这样的话就没有办法导致导致考虑。
12:19所以有了这样一个反应，我们就可以发现你在存在这个 nadel qugine 下，你是没有办法同时达到这个 consistency 和这个啊背背起来。所以这意味着什么呢？意味着说对于一些分布式系统注意是一些不是所有分布式系统，对吧？
12:34比如大模型推理，就没没必要这个搞扯这一套。对，但是你数据库就就得搞这一套，你就得在什么呢？在这个 a 和这个 c 里面去做一些权衡。
12:46那具体怎么去做权衡，其实是 depends on 你的这个这个应应用规是是么样的。比如说我们可以以淘宝的话，我们就可以举两个很经典的例子，就是淘宝。我们的阿里它有支付宝，
12:57对吧？支付宝和淘这样的业务。那么对于你一个淘宝应用来说，大家想想想，你是如果让你在 a 和 c 面做取舍的话，哪一个比较重要？
13:05肯定是 a 比较重要。为什么？因为你这个用户如果不下单了，对吧？我这个业务不就我下的，我我点了个下单按钮，
13:11他告诉我没有反馈，那我就不买它了。对，不那这个显然是这个很高。所以对于淘宝来说，它一般会选择这个 a 啊保障没有问题，
13:20但它会有一些一致性的问题。那么一这些问题对于宝宝来说重不重要呢？其实不重要，对吧？对于淘宝来说，我如果一个东西超低淘宝，
13:28这是一个问题，无非就是一个东西超卖的那我超卖的话，我最后给点补偿运费也能接受。我这样他发生的概率很低啊，但是对于淘宝来说，他选择的就是 a 啊。
13:37那大家注意啊，这里面为什么我们说 p 一般来说都是在的呢？因为这个难道法律现象它是一个物理现象啊，你不可能说我抹除一个物理现象，对吧？这个你得保证在啊，
13:48你你你基本上是不大能抹除物理现象，除非你是造造事主。所以说所以我们只能说在假定存在这个 p 的这个前提下，我们在 a 和 c 另一方面来说，我们可以看到支付宝这样一个应用，对吧？
14:00它其实啊就是就是选择了 c 啊 c 就是说因为你只有支付宝，你的全部的钻属全算扣了，对吧？人家这个就要要跑到这个支付宝这个蚂蚁去去去去去搞事，对不对？那肯定这个是会不能不能那么搞。
14:15那这个时候我们其实也能看，从这两个的选择上，大家其实也能够感觉到不同应用实现的不同。比如说大家不知道有没有注意过啊，对于淘宝来说，对吧？
14:25大部分的这种浏览页面啊，或者说那啥的操作都是比较丝滑的很快。但一旦比如说你要涉及到支付的时候，其实大家都不知道大家有没有感受到它的它的延迟。其实是会明显的比你的这个其他操作要高很多的一个原因就是因为你支付的这种操作，你要保证你知性啊，
14:43它的一般来说性能就会啊更加差一点。当然这边啊需要和大家啊强调的一点，就是说，我们虽然说 CAPCAP 三者不能同时达到，对吧？但是 p 这个东西它是不是所有时候都会出现相期出现的概率非常低。
14:59所以当你这个这个这个一个系统啊，它没有这个出现 partition 的这个时候，其实我们是能够同时达到这个 consit，他没没去行。那么前面就是我们这个主要的这样一个给大家介绍一下，就是分布系统里面它面临的一个比较大的这个容错的这个问题。
15:18那么其实关于在分布式系统里面，我们前面说说很难的一个很难的一个点，就是怎么去 detect 到这样的一个 fault，对不对？那么这个 detefault 这个事情其实在现在都是一个非常呃都都还是在研究的一个一个话题。其实数据中心啊也有非常多的尝试，
15:37也希望能够对它做一些更深入的这样的一个分析。那么下面我们给大家介绍一篇啊，我觉得写的还是比较有意思的。这个 paper 啊叫做这个啊 green failure 啊， green failure 就是微软的，它一个人跑。
15:50那这 greefailure ure 它用 paper report 啥呢？他说这个我们这个分布式系统里面啊，它的 failure 啊，不是 fear stop 的，就是我不是一旦挂了，我这机器就不可用。
16:00而很多时候就像我前面所说的，这个服务器，它可能只是跑的慢了啊，跑的慢，或者说它只是其中的某一部分组件呢。我很比如说有一个虚拟机对吧？
16:09这个虚拟机它可以执行，但是它可能发不了网络包了。那这个时候很多时候我们的用户态的这些啊的策略是检测不到，那检测不到的导致的一个结果啊，就是说我的这个应用可能在悄无声息的这个过程中受到这样一个影响，它叫做 detebrief 脸就没有激化。
16:27但是应用给别人感觉是不能用的这样的一个状态，它作为一个更细致的分类。那么我们来看一看它里面举的几个例子，以及它里面提出来的一些可能的这样的一个啊这个解法。对， OK 首先啊这边黑问它定义了一个事情，
16:45就是说什么到底什么叫做啊 grave 分裂？那它的区别就是传统的我们很多这种技巧，对吧？它假设不是规 graly，什么叫不是 gragraze 呢？就是说我一个组件组件它要么就是完全不能用了，
16:59要么就是完全是正常的可用了。但是在实际的这个这个运营的这个过程中啊啊这个微软的这个研究人发现对吧？他很多时候它的这个这个组件，它其实也是处处于一个可用和不可用的这个样的一个中间台啊，中间台很多这样的一个 case。然后导致这个结果就是这些 brief 分裂非常难以 detack。
17:22因为它从我们的这个观测者角度来说，它其实这个东西是好用的。那么好用只是说它的这个性能啊受到了这样的一个影响。我们可以来举一个例子啊，举一个例子，到底什么是国璃碎裂的，
17:36就是这个是微软他们去 report 的一个真实的这样的一个例子啊，就是这样子它里面表达什么？就是说在微软这个这个数据中心里面，有一个交换机已非常低的概率发生了故障。但是这个故障导致了所有的这个这个大量的前端请求都不能用了，而且这个故障还没有办法被了。
17:57我们可以看看为什么。首先这个架构相信大家应该已经比较熟悉了，对吧？我们前面讲了这个数据中心网络是以这样的一种这种方式啊去做互联的。然后比如说我要发一个请求的话，那么这个这个这个这个我我这个会路由一下，
18:15到这边。然后我们会看到每两台 server 之间其实是会有很多条路径互联。这因为什么呢？因为着说其实微软它已经做了很多的这样的一个一个这个这个这个优化。就是它用一些 random 的这种方法啊，使得说我如果有一台交换机 crush 的情况下，
18:33或者说它做的比较慢。这个情况下我能够立即的切到另一个交换机，它能够随机的方式切到另一个计算机。所以说我这个切的方式啊会受到这样的一个这个影响啊，影响会变得很小啊，变得很小 OKOK。
18:49那就这样的一个情况，所以我们可以看到是在这种架构下，对吧？如果我每个交换机它出错的概率非常低，或者说我我几千台交换机，我有一台交换机啊，
18:58它如果出错的话，它其实对于服务的影响理论上来说是应该是非常小的，对不对？我应该只有啊只有只有某一一小部分需求才会影响啊，才会这个这个这个这个影响到啊这种时候的话，如果我去做一些大规模测试，
19:13比如说我在随便的这些机器去做一些 pink 这些消息，我们会发现这个整体的架构其实非常影响。应该是应该是，如果即使是有一两个交换机挂了，应该对整体服务影响是不大的。但是啊但是这个微软啊，
19:27他发现发现在他们的这个数据中心里面，如果出现了一台这个交换机啊，它发生了一个随机的克 pjob，就是说它其实没有坏啊，但他他他他是他他说僵坏不坏的吧。他就是说就是说我这个有时候随机会丢一些包裹。
19:44那么原来来说，根据我们刚刚这套方法，我每个包是如果是随机走一个路径的话，那么它其实我对于一个用户来说，他的这个请求受到这个随机丢包的这个影响，应该非常小的，
19:57对不对？应该是非常小的。但是在这个 microsoft 里面，他发现这个受到的影响，他发现几乎所有的请求都受到了这样的一个这个随机丢包的影响。为什么会出现这样一个情况呢？
20:11基实本质的原因就是我们前面给大家介绍的。你在一个数据中心里面啊，它一个服务，它并不是只有两台机器通信去完成的，它是由很多个组件去做这种协调。比如说你这个搜索，
20:24它为了加速搜索，它会把这个请求 FOF 到这个很多台机器去做疫情的搜索。这样导致的一个结果就是你的这个累加起来的。你这个随着你的请求获的数量越多，而你你去访问到这，你的整体请求是访问到这样的一个受损的，
20:43这样的一个交换机的概率就会越大。最后当你的数量大到也不用特别大，你几十这个时候它基本上你就百分之一百会受到这个丢包的这样一个影响。那导致结果什么就是我的这个整个服务都烂掉了，整个烂掉。但是如果你去跑一些现有那种点对点的这个 forping，
21:00每台机器之间点对点 ping 去去 dedet 的这个问题。你后你会 maxso 的发现，它这个东西是是发现不了的啊，是发现不了，你必须得跑一些很大规模的模拟真实业务的这种搜索哎，才能够拿到。
21:12这就是一个在数据源里面很有意思的 case，就是一个非常小的这样的一个飞裂。然后它也不能算飞碟，它就是一个稍微处于一个不可用的，慢一点的，或者是受损一个状态。
21:22它就会导致你整个这样的一个里面受到这样的一个影响。 OK 在微软里面，它其实还给了很多很有意思的例子。我们可以再举一个例子。哎呦，我这个意思呢，
21:37它举的是一个出错的处理器。什么意思呢？就是大家像微软，其实现在大家看说到微软，大家第一反应什么是 windows 还是还是啥么，还是欧 en AI 还是啥。
21:49那么其实微软现在它的一大头号业务是它的那个 izo 的虚拟机，就是他一大堆很多收入是来自于他把它的数据中心给当成虚拟机，卖给卖给客户去赚。然后为了提升竞争力，微软呢他们做了一个操作，就是说我如果一台虚拟机在某一个节点上挂了 OK，
22:09微软它会自动的帮你去启动一个新的这样一个虚拟机。然后让你这个让你的用户啊的原本讯集跑在新的虚拟机上。这样的话我可以给用户一个基本上不会挂的这个抽象 OK，这个是一个很好的抽象，对不对？对云上来说的卖点，
22:22那么怎么实现这样的一个抽象呢？微软就说好，我得去实现一个这样一个个飞 ure detector，对吧？你得先看一下这个虚拟机到底好不好，如果不好，
22:32我得及时给他做一个切换。好，所以微软这边实现了一个 failure detector。但是这边有一个问题，也就是你这 detect 到底怎么实现呢？我假设我每台机器要部署几十个虚拟机，
22:44一般来说其实现在一般每台机器都是会布大概几十台虚拟机。因为现在数据中心的机器大概是啊每台机器大概是有一百个核差不多这个样子的啊，几十到上百个虚拟机，然后微软的一个数据中心又有几千台这样的一个物理机。那么大家如果我就拿一个单点的这个分碟 deteteor or 去 detect 所有虚拟机的故障，对吧？
23:03这肯定是一个不高效的这样一个设计。所以微软这边呢它实现了一个叫 hierarchical 这样的一个虚拟架构。什么意思啊？就我每一台机器上啊有一个 agent 啊，这个 agent 跟我们现在的大方型 agent 不一样样，它就是一个很机械的 agent。
23:18它去定期会跟每个 VM 它的一个子模型，通过机器内的这个网络互联啊，一般来说就共享内存去通信。然后呢，这个每一台机器发现了它一台一台机器节点内有一个迅拟挂断了他，再去汇报给一个统一的这样的一个全局的分类 detector，
23:35然后去做这个行动。 OK 就是这样的一个整体的这个这个海外 p 架构，对吧？也是经典的这个系统的方法。然后他们在运营的时候发现了一个问题，什么问题呢？
23:48就是如果我这台虚拟机它就挂了，了如说它不响应我这个 host agent 的这个消息了。 OK。那么这个时候我的这个这个这个这个这个分类 detect 能 detect 到它可以做一个重启或者迁移。但是我们知道大家有没有用用机器，有遇到过这种情况，
24:06就我这机器明明 SS 去上去还能跑，对吧？但它实际上很多时候它有些功能都用不了，比如它的网络驱动发不了包了。大家有没有遇到过这种这种场景？其实我遇到过，
24:16尤其是当时我我我写代码，就是把那个坑都搞不搞。 padiche 的时候，比如在 kno 里面扔了一个这个 warning 的时候，这个 clo 看上去我还是能 SSC 上来跑，但是它基本上跑来跑着，
24:27它就会跑跑飞掉啊，这样不能用。那这个时候会告诉他，直播前，就是说站在用户的角度来说，这个他方发现啊，
24:33就是我这个用户这个虚拟的这个网网络啊网络包发不出去了，就是它这个虚拟机没法跟外面网络通信了。但是呢这个它跟它里面的一个另一个这个跟 a 键程模块交互的这个模块仍然是好的。所以站在非也的这个视角来说，他觉得这机器没有挂。但是站在用户的视角来说，
24:54因为大家想外部的用户他肯定得用这个网络去跟虚拟机这个交互，对吧？这本身这个虚拟网络的这个架构是比较复杂的。所以呢麦克 so 我就会发现，用户告诉我这个不能用啊，然后这个股会被 ACC 去了。
25:08但是这个这个这个这个这个这个这个这个站在厂商找的时候，他觉得这个虚拟机变化他没有必要做出任何的这种修复。这个时候其实就会发现啊，这个这个这个本身这个用户体验就会受到这样的影响。这是啊所以这个微软呢就发现啊发现我作为一个这个云厂商啊，我我对于这个分布式系统里面的这个 fault 的这个理解实际上是非常非常不够的。
25:40那么他觉得这个问题的本质来源是什么呢？就是我们的观测的这个东西啊，就观测者没有办法去观测到最真实的这样的一个场景。比如说我们前面讲的那个丢包那个场景，对吧？我们现有的这种检检查，
25:55网络连通性的方式都是点对点的。但他其实并没有去考虑。我这个消息可能会是一个很多个机器协同完成的这样的一个特性。那么前面这个 VM detector 这个这个角度来说，它其实就是因为我的这个用我的这个 observer，对吧？
26:13其实并没有观测到这个网络流量便是零，它只是观测到我这个这个机器能否给我哈 bit 啊，他只观测人。那就是这种差异导致了我们有一些飞利啊，它实际的影响了这个现有的这个运行。但是我们的这个平台却没有去啊 detect 出来。
26:30所以我们 mictop 这边其实我就做了一个很好的这个分类。对吧他其实就是说好，如果我的这个哦其实对一个好的 observer 应该是一个好的系统的观测者。应该什么？就是说我这个系统如果 report OK 的那我应该这个 observer，它观察是观察出来，
26:46也是 OK 的。如果这个 observer 观察出来的是不 OK，但是实际不 OK。那其实什么那是这就是一个这个 gray failure 啊，就是一个灰色的这样的一个场景 OK。所以这边的话就是微软定义的这样一个东西。
27:01那么怎么去解决这个问题呢？其实其实其实解决，当我们其实我们会发现你，你有时候如果能定义清楚一个系统问题的话，其实你对它的解决是非常简单。比如说我们前面说的 VM 这个场景，
27:15 VM 这个场景本质是什么呢？就是我只观测这个机器给我是否给我哈币，这个事情是不不行的啊啊不能不能够你不能够 imply，它没有什么它没有问题。所以这个时候呢， max 的解法就是我对于 sofv m 的这个观测，
27:30我不仅要观测它是否给我 habit，我还要监测它的这个这个这是 hdbit，我还要监测它的 CPU 使用量，我还要监测它的 disk 使用量，我还要监测它的这个网络的使用量，对吧？
27:41如果它这个网络突然突然出现了一个 NT pattern 的话，那么我就是我如果突然就突然掉下来，我就认为它可能会出现一个问题。那么这个是一个很直观的解法。那么对于第二个来说，就是说这个这个这个这个这个这个这个比我们前面说那个对于那个摄取那个就是网络掉包那个事验我们没法检测到，
28:01是因为现有的这种网络。当前当时现有这个网络治疗工具主要是点对点。那点对点的话，我没办法发现这个这个协作的这个通信的丢包，那怎么办呢？那我其实很简单，
28:12我既然知道这个应用它需要要很简包才才够完成一个任务。那我其实就我就模拟这个应用嘛，对吧？我去把它这个这个所有的包都跑一遍，那我其实也能够发现对不对？还有一种其实微软这边还发现了一个很有意思的事情啊，
28:29但是他没有细讲。他说有时候呢我站在一个应用的观测角度来说，可能发现不了这个应用的它它有问题，但我不知道原因在哪。那这个时候呢，如果一些其他的这个 tenent 对吧，
28:40它它也有一些观测的手段，那我们是不是可以拿其他 tenent 的观测结果来去 imply 这个另一个 tenenent 的这个结果。因为其实在云上啊一台机器上是会跑很多的这个不同租户的机器，它并不是给你独占，而且不占这些成本太高了。所以大家就是说嗯就是说就是说如果想用这样的话，
29:00其实本质上这这也什么？这也是去给给这个平台一种更多的这种啊可观测的这样的一个这个手段。 ok 行，那这边的话就是啊我们关于菲利 o 再再再讲一些内容。那么最后一点时间的话，我们可以再介绍一些再更深入的介绍一些这个这个比较有意思的这个分布式系统的这个特性啊，
29:27我们前面可能只讲了，对吧？这个 consistency 啊，我们只讲了这个 fortarance。但其实关于 sculility 和 perforforance 呢，我们也讲了很多。
29:35但是这个到底什么叫做 perforvity，到底什么叫做 performance，对吧？那么我们其实我们可以再再深入展开讲一讲。这些概念其实很重要。我们对于做系统研究的时候，
29:47我们说这个 forformimimvement 对吧？到底是 improvement，以及这个通公斯到底是取决于什么因素，对吧？以及它到底这个 perimprovement 重不重要，对吧？
29:56那么其实其实说白了啊， performance 一个最直观的这个这个理解就是啊你到底多快能做完一个计算任务。这个其实就是个 latense 啊， latense。然后还有一个点，就是这个 suput 啊，
30:12就是说你的这个这个这个每秒到底能做完多少兆？这样呢有时候是相处的这个关系。但有时候如果你考虑到这个排队啊 q 的话呢，其实啊并不是啊这个是我们讲的这个 performance 的这个这个因素。然后到这个 performance 这一点，那它其实更展开来讲，
30:31它其实又取决于你这个算法的这个复杂性和这个系统的这个复杂性。比如说我们大家上算法课肯定上过，对吧？算算法课，我们说一个算法高效，它的判别依据是什么？
30:44我们判别依据是说它的这个这个复杂度对吧？是 ON 还是 n 方，对吧？一般来说一个 ON 的这样的一个复杂度的这个这个这个算法会比一个 OO。比如说 o log 呢更加的低效，对不对？
30:57但是其实我觉得做系统的话，我们一定要理解的一点，就是你算法上的这个复杂性的这个提升，并呃并不一定能带来系统上的性能提升。就是我这个 job 算的快不快啊，我因为因为本身你的不同的算法，
31:13它的实现的这个常量是不一样的我来。我可以举个经很经典的例子，就之前我们实现一个内存的这个逼数。我们当时有一个操作，就是要找到一个这个一个笔竖的节点里面是吧？最小的一个呃是最小的还是要中间的一个值，
31:30中间的一个值这样的一个操作。那么大家想想要找到这样的一个操作，我们假设这个这个 b 数里面存的这个 k 啊都是排序的，按照我要的大概排序。那理论上来说，我一个算法上更快的系统，
31:44我是有一个二分查找，对吧？我可以以 o log 的这样的一个形式去去找到这个形式。那么还有一种方式是我可以很傻的去遍历一遍，从头遍历到尾对吧？找到我我移一个数最小的这个数。
31:56那大家可以去测试一下，大家想想我在实现中是 o log n 的这个方法更高效，还是 ON 的这个方法。更况下呢？在我我当时的这个实践中，我发现大部分情况下，
32:06但是 ON 的这个方法更高效，为什么呢？有两个原因。第一个原因就是你在内存的 b 数啊，它的 n 不是特别大啊，所以说你的这个 o log n 它要减少了，
32:16这个比较的部署不会特别多。第二个原因呢就是因为 o log n 啊，这个东西它对于这个 cash 的 locality 非常差。大家想想我 o log n 的话，相当于我是得在这个 b 数的节点里面跳来跳去，对不对？
32:30那么我跳来跳去，我每一次跳一下，当我我第一次访问这个节点时候，我就得把这个数据从 rug 访问到这个这个 cash 里面，会有漏的这个过程。但是如果我是一个顺序扫的这种方式的话，
32:42我其实现有的 CPU 它会帮我 prevent 后面的这样的内存。使得说我每次访问这个节点的时候，它其实没有一个没有一个这个这个访问 randdom size， run rrandom size 的开销。所以在实际的测试过程中，我们发现这个欧文的这个方法其实有时候会比 o 罗文更加快。
33:02那这个其实就是太 deon system intestrution 和哈伦。这点我觉得是啊大家如果是有做这个系统研究的话啊，这点一定要一定要一定要注意一点，就是算法上高效的东西不一定系统实验发会更高效，它取决于很多很多因素。那那怎么去分析这些因素呢？
33:18一个很好的方法，就是说你需要把这个系统 model 给给给给给给给建出来。好， k 这个太复杂了。这个我们可能这一课就讲了 OK。那么讲了古风 boss 之后呢，
33:27我们就可以更加清楚的去定义 scacage 了。什么意思呢？大家想我们其实前面讲了要 skill，对吧？我们说 skill 它的这个这个形式是说我通过这个这个这个我我的流量变多，我的机器的处理能力变多。
33:43那么我们当时的这个描述其实是一个非常啊非常呃不不不精确的这样的描述。当然我们现在可以稍微精确点，但也不是最精确的。这个思就就说其实什么叫做 scalibility？ spability 本质上其实就是两个问题，就是我给了你更多的对于同一个任务来言，
34:00我给了你更多的这个计算资源。比如说我给原本我给你的十个 GPU，我现在给你二十个 GPU，我能不能在一半的时间内把这个任务完成啊，这个就是计算时间能不能缩小到一半。如果能，
34:13我们就认为它是一个线性的 scale 的这样一些。如果不能，那那肯定是有一个线，他的地方引起这个 homost of t neck，我们得去解决。那这个是我们从性能那这个角度去定义 security。
34:25当然从存储的角度来说，我们也可以这个按一个定义，那就这个存储就比较直观，就是我能给你一倍的这个计算资源，我能不能去存这个多的一倍的这样的一个数据啊，这点大家可能看上去觉得很直观，
34:37对吧？我给你讲你一倍的这个计算资源，那我理论上说我不就应该能能多存一倍的数据嘛。但实际过程中你你你其实存的可能只有零点八零点七，为什么呢？因为你当你把这个数据啊，
34:49尤其你扩展到多机之后，对吧？你有些时候你得存原数据， matt data a 吧，你 data 也会占一定的这个空间啊，所以说它其实啊并不是一个完全一倍的这样的一个数量。
35:01那么从 skilled 啊这样的一个啊角度来说呢，就是说又有两又有两个维度的这个词标。其实很有意思，一个叫做 skill up 啊， skill up 说的意思就是说我在一一台机器内啊，一台机器内，
35:16我能不能比如说我通过用更一更多的 thread 来去增增加这个性能。其实本质上来说，其实就是我们发现你现在的这个一台计算设备啊，它其实并不只有一个计算单元，对吧？它其实有很多的这个这个这个计算单元。
35:31那么除了 skill up 以外呢，其实还还有一点叫做 skill out。就是说我能不能加更多的这个机器啊，这两者它的这个 skilled 带来的这个普通 penalty 是不大一样的。因为你 skill out 它的 penalty 在于我机器内啊可能需要一个同。然后然后机器 y 啊，
35:49机器外它那个叫什么？这个这个这个 scalout 的话，它实际上通过网络同步，它其实那个同步的这个域啊会不大一样。所以啊也需要一些这种啊系统设级。不对行，
36:00那么讲讲完了这个这个这个这个 performance scuribility 之后啊，大家可能就会有一个很好奇点对吧？就是说我的 performance 和 skilribility 理论上来说，我我希望是两者都兼得，对不对？那么假设我这两者啊不能兼得的时候，
36:18我是选一个 skill 的系统好，还是选一个这个 performance？好的系统好是吧？这个其实来自源于这个我我也觉得一个很有意思的这个现象，一个很有意思现象就是在一四点啊，有有一个工作，
36:32它测测了很多的当的那个 salalable 的系统。什么叫 salduable 系统呢？就是我加了很多核它的这个 job 时间，就线性的减少。里面有一些很经典的例子，就是像 spark 啊，
36:45 spark 大家可能在一多会听说过，对吧？我加了核哎，我的这个性能就行。他觉得哎这些系统，然后这边是不同任务的啊这样的一个时间啊，
36:54他觉得这个可能任务比较好。然后呢，当时那个老哥做了一个很有意思的实验，就是他测了一个东西，他把相他发现首先先这些任务是能够跑在一个笔记本高端稍相对好一点的笔记本上了，这笔记记本就一个盒。
37:08然后呢，他把它跑在笔记本上做了一个对比，发现啊，你这个 spark 对吧？这个东西看上去很 scalable 啊，但是它跑出来性能非常差啊。
37:18第一，比比比比这个笔记本要差一个数量级啊，那笔记本肯定是不 skill 嘛，不 skill。所以呢他就会发现一个很有意思的事情，就是在从抽象来说，
37:29就是说我们有两个系统 OK 一个系统 sist a 比如说 spark 对吧？它的这个非常 skill 啊，我给它多少个核，它就能获得多少倍的这个提升。然后有个系统呢它不 skill，比如它只能 skill 到十个核，
37:41它只能在单机跑一台机器，就是十个核，然我 skill 到十个核就结束了。好吧，这就是这个这个另一台这样的一个系统。那么你我们大家能不能通过这种 scribility 的时候去判断说系统 a 一定比系统 b 好呢？
37:56其实不能为什么？因为你的 skribility 说实话实际上是实是一个什么是一个次要的目标，对吧？什么次次的目标？就是我们一定要明白的是，我们对于一个研究这个系统的这个系统，
38:08最核心要达到的这个指标是什么，对不对？对于我们一个计算任务而言，它最重要的其实不是 skill。 ability。只能说我能 skill 当然好，
38:19但我最最重要的肯定还是什么，我能多快的把这个任务给计算完，对不对？那如果 system b 啊，它其实这个能够在更短的时间计算完，它即使不 scale，
38:32它也比你这个当前一个看上去更加 skill 的这个系统啊，这个其实是关键什么呢？在于我们这个做任何系统下，我们要有一个这个选型上面的这样的一个考虑。那么为什么这个这个这个这个这个这个一个看上去很 scale 的这个系统，它的性能反而不如一个不 skill led 一个核的这个系统啊，
38:59好呢？因为其实原因也很简单，其实这就画出来了，这边是一个笔记本的这样的一个系统。然后上面就是一个很 scale 的系统。其实一个很重要的原因就是你的这个任何一个这个啊 skill 的这个这个系统啊，
39:15它是 skill metty 是有代价的。比如说你要 skill，我们说 skill up 对吧？ skill up 就是我我有一台机器，我用更多的线程，那更多的线程就会出现什么呢？
39:24就会出现。如果你两个线程访问同一个这个数据的时候，会出现一种情况，它就会出现这个数据竞争。那为了防止竞争，你得什么你得去加锁。
39:34那么锁其实是非常大的开销。大家可以去测试一下你在现在的这个 CPU 上，我去访问一个读内存或者说 catch 读操作。它的时间实际上会比你做一个原子的这种锁操作要要快一百倍。所以说当我的系统 skill 的时候，它可能就会涉及到 skill up 的时候，
39:54它就会涉及到机器内的同步，会有系统损耗。那么当我 skill out 的时候，其实也会有系统损耗，对不对？大家想想我 skill out 意味着什么？
40:03意味着说我的任务之间需要去通信。那么通信的话，现在在数据中心内最快的通信网络啊 RDV 啊，我们会讲大概的通信延迟大概是在一微秒到两微秒这个样级那一微秒到两微秒的量级的话，它其实比你一个在本机的内存访问是要慢十倍的。本机的内存访问大概是在几百个纳秒啊最坏情况下，
40:26几百个纳秒的这样的一个随机访问的这样一个量。所以而且而且并而且我们这边还没有考虑到，对吧？你当你的 skill out 的时候，你的出错的频率其实会比这个 skill ill up 的时候， skill up 和这个在不 skill 的情况下高很多。
40:42这也导致的结果就是你的一旦 scale，它其实并不意味着你的 performance 会好知道是吧？只有你的比如说我一台 GPU 啊，我就把参数都放不下了。这我并并呃这个迫不得已的时候，对吧？
40:55我才需要取这个 skill。所以这个是也很重要一点，就是 performance schevity 是一个非常相关的这样的一个指标。但是通常情况下，我们应该先 care 的是这个 performance，对吧？
41:08而不是啊这个 scheduity。当然当时做这个系统的这个老哥对吧？他也呃说了就是说他说了一个很重要的这个这个结论，就是说你呀在这个这个这个这个这个这个这个用要要要管一个集群之前，对吧？你先得去看一看你这个单机到底能不能用好，
41:29对吧？其实现在的这个单机其实越来越越强大，对吧？像 GPU 每年的这个性能，其实容量其实都在翻倍，对吧？
41:36其实啊你是孙浩是很有，其实很多时候你的单机场景是够的。当然其实现在虽然说现在单机越来越强大了，但但是现在有个有个问题，就是现在单机系统也越来越变得像这个这个这个分布式系统，对吧？
41:50我们之后期也会介绍，就比如说像现在 GPU，对吧？像 black way 啊这种机器啊，它其实内部已经有啊，已经有是分布式的这个概念啊。
41:58大家如果去看它新引入的这个 feature 的话，我们这个有时间我们上课会稍微介绍一下吧。那这节课我们就啊不介绍，反正这个这个反正不管是单机也好， scale 也好，这个啊它里面用的技术点，
42:10其实字幕号都是啊互通的。后面其实还有一些特性的话，我觉得呃我们这节课可能就先不讲了吧。因为后面我们每每每每节课其实啊都会都会讲到对应的这样的一个啊内容，对超高问题没也不是很大。然后啊我们可能就总总结一下吧啊总结一下，
42:33就是就是说我们认为这个一个分支系统对吧，它这个它有很多很多上面的单系统啊，它有一些一些一些更加需要大家注意的这个点。比如说它的 pforformance 一定需要提供，然后 consistency 啊，在支持 performance 就会遇到这样的一个问题。
42:54然后然后这个这个 performance 啊，然后是我们的最终目标。在追求 performance 的前结果前提下，我们需要我们系统能够 scare scalable。因为如果你系统不 scheduable 的话，意味着什么？
43:05意味着说我资源浪费，对吧？我一百台机器，我如果你这个只能发挥你五十 IT 新任务，那不是意味着五十 IT 是浪费的嘛。那么在这个基础上分布系统，
43:14其实还有一个很重要的点，就是你能不能方便编程。因为当然大家可能都没有写，都很少会有经验去写一个集群的计算软件，对不对？大家想你写一个集群的计算软件，
43:24能不能像我们简单的写一个这个单机的计算软件呢？其实你如果你是没有任何框架，比如说像这种拍多少局，比如 UTT 的话，那么大概率是不行的那这个其实本质上是什么？就在于你到底该怎么去编程一个分布系统。
43:40其实对于特定的那种，比如说机器学习啊或者图计算，可能有一些比较成熟的框架。对，但对于比较通用的这个计算啊，这个这个这个这个这个分布式统编程其实还是有啊很多啊，
43:52很多还是可以很多值得研究的。然后对于每一项实实现这样的点，其实都会有很多的这个技术。这些技术基本上是所有系统通用的，比如说容错的话，它有 check pointing，
44:04对吧？现在大模型的容错其实基本上依赖于这个切框的的。 so 啊这这个东西和其实和传统的 check 框的没没任何区别，别啊基本没有区别吧，不能太武断，然后对于一致性对吧？
44:16我们有很多的一致性，这个模型啊，一致性模型啊，我们可以嗯会介绍一些。那对于大模型的话，它它其实一致性的问题非常弱啊。
44:24因为因为反正你也没法解释这个模型什么么出这个词。对的，那对于 scale break 有很多，这个比如说 adad balalcy，还有用这种新的并发硬件啊，这跟传统其实差不多。
44:35我们会介绍一些啊我们这堂课会介绍一些 AI 计算啊相关的这样的一个 skill scale 的技术啊，对 performance 的话啊这个就比较这个套路性就比较大了。因为怎么优化 performance，这个还是目前来看，还是非常应用相关的。所以我们可能会对于某一些 case 我们会做一些介绍。
44:53比如说模模型怎么做 scalill up，这个我们可能会做一些介绍。那其他的话可能就得依赖具体 case 具体看。然后然后虽然有这么多 poperty 啊，那么我们最后想呃结束前我们想表达的一点就是说就是说其实理论来说，我们希望我们的一个系统图话全都满足，
45:11我们既能 scale，又有好性能，又能好好编程，又能又有一致性，又有容错。但实际的这个系统图啊，
45:18它得做一些取舍。一个比较经典的对比就是 no seq l database ase 和这个啊 new seq u data abase 啊，就是 no CQ database，就是是没有有 CCD 啊，它能做到非常好的 skill 和和 onmance，但是它没有正对性。
45:31那对于这个 new csql 的话，它的性能比较差，但它其他都能做好。这个其实是没有办法同时满足。因为我们大家为什么？因为我们前面讲过有有 CAP 定义对吧？
45:40 CAP 定义告诉我们，就这两个能同时满足。那对于其他的一些系统，它其实也有这些趋势。那么其实那么我们回过头来就是说我们如果要做一个系统研究，或者如果大家做一个总系统架构师去设计了，
45:51对吧？那么我们第一点就肯定先得把这种类似雷达图对吧？画一下，看看我们能做到什么程度，然后再看看我们哪些不能做到，对吧？
45:59因为因为有一些比如说 CAP 定理啊，他是告诉我们是不能答。当然其实也有些啊除了 CPP 有些比较经典定理。那这个时候的话，我们就可能需要去啊问一下这个到底。比如说其实现在我们都可以用大模型，
46:11对吧？你如果大模型说我能不能同时达到 fortrists 啊，和这个 sisistency 和 liberty，他肯定会告诉你不能达到，对不对？这个时候你就就如果你老板给你布置了个任务，
46:20对吧？那你就可以跟他说，这个不行，行，好不好？那行，
46:23我们今天课就先上到这边，好吧？好，行，我们就先请约一下吧。安全这今天那个等一下我爱吃老，
47:03为什么我们个那个还是按，对吧？姐，你知道你妹了，轻一年突然臭的慌。好的，
47:25宝贝，那我我心里开始不完了。我说的啊可能啊，因为我想要绿色部，然后你先首先是的，在那个是有苹果在。
48:09对，然后我就拿那个新洗口头券啊，是有是是年多的，因为他这为我拿不来，因为他这问我知道不？我把我哥哥友给问我，
49:47那个爽那个我嗯嗯好极了，我去不嗯多出的事啊。不是，那有一个朋友可以得到，我其实是嗯我络是不是电脑调一百，你想放不起吃嗯。