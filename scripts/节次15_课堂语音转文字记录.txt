00:23一起看是是他就是好的，不不是就是法院 ok 来推往数去。嘘上门，你谢。残在因变量，不是好，
05:36行，我们继续 OK。那我们上节课讲到对吧？就是说有一个一些问题，就是说你如果 log 变得很大之后， OK 我的这个这个这个系统，
05:46它这个这个恢复就会很慢一些，很会很很容易固电。那怎么办呢？那其实我们其实就需要有一个方法把这个去发现哪些 log，它其实是不需要这个这个这个被 recovery 的对吧？这样我就可以直接把它给扔掉。
05:59那怎么总判断呢？其我们有有个共经典的这个系统就叫切换。就是说我们把一堆操作啊，这个历史我们压压缩成压缩缩缩一个状态啊，坍缩成一个状态。然后坍缩完这个状态之后呢，
06:12我只要存这个状态啊，我其实就不需要去记录这样的一个这个这个 log 了。那具体来说我们来看这个第一个 case study，对吧？就是我们的这个 logging。好，
06:23那么我们 login 里面我们讲到的就是说它其实需要什么？我们其实就是要把一堆 review 啊也好， enrereview elolog 也好，把它状态它最后塌缩成了一个什么状态？塌缩成了，实际上就是一个这个这个这个一堆文件对吧？
06:37就是一堆文件，这个文件体现了一堆传载性的这个修改。那我们怎么去 check 一下这个呢？那其实本质上一个最简单的思路就是好，我们定期的去把这个 log 文件去呃这个这个 review log 去跑一遍，对吧？
06:52我把系统停下来 OK，我把这个 review 从头跑一遍。然后我们其实就可以老把这个文件全都 flrush 掉。 OK 那么我们就可以把这些对应的 log 去删掉了。 OK，这就是一个非常基本的这样一个思路。
07:05那么这边有一个问题，有一个问题，什么问题呢？就是你你这个一啊，你这个我觉得这它就它就是性能太差，对吧？
07:12又但是啊你要保证这件事情，那我得跑这个 review log 的时候，我其实应用它就不能跑，或者它即使跑它也其实会被你这个操作干扰，对吧？因为两应用和这个 log 本质上是懈了一个 recolege，
07:24或者是就框本本身它是泄了同一个这个这个这个这个这个这个这个呃这个这个磁盘的这个介质。那这里就是遇到我们之前所说的，就是说你要去加速它，那你具体加速它的，你要其实相框本身只这是只是一个操作。那你怎么去加速的个操操作际际是 depend on 你的是吧？
07:44 depend on 你的具体的这个场景。那么在我们这样的一个场景啊，就是说我们是一个银行的应用，对吧？然后我的这个或者数据库基本上就是数据库，然后我的这个数据都是存在在文件里面。
07:54然后我去修改的话，我是先切改到我在文件。那么大家我们有没有一个办法能非常快的去判断哪些 log 需要被这个重做，哪些不要做呢？其实我们可以有一个判断，就是说大家想想我们对于一个 transaction，
08:11如果他所有的数据都写到磁盘上，那么是不是就就一定一定这个这个 transaction log 都重做了，对不对？那么在这个系统里面，哪些这个 transaction 的这个这个 log 是是是是是是在磁盘上或者说哪些哪些 transaction，它就是哪些传参性，
08:31它可能需要去重做的那像本质上来说，那些这个这个这个这个这个这个需要重做的这个传载性啊，它的 log 都在这个 page catch，对吧？一旦它不在 page catch 里，意味着么这个传参与所有的修改，
08:43它一定都被刷到这个词盘上了。所以本质上来说，对于我们这个其他控制系统来说，只需要什么？我们把这个当前所有的这个传达件的这个 page catch 全都刷回去。那么我们其实就不需要去这个这个这个这个所有的这个 transaction 已经提交 trtraction log，
09:03其实都都可以控制在了。为什么？因为这些 transaction 它不可能会出现这个 nothing 的，或者说 partially update 的这样一个状态，对不对？对，
09:14那这就是一个基本思想。那这边有一个关键问题，就是说我如果正在 flash page pach 的时候，正好又有 transaction 再去修改怎么办？那你不是很有可能你这个 flash 的这个过程永远做不完嘛。那像我们要说你 check 框架能能能正确的这个一个一个原因，
09:33对吧？是说什么？我一我我这个 chair 框架要反映的是一个没有出现黑夜的情况下，它能出现的这个正常执行。如果你这个个 check 框框，就是这个数据，
09:42它不可能在一个正常执行出现。那你这个你这个你这个换框架是没有意义的，对不对？所以所以我们会发现你要做这个这个优化可以，但是呢有一个问题得避免是吧？就是是你要我们 chaflflash 这个这个框架的时候，
09:54 OK，但不能有有人在同时时再再往这个配 ge cash 里去写东西。所以这边就会有一个这个这个这个我们的一个基本的这样一个协议。那怎么去避免这个没有 on going transaction。那么我们还可以做一个妥协。就是说我们在做这个 check point 的时候，
10:11 OK 我们先要做一个等待等待，让什么呢？等待让这个这个当前啊正在执行 transaction，先给去去去，先先给停掉，先给停掉。
10:21 OK，这个时候我再去 flash page catch flash 完之后呢，我就可以把什么 committed 的那个 transaction 都给的这个杆 lotion 都给扔掉。 OK，那就是我们这个基本讨论。那这这大家要注意一点，
10:33就是我们不能把所有的 transaction 都给扔掉，为什么呢？因为你这个你这个这个这个这个当前啊当前这个这个可能有些喘塞，这还没有做完，还没做完 OK。好，
10:45那么我们前面说这样的一个这个操作，说我们要做这个切换，对吧？我们要保证正确性，我们得做一个 stop p dee，就就是我们得让所有的一直都停下啊，
10:55所有的所有的喘塞都都停下。那大家想想，我们站在一个操作系统角度来说，你这个怎么去实现这样的一个势能，实实现这样一个势能。你一种方案是说啊，
11:04我我看一下我们一般来说这种 APP，对吧？总总归会有个前端这个前端去收请求，收到请求的话来做那么一种方式，就是说我设一个 flag 对吧？然后说我等当前的这个传载，
11:16这都做完了， OK，然后呢我再去这个这个这个再去再去做。那这边有个问题，就是如果我有一些喘载片，对吧？
11:23做的很长，做的很长，那么我这个这个不就整个 check point 就没有办法做了嘛。那这个时候其实我们可以有一个小优化，就是什么思就是谁不说呢？就我们其实是不需要等这个这个这个这个当前啊，
11:37就是说这个这个这个所有的传参 tion 全做完，我们只需要什么？只要等到这个传参 tion，把当前的这个操作做完就可以了，为什么呢？为什么呢？
11:46因为这个时候我们其实会会发现，就是当前你这个切换的时候啊，你的 trtraction 无非就是分两个，一类是什么？一类是已经做完的，一类是没有做完。
11:55那没有你对于已经做完的 transaction，我一旦 flash 了，这个这个配 ge catch，那一定它都会变成 committee。那对于没有做完的呢，我 transacflflash 了 check 的有没有和影响呢？
12:07其实没有影响，只要什么，只要我把它的这个 log 给保留下来，对吧？我只要把它 log 接下，我不把它的 log 扔掉就可以了。
12:15所以呢那具体来说的话，那我们这个这个整体实现就可以简化成就是说唉我是我需要把这个这个当前啊这个这个正在做的这个喘塞品啊，它的这些东西还是得做一记录啊，做一个记录，记到这个 log 里面，然后然后再做这个做这个切换的 OK。
12:35那这样的话就是说这个 recovery 的时候的话，我们就会相对来说的话，就会这个这个这个这个这个会稍微复杂一点啊，会稍微复杂点。因为我们的这个 log 它可能会有些传塞写 log g 这个这个这个这个待切换之后，你有些 lock 是丢弃的，
12:50有些没丢弃的对吧？我们得稍微注意一下，比如说这样的一个这个这个这个这个这个这个这个这个图对吧？这个图其实啊就是说这个这个这个讲就不种不不同 case 啊。对啊，不同 case 情况下，
13:04这个传参证怎么恢复啊，怎么恢复。然后比如说这个这个 t 二和 t 四对吧， t 二和 t 四的话，我们当中有一个这个这个 check 换的这个点对吧。那么其实我们这个恢复的时候的话，
13:17我们就要区分什么呢？就个区对吧？那么这个这个哪些传参证对吧？它是已经提交了，就在切换的时候已经提交，买的时候再小框没有提交。
13:25比如说在切框里面您提交的 t 一对吧， t 一的话，那这个传载性我们其实就就不用管它，对吧？那如果是这个这个 t 二 t 四的话，那么你不仅啊需要从这个这个这个这个这个这个这个这个呃他他们在撬框的时候，
13:40其实还没有做完。所以这个是我们其实还是需要做做这个 review 这个和 n view OK，那就是这样一个操作 OK。当然这个这个这里面啊，其实就是说有一点需要做的，就是说我们这边讲的这个 logging 的这个方，
13:53对对吧？这个本质上我们说这个 log 啊，目前是写到这个文件里面。但是这个 log 其实本质上是一个这个这个比较这个比较这个通用的这样一个抽象。就是你不仅不一定是要写到 log，你其实只要写到任何的，
14:06能保证这个飞裂的时候啊，能恢复的这个介质就行。比如说你可以是一个这个 replicated 的 server，像这个 russ，把它本照里面六个这样的一个 log OK 行。然后那么前面就是说有了 check copoint 之后，
14:20我们其实就可以去做一个加速的这样的一个恢复的这样的一个操作。那么 check point 的这个技术本身它还它本身啊，其实也能够啊用来容错。我们可以来举一个这个这个比较现代一点的例子，对吧？就是说虽然演习也不是很简单，
14:35就是大模型训练对吧？大模型训练，那大模型训练的话，本身它其实啊也很容易也很容易出错，还容易出错。那么我们怎么去保证这个训练的过程中，
14:45如果有出错决心的 OK。那行，那个不知道大家可能背景怎么样，我们可能先简单介绍一下，对吧？就是说这个这个给一些基本的 background 啊，
14:54基本 backon 就是说大模型训练是怎么样的吧。其实大模型训练和传统模型训练的差不太多，基本没有特别大区别。唯一的区别可能就是它的参数比较大，数据量比较大啊，仅此而已。
15:05那么传统的这个模型训练是怎么训练，那它本质上实际上是一个这个梯度下降的过程。就是说我定义了一个数学函数，比如说是是离我这个预期差多少。然后呢，我会然后呢会我这个模型有一堆参数啊，
15:18就是比如说这个 w 然后呢这个大模型它会用一个叫梯度下降的方法去更新这个参数怎么更新呢？就是说我其实可以这么可以这么想象，这是实际上是一个这个 w 的这个目标函数的一个平面 OK。然后我们要最小化这个 coast，就是说你预期的差别。虽然我们就会沿着这个最陡峭的这个方向不断的下降啊去做这个优化。
15:39那么这个优化呢它写到数学上呢，其实就是我们会去迭代去更新这个参数啊。这个上面的坐标代表的是你是第几维前序 sion 啊，每个前列 tion 呢它会跟算一个这样的一个这个这个这个这个梯度，然后会根据这个梯度算一个这个这 learning rate 啊去做一次更新，然后一直更新更新，
15:55直到什么直到你的这个 loss function 收敛。就比如说你是非常接近于 OK，那这是一个这样的一个这个这个这个这个这个这个过程，然这个过程会持续非常非常非常久啊，我这个更新可能会更新到非常久。所以说我们需要定期的什么？
16:10把这个训练的过程这个 w 给给下来，来保证这样的一个没错， OKOK。那么这个里面在大模型训练，它其实相对来说它没有都不是不是一个简简单单，它就是只更新 w 这样的一个简单的事。
16:23因为我我在训练练过程中，我们还得去确确保是是说我们这个 step 到底底去多大。因为你如果走的过大，它可能就会越过你的这个最低点。你走的过小呢，它这个收敛又比较慢。
16:34所以呢在大模型里面呢，它还有一个东西叫做这个 optomobobtissstate 啊， opadviser site 就是说就是说一般来说会有一些比较好的优化器啊，比如 adam 啊这种东西。然后呢它其实也会记很多的这个状态啊，记很多这个状态。
16:49然后它每一步更新的时候，不仅仅会去更新这个参数 OK，它也会去更新这个优化器状态 OK。那这个是我们这个这个数学上啊简单的这个大模型训练的这个一零一 ok 一零一大家六为就是说我我觉得啊就是说对于我们做系统的人来说啊，你其实只要知道到这个程度啊，其实够了啊，
17:08你其实并不需要知道这个更多的时间，我们其实就能够用它来，我们就怎么样来解决大模型容错的问题了。好，我们来看看怎么来怎么来解决。那么这个大模型容错，
17:17我们说前面我们给的是是个数学公式，对吧？那数学公式它其实并不能体现真正的这个系统执行。那么这个系统执行它到底怎么样呢？我们得把它从一个这个数学公式上的一个抽象形式，对吧？
17:28去映射到一个抽象系统。那么在真实系统上来说呢，我们大模型其实可以把它映射成这样的一套这个迭代迭代方式。比如说我们前面可以看到，就是还是一个一个 iterition，然么每个 iteration 呢它其实会分成三步啊，
17:42分成三步，第一部分叫 forward。第二个呢， backward 大加不里 update。 update 呢就是我们刚刚给的这个公式啊，它会去更新这个参数和这个这个优化状状。
17:52然后后 ward backward 呢，它其实就是去计算出来这些更更新所要的这个参数。那具体这个怎么不算这种，我们其实不其实不需要了解并需要了解。那么这样这其实是一个稍微抽象一点的这个系统模型。大大我们可以看到到我们把它给啊啊抽一一个呃 forward meackd d 和这个 update 时候，
18:11对吧？它其实就跟你的这个具体的这个这个这个算法已经开始有一些剥离了。 OK，那么我们要看看大模型里面的这个吹力的这个问题的话，那我们还要把这个抽象一点的模型给具体映射到一个系统。那么现在大模型是怎么去实现这样一个系统呢？
18:26其实其实我们我们大家可以看到到这个为止，我们已经没有任何的公识。我们就就完全把这个系统的它的系统，其实就是我们每一个这个假设有一堆 GPU 或者是 NPU 或者叉 PU。我所谓嘛，然后每个 GPU 上呢，
18:39它就会分一部分的这个数据 OK，然后它会去做一部分的这样的一个计算。计算完之后呢，它会去把这个所有的 update 去收集一下啊，做汇总一般般说，就这个累加累加。
18:50累加完之后呢，它会去再进行下一轮的这样的一个这个 update 操作，是一个下一轮计算 OK。所以我们可以看到它其实就是这样的一个所有的 GPU 一直在就是说我先跑一堆计算，计算完之后呢，我收集一下结果，
19:06更新一下，结束 OK 就这个过程。然后更新的东西就是我们前面讲的这个 oppomizer state 和这个 model weight model ight OK 就这个问题啊，就是就这就是这个这个我们对大部分去训练这个 sm model 啊，其实很简单，对吧？
19:19我们根本都不知道知道这个它怎么训练 OK。但是我的问题是什么呢？我们问题是大家回想一下，我们之前在讲分割式课的时候，对吧？我们说这个这个这个几 v 次训练的时候，
19:30它会告诉我们说什么。说这个嗯这个公开的数据就是说这个这个这个 GPU 训练的时候，它的 GPU 利用率非常低，非常低。非常低的原因是什么呢？就是这个 GPU 经常的挂经常的挂。
19:43那么这个对应到我们这样的一个这个 case 里面呢，它其实是什么？它其实就是啊我跑着跑着跑着时候，突然我这个 GPU 挂对吧？挂了，那我怎么办？
19:54我假设我我我去 replace 的一个新的这样的一个 GPU，我们应该怎么去恢复，对吧？其实就变成了啊这样的一个这样的一个问题。那这样一个比较比较直接的这样的一个问题， OK。
20:07那这个时候我们怎么去容错呢？大家想想我们前面讲过容大波型训练容错的一个关键点。什么？就是我们讲或者说容错一个关键，就是我这个容错这个恢复的时候，它的这个这个这个状态啊一定是要和一个就是没有出错的状态是一样的，
20:23对不对？那么对于我们这样的一个例子来说，假设啊假设我们这个假设我们比如说我们再抽上点，我们现在跑了这个九个 iteriation 啊，突然我这时候在第九个 iteration 挂了，挂了之后怎么办呢？
20:37其实我们其实跟可以根据前面用那个 logging 恢复一样，对吧？我们最简单的方法就是我们从第一个 iteration 去重新算一遍，对吧？其实我们可以根据算，因为大东辑里面，
20:48我们这个每个训练它无非就是去做一些确定性的这个计算，对不对？但是这样的一个方法的话，我们其实会可以很明显的发现它很慢，对不对？我比如说我训练了一个 iteriation，
20:59然后我一百 a 圈选挂了，那我就我就重新算，那不是很浪费几丢嘛。所以我们这边就需要 check point，就是我们需要把计这个这个计算过程中啊这个这个这个中间的状态可以保持下来。比如说我们如果能够把计算的时候的这个这个第四个 ituation 的这个状态给 check 换一下。
21:18好，那么这个时候我如果第九个 ituation 挂了，我们直接去从第四个这个 situation 去恢复。那不就是很快的嘛啊就很快了嘛，我们就不需要去这多。那所所以呢这个所谓的大模型的车况呢，
21:31其实非或者说为什么我们大家很多参数都在测况流，对吧？和本质上来说，就是我们在做这个计算的时候，原本大家想啊我们计算三步就是这个一第一步是 fhoard 的。第二步分括第三步是这个这个 update。
21:44然后 update date 完之后呢，我就后面要给它加一个车框。这个切换过的本质上什么呢？就是把这一步 HV ation 一算完的这样的一个数据啊，给这个这个写到一个持久化的这个存储里边啊，比如说是文件文件或或者说是云存储啊，
21:58就是这样的一程，这个过程就叫做 check point。然后呢，当我有一个 situation 挂了，我就从这里恢复就可以了。好，
22:06那么这个里面它用到了我们今天这节课讲的哪些知识呢？比如说第一点就是我们写 check point 的这个过程啊，它是需要 automatic 的。大家想想啊这个这个这个这个这个我们说你写一个 check point 百分之叫什么？是把你这个 GPU 里面的优化器状态和把的这个 weight，就是这个参数给写到这个存储里面，
22:27对不对？但我们先说你的大模型的这个这个参数啊也好，优化系统它是非常大的。也就是说我们写文件系统的时候，它其实是可能是一个这个你要一个配一个配置，写很久就跟我们做这个 f think 不同的账号一样。
22:40那么如果你写到一半挂了怎么办？我们能不能直接用这个写到一半的这个 adverssed state 和这个位置去恢复呢？显然还是不行的，对不对？那我怎么去保证这个东西的原子性呢？怎么保证种原子性呢？
22:53它其实用到的技术跟我们什么跟我们这个泄露靠背很像什么意思啊？就是大家看这个大户系车库的有一个很好的特点，就是吧？就是说我我比如说我在第 n 类特别性挂了，我其实用第三类特别性跟用你第二个前面线的这个 check check 框呢没有什么区别，对吧？
23:09因为我都可以通过重算去恢复。所以呢其实我在大模式里面 OK，我就一开始就保证一份就是对的这个 check point seene。比如说我就在第一个 check retion，对吧？我就先把这个 check point 的这个 organized say 先保存好，
23:23就最开始总归会有的。因为一开始 organized set 就是零，对吧？基本上是零，然后参数可能就是出 learning ize st 一下 OK。然后呢，
23:32我们之后我们假设要做 check point 的时候呢，如果这个 check point 挂了啊，我们就是我们不会让它去覆盖原来这个这个对的这个 check 况 state 我们直接是么？我们直接创新一份新的，一般来说是标号，就你记几个缺些，
23:44然后是吧？一旦你这个操作做完了，我再去用一个 rename，对吧？我把最新这个 check point rename 到你的这个最新的这个 check point 了，对吧？
23:53但是不就能保证我这个 check point 的这个 automathe state 和这个这个这个这个这个参数是对嘛。所以说这个其实我们也是能很容易保证，对吧？它其实用到的就是一些这个经典的这样的一个这个这个技巧 OK。好，那这里面大家可能会有个问题，
24:09就就是说你前面说了，我们们这个系统里面证证为这个方法，对吧？或者说容存方法很多是这个 logging。那么你这边又说我这个大模型用的是这个 chapoint point 这样一个方法去容错。那么这两者之间其实有什么，
24:23是我你是不是会互斥呢？因为为什么你这边不用 logging 呢？其实我们会发现这个大模型里面这个 check 框本质上它就是这个 logging 一个特殊配，或者说 lologin，它是这个拆框的一个特殊配置。什么意思呢？
24:34就大家想想，如果我每一个这个这个这个这个全 action 我都去做一个这个 check 换的。但是它本质上是不是和我们前面讲这个 radio login 是一样的，对吧？它本上一样，就什么意思啊？
24:47就是我恢复的时候，我直接啊唯一是唯一的区别，就是可能就是我不需要从这个 radio log 去恢复了，对吧？我直接就是拿最新的那个 check cort 就就行了，对不对？
24:56就其实本质上是是差不多的，差不多。然后我们在在大模型里面，其实我们没有不会遇到像之前所说的这个 log 和这个大小变得非常大的这样一个问题。因为这接 check check on 的话，我们只需要取什么最新的这样的一个 check cort 啊，
25:11我们其实就能够去做恢复了。 OKOK，那这边有一个问题，那为什么我们说这边 check count 跟 logo 还是不一样？对吧？因为其实可以看到的是，
25:20现在的模型训练的时候，它其实不会采用一个这个 proetution tion。每个 attuiation 它都会做一个 check 换的操作。为什么呢？为什么大家想想啊，它的本质上什么本质上是你的这个 check 框架。
25:33你为了保证正确性，我们前面说你是为了保证你 check 换数据。对的，你得把什么你再做 check 框的时候，得把这个这个基本上呃大家停下有有很多优化。就是就是说你你把 GPUU 停下一段时间，
25:45停下一段时间，为什么？你因为你比如我这个 GPU 正好再改你的这个切换，然后你又再去拷贝，那你的拷贝数据不就出错了吗？做 logging 的这个 check 呢实际上是一样的，
25:55对不对？所以为了避免这样的一个这个这个这个这个这个这个这个这个这个车况的这个非常大破坏的。所以目前人们的这个车况 frequency 啊，应该就是相对来说是比较低的。就是说我不会是每个人 dason 做车况的，我应该大概是每十个，
26:10或者说啊每二十个这个 ddition 做个车况的 OK。那这边就有个问题，就是说我们的我们实际上我为了减少这个 check， home home overhead，那我直接去把这个这个这个这个这个这个这个 check on francy 开很低不就行吗？比如说我一百个 ittuation tion 一百一百 attention 贝一个。
26:29大家一想这个做法合合不合理呢？它其实有一个问题，问题什么？就一旦你把这个 cocheck on fancy 的频率变低，你的这个 recovery 的这个开销啊其实会变大。比如说我们这边举了一个例子，
26:41比如说我每部 vituation，我做一个 check point。好，这个时候我如果碰巧大家，我如果是我机器挂了，那么他最坏情况下他需要做多少次重算，
26:51他其实要做四次重算，对不对？因为你这个这个之前四个推训的这个拆况都没有都没有。所以呢这个这个这个这个其实啊这个这个这个这个车整个就是我们其实最 care 是什么？其实最 care 是这个切换换的本身这个这个端到端的这个这个性能的影响啊，这个性能影响它其实是就是切换的对这个容错对这个大模型虚拟器影响其实有两部分就释。
27:15第一部分就是说它的这个这个这个这个这个这个这个 restar 啊，第一部分就是说我的这个本身的这个切换呢额外的啊，第二个呢其实就是说我的这个一旦我出错了，对吧？我去做一个重算太过外，那那它重算的代价大概就是基本上是你能 check。
27:31从概率上来说啊，大概是你的这个 check point 的这个这个这个 frequence 的一半 OKOK。所以所以呢我们通常来说也不不大会去这个每每每个这个这个这个这个这个每个这个 intertention 这样的一个去做策划的。好，那么这边大家可能就会有一个问题，有个问题就是说那我对于一个训练来说，
27:50它到底这个 check point profecy 该设置多少，对吧？那这个东西呢其实有很多这个经典的这个公式可以去计算。我们可以以大概来看一下，它其实啊其实取它实际上它其实并不是一个这个定制，它其实是得根据你的这个 c 列 rate，
28:07你的这个 check 框以及你有多少个这个这个 GPU 这个这个算出来的那具体来说的话，我们假设啊我们用之前那个 check 的 cormodel 啊，其实有很多 paper 啊，我们可以看到就是你的这个 check corent 本身对你的这个整个计算啊带来的这个 overhead，对吧？大大概就是这样的一个公式。
28:25这个公式啊，它这个 FF 是大 f 啊，是这个你的这个这个这个费列的赔率。这个一般来说这个定值就比如现在卡 ass 大概是每一个小时啊每个小时一次。然后这个 n 是你有多少个 GPU 或者差，然后 t 是总的这个 training 的时间，
28:40然后 r 是这个恢复的时间。然后这个小 f 是一个 check 换 francy，然后这个这个这个 o 是这个 check 换的 overhead，就是你做 check 换的时候，你 GPU 大概会停多久？然后我们一看到这里面的 f 实际上是一个变量，
28:52是个变量。然后这个里面的 f 其实如果你求个导对吧？可以，其实可以求解出来，就是说啊你要达到一个最小化的这样一个 tratrain，就这 tratraing 的这个这个 overhead 的话，
29:02那你 f 大概会取这样的一个值啊，这个值我们可以来看这个个这这个值本质上什么？就是说你的这个 ad 越小，对吧？你的这个这个 check check 的这个 fraccuracy 就可以调的越高啊，这些符合直觉对吧？
29:12因为你 overhead ad 很小，我可以高频的 check 换。如果你 overhead 很大，我得这个 check 的慢一点，慢一点，对吧？
29:18就是让这个这个这个 cooverhead 可以被这个特 overation 给 amatetezile amatesor。所以所以其实就是说这个个 check 的话，其实已经算是一个比较 closer。你就是说啊只要我能知道你某一个 check 换的方法，它的这个 overhead 大概是多大。然后我其实就可以算出一个最多的 check point from frecurcy。
29:35然后我就能够大概估算出啊，我用就方法在一定一个分裂 rate 下，对吧？去容去做容错啊，它大概能够带来多少危害。对，
29:45那么所以现在的话这个这个系从系统的角度来说，优化的话，大部分人的关注点其实都是在这个这个这个这个减小这个 o 上面啊，因为你 f 实际上是可能根据 o 算出来啊，一般来说你把这个 o 减小，总是能把这个 OO 害 ad 给降低。
30:01这边其实有一些有一些比较经典的优化技巧啊，因为时间关系我们可能不展开。比如说第一个技巧，就是说我在做掐框的时候，能够 GPU 的继续算啊，这个我们叫 open napping，
30:11对吧？有一些经典的工作向降，包括我们今年的这个 source 的工作，还有这个 check frequency 都这么都是这么搞啊。还有一个就是说我能不能让这个 check 框的磁盘这个变得更快快。如说像像 ource 的二三的这个吉姆奶，
30:23对吧？它其实干的就是说我把这个这个这个 check 框写到内存里，但是显然就比你写磁盘快啊，比较直接是吧？当然还有很多这个聚拢于啊聚拢于这个这个这个比如说我这个不同 GPU，如果它的这个参数是一样的话，
30:36其实我只要写一份，最起码不需要写多份。但这个其实还有一些小的这个优化技巧。比如说你根据这个从模型做优化，那那这个跟我们这个这个整个课 topic 啊，它就比较爱 hold 啊，
30:48就是说大家感兴趣可以自己去看看它的核心原则。其实就是一个就是怎么把这个 o 给这个截角 OK 好行。然后啊最后啊最后还有一个 case 点，所以我们发现切换的这个东西非常上有了所有的这个不同启统仪器都用，就是我们上节课讲到的这个啊 stuareventually consistence system 啊，不知道大家还有有印象，
31:10就这上节课我们其实讲到说就是你你发消息对吧？发消息我们一个理想的保证里边呢，就是说我这个不同人的这个手机啊，它的最后的这个消息啊看到的是要一样的。那么我们怎么做这样一件事呢？大家还有想法，
31:26就是说我们的问题是我如果有两个人，对吧？这个同时往这个手机发消息，但是他们两个的这个然后通过 sink 去交换消息。然后因为他们这个发消息的这个频率不一样，所以会就会出现哎，
31:39某一种情况下，就是比如说在 service 一这边观测到就是 x 先写 YY 先写，然后 server 二这边就 y 先写 x 先写 OK。那这个是是当时这个 image 是留下来这个问题。然后当时我们是怎么解当时我们的解法就是说 OK 我每个 server 它会有一个 log，这个 log 会记录当前这个看发的所有的消息，
31:58以及其他 server think 过来的这个消息，对吧？然后 think 完之后呢，我们去做一个在 log 里面做一个 reorder，然后再根据 log 的这个 order 啊去去写回。这样的话其实就能保证最终最终的这样的一个一致性，
32:12对吧？这是当时上节课呃上节课留的一个 case。那这个 case 里面其实也有一个问题，大家要跟我们这个做用，用这个 logging 做做伙伴里面的一个一样的。你如果这个 log 一直涨怎么办？
32:24因为就出现什么情况，就是我的手机这个这个聊天，对吧？每次 sik 完之后，它会越来越卡，越来越卡那怎么办？
32:30其实我们也需要一种方法去把这个 log 里面的一些这个状态，这个去去把它给换到这个这个历史使用里面啊，作为一个切换。这样的话我其实就没有必要这个每次 siink 都把整个 log 都给 load 了一下，对不对？那这边在这个 imagine consense y 和之前和我们今天讲的，
32:50不管大模型也好，还是那个那个那个那个这个这个这个 review log 也好，它有一个很大的不同点是什么呢？就是它的那个 log 啊是会变的，它的难点在于它 log 会变。为什么？
33:00因为你当你有一个新的这个他们下面的这些请求过来的时候，然后你去做一个 reorder 的时候，这个 log 它就可能就可能会变。那一旦变就是什么，就是我在一个 server 当前的这样的一个情况下，它其实是很难独自的去做一个决定。
33:17就是说我哪些 log 要要写哪些，那我不要写对不对？所以这是这是里面这款 c log 它做切换，就跟做这个这个我们讲做这个这个 review loggy 和大模型这个不大一样的这个点 OK。当然这边我们其实也有一些一一些比较简单的总整。对，
33:32比如比较最直观的，其实我们会发现这个这个这个 review 里面的这个 log 啊，它不是不是所有的 log 叫不，它不是所有的 log 全都会被 enreorder。为什么？大家想想看，
33:42我一个这个 reorder 的这样的一这个 entry 的这个本质是什么？是本质是说我一个 server 可能会 think 过来一个请求，它的这个 time ststeand 比我当前的这个 log 里面的有些 time step 都要小，对不对？但是大家想想看，如果我们的一个 server 能够明确的知道，
34:00就是说我这个其他人啊，所有的这个 server 里面，它的这个 tomesteand 不会比我当前的这个，比如比如说 log 里面的一些 timestep 更小。那其实在这个某个这个时间 tomesteand 前的这些 low entry，其实都能够被确定的排序一些盘，
34:15对不对？那其实我们就只要知道这样一个具体这个 time 这个时间点就行了。那这个怎么做呢？其实是能做的对吧？一个最难的方法就是我们说你这个 server 每一次跟其其 serserver 同步，它其实是可以知道每一 server 当前的这个或者说它它历史上的这样一个信息时间点的，
34:33对不对？然后我比如说我每个 server 我都看到了一个它的这个时间说是十的这个请求啊，那我们就可以知道啊，比如说我们用 anapple 的状态，我们就能知道这个这个这个当前这个这个系统这个 server 其实不可能会收到一个他们三大于啊小于十的这个请求。那么在这个 log 里面，
34:50所有小于十的请求我都可以什么都可以被 check point 掉，我就直接把它给放到这个聊天记录里面了，对不对？当然这个方法会有一个问题，就是如果某一个 server 对吧？它这个离线啊，
35:00对这个 server 它就他就不响应了不响应了的话，那我不就意味着说我的这个这个这个整个这个这个这个这个我就这个 lock 还是没有办法切换的吗？那这个时候的话，其实也有也有一些方法。就是说我们可以用一些心心化的这个服务器。我们就是说我们比如说腾比如说我们要实现微信号，
35:18对吧？微信它肯定会有一些 hily available 的这样 service 这个这样数据中心。那这个服务器呢它可以去帮你的这个这个这个具体的这个这个这个这个那些没没确定完顺序消息啊，把一个确定的叫做 commen commestep 啊。然后比如说他打了这个 command，他们算了之后呢，
35:35我去排序的话，我就去这个这个这个这个这个这个这个我排所有人排序的。是我先按 stecommen time stter，再按这个本地这个时钟去去排序。那这种情况下的话，其实也就避免什么？
35:47就一太 server 啊，大家如果失联了， OK，我其他的这个 server 可能就这个最小时间抽就不涨。因为我只要能跟这个呃的这样的一个 priserver 去联系就行了啊就行了。当然这边有会有个问题，
35:59就是说你这个 compensttime step 对吧？怎么去保证这个 cosalic？我前面我们上一个如果再分享，就是我们说一个很重要的点，就是我我我这个 local time stem 本质上是是要保证这个这个这个口火灾。 ity 就是我如果一个事件他看到 a 看到呃 b 看到了 a 那么 b 的他们 ent m 一定要比 a 大。
36:16但是会不会有一种情况，就我我的这个 local local time time 比 a 大，但是呢 b 的这个 comentime stem 去比 a 小，可不可能出现这种情况呢？其实是是有可能的，就如果你不做任何的控制吧，
36:25那这个时候我们怎怎怎怎怎么办呢？其实一个一个很直观的说，就是说我们这个 comment time stem 得有一些这个得由这个 lohave some 更大的这样的一个时时间间。 server 需要息。比如说我我这个这 serserver 吧吧，如如果看到了这个，
36:42比如说我看到了这个一个它 depdon 的实验，因为他去拿 comment ence on 他把他之前的依赖的这些全都拿完。那这样的话其实啊就能够保证这样的一个盒 SIP，好吧？行，那然后我们这个啊总结一下啊，
36:56总结一下。今天的话其实我们主要就讲了这个这个 audustsing 啊， automaity 啊这样的一个视觉，以及它实际上它的一些经典这个方法，包括 shelter copy 啊、 logging，
37:05还有这个 cheort point 好吧。然后就是说我们也呃搭建了一些这个具体的作用，插框的这样的一个例子。好吧？行，那那这这个我们啊就节节课，
37:15大家表现，我们今天时间可能就到这儿。好，那我先下课。嗯嗯，不是嗯嗯嗯看得见空。
37:49不使劲吧，结婚就嗯与不着分散，或者说不好笑。建模都是这面膜那个的整理呀，我都要还不是他有让流量吗？还有任何这一个，
38:39我已经帮我，你之为我们缺货。然后然我因会是不管你对我要一点我心求，那就是去做饭。就此每一天，为什么怎么新买的？
39:29这他这个不符合。所以教学实期研究员对对，是你做运动好，要不儿经常的运，真的，你是当朋友一个。
39:46我这个开车机没到了吗？你说不是我说谁用的？八零零零端端口要求用谁用？八零零零端口真的什么联系号？你好，还一个不符合人文规律啊，
40:03全是是五值二回贴的那个热的泡滑剂，他他官方给他放的比做的好吃。对呀，你别好气了吗？最低最早还有一个问题，但但他说的是对清的，
40:35没这个什么，我没有点默认，我没动，应该就是点 f 里面哦。可以，这一个是应该是大于等于呃有小数点也不行，
42:32有小数点，有预算，还有个映着的。有小一的话，这个算出来的结果就是就会给你嗯嗯嗯嗯嗯。那比如说他这个颜色是比如失败的啊，
44:30进行在下一步操作，是让他们我给你其他措字比较偶陷。主要是这个我已经说是什么问题啊。对，当时有个链接也没有刚刚过的丢的，我还没有个就记了，
47:18真不难的，你就得往前走啊。嗯什么是？对，这样吧，你特那个那就是嗯这个是哪刚还好，
51:21反正我们三个都这么快的钱，就是呃我一开始不用配我们的后端，这是他自己的够一点。美你的在一起难关西啊，还我看上去我巧克力，那我觉得全都是把它和我们微信 q 进去，
51:58你可以就先买一个，它就是这边，那你不是三匹配一块就行，你没能用吗？你都可以直接用我的那个嗯一小时间，就是作是 sorry，
52:16一嗯进去了。然后就是那你的任务，我就是为什么我上次就是把这个从业值上，不是，就是相当于他是给他发行的，搜了 address 十五 address s 五跟我在一起，
52:37或者是二零二零。这个是这个后端，只要一直就是他那个这里端西先试一下，再清一下你的。他找我就是他昨天希望我们递交会要备选的备选的工具要自己去写。我还有种，
53:21但是情情要不那么就那个多喜快递，我允许那有一些我没去，就是先跑下了。对，没有直接进来。他是你就想想说这个什么进化数量也数量，
54:02但是我已经推出来了，这还不用，而且这是是什么？问你定其他的思维，我觉得发这个就不用莫生了，听不到啊，
54:21给你发个号，你一天嗯，我没有这个后面说支付对密码，就是那个 ST 再开一遍，你一个是。