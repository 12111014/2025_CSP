00:19一是是谢谢没啊。好，那个这个我们我们继续上节课的这样的一个内容。 OK 那具上节课我们再回顾一下，我们说上节课我们前面讲了一个 imagal consistence store，对吧？
05:46它其实本质上是能保证我不同设备的这个聊天记录都是最终能一样的。那么我说这一样的话，它对于我们大部分交流的那容，如果你用 photopro，它基本上就够用了。那现在呢会有个问题，
05:58就如如果有先应用，对吧？它对于这个谁先谁后，这个事情非常敏感。比如说我这个接龙对吧？我说第一个人拿到会有比较多的这样的奖金啊，
06:07我们会发现你用蓝 pod clock 去去搞呢，会有一个问题，就是我有两个事件，对吧？我明明没有办法去区分 alice bob 他们去发起这个兼容到底谁先谁后。但在蓝 popod clock 里面，
06:18他一会儿给了 alice，先一会儿呢又给了 alice 后。那这个东西的话，它其实对我们的系统其实非常不是很友好。具体来说就是蓝泡的，它有有个很强假的，
06:29就任何事件啊，它一定是有时间谁后的。但是你在分布式里面，其实你很难分辨的出，对吧？我两个事件如果是同时发生的，
06:37或者我在相近时间发生的对吧？你到底是些时候呢？其实这个时候理论上来说，我应该告诉你这两个事件，我区分不了他们的这个 pocosety 的这个关系，老区分不了关系，
06:47你应该要推倒重来。那么这个的话化成这个如果我们有系统的这个语言表达的话，就是我们需要在这个 cosevenent 之间去建立一个这个 parture 候的。如果两个事件，如果 a 啊如果一 event 一导致了二发生，我的这个时间戳要比你小。
07:03反之一来。那如果我的 evevent 一和 event 二之间没有任何的这个框作的这个关系。我要告诉你这两个这个东西这样时间戳啊，这个这个这个完全没有这个这个这个这个完全没有这个这个呃这个这个这个这个这个依赖的这样一个关系 OK。那么我们怎么去实现这样一个时间戳呢？其实我们也可以，
07:22我我们只要在 lampod d 这个 clock 上去做一些简单的扩展就能实现了。具体来说，大家想想我们 lapoort clock，为什么这个这个这个没有办法保证这个跨 server 的其实比较好，从 server 之间我们给的比较多，为什么不能实现跨 server 之比啊？
07:36因为我每一台机器它其实不知道另一台机器的这个时间戳是多少，对吧？那我当然没有办法给你，大概是七十 p 啊。那好，那我就做一个 vector clock。
07:47这个 vacor clock 里面呢，它我这个实验戳是一个 vector。然后每一个 vactor 的项代表的是我某一台 server 的这个我我不是 server 零，它观察到了其他 server 的这样的时间戳。比如说我这边有两台 server OK，我这个 seror 只有两项，
08:02第一项是这个 server 零的这个时间戳自己的时间戳。第二项呢是我我当前啊观测到了其他 server 的这样一个时间戳。然后呢，我们跟这个这个 lamer crock 一样，我每个时间呢或者我每发生一件事，我或者我每时间进步之后呢，
08:18我我会把我己的这个时间说说说提升。比如说色纹零对吧？它发生过呃它这个这个这个过滤表，我就把色温零自己的这个 cock 去提升。但我不去提升其他色 ver 的，因为我并没有从其他色个这边去听到这样的一个消息。
08:33 OK。那么大家想想，如果我们有了这样套机器之后，我们假设两台机器不同步，也就是说他们的这个事件是没有关系的。比如说我 i 呃我这个这个 server 零，
08:44对吧？他收到了一个 IX 的这个消息，然后 server 一收到一 XY 呃 add add y 的这样一个消息，你会发现 server 零的时钟对吧？它就变成一个二杠二，然后 server 一的这个时钟啊，
08:55 server 一时钟呢变成了这个一杠三。大家想我们站在这个 slacor 这个比较的角度来说，这两个 vector 我们能不能说是谁大，两个都比谁大的。那么我们说在这个 vector crop 里面，一个 cop 要比另一个大的话，
09:08它一定得什么？所有的这个 actry 都都比另外一个大，那比另打我们才能那么好。大家想想看，我们假设这两个情况就两两台搜之之间有有任何同步的话。那么大家想他们发生这个事件的时间戳，
09:20其实就是一个不可比较的时间戳，对不对？那么这种情况下的话，这个 vect pop 就给我们建立了一个这样一个 part 多的。就是你有两个事件。如果他们没有通信，
09:30他们其实这个是你是没有办法比较的 OK。那么这个我的 vect pop 什么时候通信呢？其实跟我们之前的 lamper pop 一样，就如果 server 一 OK 给二零发了一个 serthink 的这个信息，那我我二零 server 一和之前的 number clock 一样，我会把自己这个 back ack clock 啊发给这个这个 server 零。
09:47那 server 零就会把这个每一项安全更新到这个比 server 一的这个每一项安全都更大。那这样的话，我这个 server 零之后的这个事件的实实验漏就也比 server 一这个事件之前的这个实验都更大。那么这个这些其实就满足了我们之前这个提到的对吧？我们就是说要有一个 passh al order，对吧？
10:06如果这个我 server 零是一个 ad y 对吧？如果我这个啊这个这个 reference y 的话，它实验出后其实就会比看这个更难度 OK。所以呢我们在有了这个两 p crock 基础上，我们只需要稍微做一些小的这个 fix，我们就可以实现一些一个 pasture all 的这样时间戳。
10:22然后有了这个 pasture all 的时间冲呢，我们在遇到刚刚那个这个兼容的 case，对吧？我们其实就会发现哦， IS 和 ball 是同时在做的那我就让两个人都擦掉，而不是说直接就给 IS 显示一个什么呢？
10:33就你一开始排第一个，然后突然你变成第二个的这样一个抽象。当然这个这个这个这个 vacket clock 啊，它有一些有一些问题，对吧？比如说它的这个这个这个呃它的这个你当你的 server 变多的时候，
10:47对吧？它其实可能存储的开销会比较大。所以呢它一般只有在那些需要去做这个 conflict detection 的这种场景啊，才才会才会用。比如说像这个这个那个叫什么 amazon 这个 dynamo 啊，大家有兴趣可以看一下，
11:02这是零七年的一篇这个 source 的这个 paber，对吧？它其实里面就讲了，就是说这个这个这个这个怎么用这个 backor clock 去解决这个两边的这个没有依赖关系的这个写操作。这样的话这个它的做法其实简单，也就是抛给用户去解决 OK。
11:19好，那么我们回过头来看一下我们这个前面讲的什么呢？我们前面讲的一个例子是说，就是说我们的有些应用对吧？它其实是是是，对于这个 order 挺重要的，
11:31它不它不能够允许。就是说我这个 order 啊，我一开始比如说 alice 看到 alice 在后后，然突然看到货 b 在线，他觉得这个事情不不行。那么我们之前的一个简单的 solution 是说什么呢？
11:41是我们让这个用户对吧？我们让用户啊去把这个这个这个这个这个这个这个这个这个我我我去告诉开发者说，我们当不能比较的是我们我们让你来处理。那这种情况其实也不是特别友好，为什么呢？因为 alice 他一开始他其实看到了，
11:55说哎自己排第。但是突然我又告诉你有一个病情的人去和你冲突，对吧？你这个也得重重新的去接龙，这也不是特别友好。那么我们有没有种方法能避免这个情况呢？
12:07其实就是还有一种方法，就是说我们就选一一个较强强的这样的一个一致性模型。比如说像我们右边画的这这三个啊，就是目前来说用的比较多的，就 secretion 一些 n sibility 和这个这个 strit t strict consenstcy OK 啊，这三者把这三者，
12:24它其实就是能够保证爱丽丝永远不会出现这样的一个情况啊，不会出现就说他看到的顺序变的情况。 OK。那么大家想想的话，我们那我们现在要求是说我的顺序不能变，对吧？
12:37那么什么叫做顺序不能变呢？就是我不同观测者看到的顺序是一样的，这或者说用我们通俗点，就是说我的聊天记录都是一样的。什么样才能那个呢？其实我们这些所有的这个强的一 g 模型啊，
12:49它背都有一个特性。就是他他他告诉用户，就是你不管是谁在什么时刻去观测你的这个所有的这个操作，都能够等一下我一个确定的这个顺序。这个什么意思呢？就是我观测就是说观测出来的一定是一个确定的顺序啊，
13:05或者是叫做 theory 的这样的一个 order。什么意思呢？比如说我们假设啊我们有一个 system，然后它有一个数据被 replicicate 在多份。然后我的用户他可能会并发的去对这样的一个数据去进行读写。然后我们其中这边每一个颜色就代表着一个这样的一个操作。
13:23大家可以看到，从分布器中角度说，这实际上是一个非常难以推倒的这样一个系统对不对。但是我们说如果你实现了一个强的一致性模型，什么呢？就是我这个系统，
13:35你不管我的系统给你的一个抽样，就是我所有的这些操作都会等价于在一个一份拷贝的这样一个数据上。然后我去按按序的按照一个确定性的这个顺序去执行。就是我不管这个这个这个怎么执行，他一定最终的结果就这样。那么对于到我们之前的例子，
13:52就是你你 eice 的这个接对对吧？他一定是第一个。然后呢，他只要他看到第一个，那么不不管 bop 再怎么 pose，他一定是第二个啊，
14:01就是不可能会出现一种情况。他他看到的数据是两个。因为大家想如果你看到两个的话，意味着你就没有办法去等价于一个这个这个只有一个一个这个一个一个拷贝的这样的一个数据。然后一个串行执行的这样一个系统， OK 所有的这个强业这些模型都有这样的一个一个特性，
14:18一个一个特性。 ok 那么但不知道大家可能会好奇吧，就是我既然有那么多的这个不同的这个强硬制模型，那么它区别在哪呢？我不知道它最终等价于都等价于这样的一个执行，那么我我我的差别在哪？
14:32它它的差别其实在于我等价的这个执行的顺序是怎么样。就是比如说我 alice 对吧？我这边发起了一个操作，但是不是有一种可能，我最终等价于我这个操作被排到很后面去执行啊，那这个其实也是如果你从等价于某一个单一的执行的话，
14:49那这确实是有可能的，对不对？但这个其实是对用户其实不大友好的，对不对？因为我们明明很早就发生了这个这个那为什么我一定要在最后时刻才能才能出现了，对吧？
15:01这个其实不好，我应该是我发生的时候，我就应该被排在我发生时候的这个操作序里面，对不对？所以允许这个哪些顺序就 order 的这个顺序的这个可可能的顺序啊啊它就决定了你的这个一致性模型，它的这个强和弱啊强和弱。
15:17那那我们到底不同用户需要哪些强和弱的模型？它其实我们前面讲的这个 evention 一样，你就是你稍微强一点的模型，你稍微好好一点 order，对吧？它就需要一些额外的这个呃实现上的这个开销啊，
15:29所以这本质上也是有费用的。 OK，其实我们来看一下我们这个例子啊，我们这个例子就说呃比如说我到底哪个顺序是理想的对吧？我们说啊这个这个这个这个这个我 f bob 还是去做这个接龙，对吧？
15:42然后我们有一个发生顺序是 s 它先发起的，就是先比如微信这个按钮按下去了发送这个按钮。所以它的绝对时间点是在这个 bog 之前的 OK。那么大家想想，在我们这样的一个接龙的这样 case 里面，对于这个理想情况的这个我最终等价的这个大家观测到的这个顺序应该是怎么样的，
16:02是不是应该观测到这个 alice 的这个操作在前 pose 在前，然后 bob 的 pose 操作在后，对吧？因为我这个从绝对时间上来说，是 alice 先发起的那我一个好的这个一致性模型，我实验出来这个系统是不是应该符合这样的一个这样的模型。
16:18那么这个模型其实是目前为止人们定义出来最强的一句模叫什么？叫做这个这个这个这个这个叫做这个 strict consistency，什么意思呢？就是说他是说不仅你的这个这个用户啊，他的这个这个最后系统跑出来等价于一个这个一致的这样一个顺序。而且呢这个顺序的排序是跟你的这个操作的发起时间，
16:40就是我按一下这个开始这个按钮啊。对，比如说 i is 先按按钮。那我在我这个顺序里面， i ice 就一定在先先接容 OK，这就说这就是这个这个系统里面讲的叫做 strict consistency 啊。
16:51那么大家解决的话是我们这边讲的是用户期望，对吧？就说对于我这个兼容应用啊，如果我要用一个强的经济模型，那么我期望他来说，我希望是要有一个 strict consistent model。
17:02但是呢有一个问题就是呃正常来说啊，你这 strict consiant model 是实现不了的，就没有任何一个分布式系统，甚至是单机系统，你也实现不了一个 street consisttly。大家想想为什么为什么实现不了。
17:14我们可以来举一个例子啊，我们还可以举子。大家想想，假设我们现在要去实现一个这个 strict constency 的这样的一个这个这个聊天记录，对吧？我们假设是信记录录呢呢，
17:26我们们我们实实现这个我们说它首先是一个强的 concont 自己，就是说它的 execution 一定是一个串行的这样的一个值等价于一个串行的唯一的一个串串执执。那那我们们首先我们要先去实现这个串行的执行，我们怎么实现呢？我们前面其实上次一开始我们就讲过一个很直接的串行实现什么？就我拿一台 server，
17:46我就用一台 server 去做这个这个这个这个这个存出来呃，存那个这个数据。然后我所有的请求都用 RPC 的形式。然后我 server 做完了反馈，我才认为这个操作结束，对不对？
17:58那这就是我们的这样的一个串行的这样的一个这个这个实现。那我告诉大家，这个实现它实际上不能满足这个这个这个这个这个这个这个这个这个这个这个这个这个这个这个 strict consist，为什么？因为我们 stricconsistance 要求我这个操作执行的顺序，得按照这个操作的这个发起时间排序，
18:18对吧？就是说我 alice，如果 pose 在前，它的物理绝对物理是要发生判年，那他在在 server 里面得先做 OK。但是大家想想，
18:26我们现在这个实现里面它的顺序是吧？它会去 depends on 你的这个 server 的收到这个消息的顺序来做 OK。那么这个的顺序其实跟你的发起时间是不 match 的，对不对？那么我们有没有办法让你这个 server，他做的这个时间是跟你的这个跟你的这个这个发起时间是相同的。
18:46我说这这个事情是不 practical 的，为什么呢？我们可以来举一个例子，我们只要这个例子，其实一个最简单的例子你都支持不了。那么我们其实会发现你更更更加简弱的 case，
18:56对吧？也治不了。那我们例子怎么样呢？我们说是这样的假设啊，我们有两个两个人，然后 post a 啊就是 alice 兼容，
19:03 pob b 接呃 pose 兼容。然后 alice 的这个发起时间比这个 bog 要早 OK 我那我们说在按照这个正常情况下，我们需要让这个 server 先执行 alice 的请求，对吧？再执行 boall 的请求，对不对？
19:18就是我们正常要如果你要实现 raict consistency，我们得实现这点。但大家想想，我们说在分布式系统里面，我们发起消息的开始时间到它具体执行时间其实是有个延迟，对吧？
19:29因为你分布式里面消息是有通信的，比如说通信有通信的延迟。比如说你 alice，虽然它在物理实验上先发生，但是它很有可能它比这个 server 是晚到，对不对？
19:41晚到那这种情况下，我怎么在在 server 的角度来说，我怎么去判断这个 alice 和 boss 这个这个消息对吧？到底是谁先谁后的对吧？那你大家我们肯定前面回想一下，对吧？
19:53我们前面讲过，第一点，你用时间戳其实是没有办法判断的，对不对？因为你这个每台机器时间戳先先发生它的这个物机器的物理器械一定是可有，不也不是一样，
20:03就有可能会比爆爆炸，对吧？这种情况下，你其实没有办法判断我这个这个这个这个这个这个这个这个这个 s 在先还是 bob 在先，对吧？第一你就你就没有都没有判断。
20:14第二个是大家想想，我们即使你你有办法判断，比如说我们两个 i 和 bob 都用了原子钟，都用原子钟。我们这个套方案能不能实现呢？其实也不能不能，
20:23为什么呢？因为我或或者说也或说说 pryacle，不 pyacle 的原因是什么呢？是你要实现 strict consistence，你的性能会非常非常烂。为什么？
20:32因为你比如说我假设 i 和 bob 的给他们对严格表达了他们的这个事发发生相果关系。但是呢在在我们的一个系统角度来说，我们的这个 server，对吧？它先收到了这个 bog 的这个消息。好，
20:45大家我们在收到这个 bug 消息的时候，我们这个系统能不能继续执行啊，能不能执行 bog，这个请求不能执行，为什么？因为它前面很可能有一些请求是其他人发的。
20:55然后他的这个开始的这个时间是比这个报 g 的这个时间要去要那个要要要叫什么，要那个叫什么，要要要要早的那我站到我系有角的时候，我必须得等到这个前面的那个请求都都到，对吧？我才能够去那那意味着什么？
21:10因为说我我这个系统它会去等于很多的这样的一个很多的这样的一个这个体验。所以它它其实你也没有办法很高效的去执行这样的系统。所以呢我们其实其实对于一个大家也可能会说我我我的我还有一种方法就是我的这个 bob。这个这个这个这个我 alice 如果到了这个，我我可以先执行 boss。然后那 aleice 到的时候呢，
21:32我看看有没有时间抽比我小的这个请呃比我大的这个请求执行，如果执行了，我就把它给 a boss 掉，这也是一种方法。那这种方法其实也不大排 tial。大家看为什么？
21:41因为你在分布式里面这种消息的这个 reolder 是非常非常多的对吧？你这一旦 reorder，你就有 boss 掉，但基本上你的系统其实是非常好。所以说在这个真实系统中，虽然对于这个兼容来说，
21:52它的这个比较 design 比较比较好的这样的一个一个一个一致性模型是这个啊 consequsttly。但是呢由于这个实际啊实际的这个各种各样的这个限制啊，我们其实在真实系统中是不大会去实现这个 stram consequsttly。当然这个大家作为理论上来说，我们可以把它定出来啊，我们可以定出来。
22:12所以呢我们就会发现啊，其实现在的系统它用的这个方式啊，它其实不会等。比如说我这个 server 对吧？我收到了哪个请求，我就开始做了。
22:21所以说我这个请求的排序其实是按照这个 server 的这个比如说 sencentralize 这个迭代流是按照 server 的这个执行操作的这个顺序 OK，那么去去去去去这个去执行啊， OK。那么就是现在的这个系统的这样一个实现 OK。那么这个问题来了，那我们如果现在的这个系统，
22:38它假设我们这个 sentralize 的这样一个系统，那么它提供的是什么样的一个顺序呢？大家想想我们这个时候就会发现有个问题，就我我们这个站在 server 的这一层面对吧，我们是能够知道这个操作顺序。但是站在 application 的角度来说，
22:54它其实是并不知道这个 server 的执行顺序，对吧？大家我站在一个手机的客户端，我怎么知道你的一个中心化的服务器是按照什么样的一个方式去执行这样的一个操作呢？其实我并不知道对不对？所以我们需要有一种方法能够让 application 去推导就它他发送的消息的这个顺序，
23:14对吧？和 server 发送消息之间顺序的有个关联。因为我们这些关联其实对用户来说才最重要，对吧？因为我需要去知道，就比如说我哪些操作一定得排在这个哪些操作前面对吧。
23:25站在我们之前的兼容角度来说，比如说我有一个兼容操作，他在这个 server 执行的这个时间啊先执行，对吧？那那他之后他在不不不站在在 PP 小的时候，他已经执行完了。
23:36那么我们期望的什么期望的是站在这个这个我如果在一个操作执行完之后，我再发一个消息，那么这个消息一定得什么？再一个这个另一个消息就执行执行的后面，对吧？这个才符合这样一个逻辑这样的这个原则。
23:50所以我们这边需要做一个简单的转换。其实我们会发现这样的一个这个 centralized 的这样的一个 ansserver，它其实实现的一个顺序叫做这个呃叫做 completion be susuing 这样的 completely before 这样的一个关系。什么意思呢？就是比如说我如果有个操作啊，叫做 pos a 啊，
24:08然后呢我这个 server 返回说我这个 pos a 做完了。然后当我这个 pos a 做完之后，我再发起另一个操作，比如叫 pos c 那么这个 pos c 这个操作，因为它的开始时间是晚于这个 pos s 的的这个结束时间的。所以最终在这个这个最终它们等价于的一个操作顺序里面，
24:29这个 pos c 一定是在这个 pos a 之后啊，这个叫做这个 comdition to issue 的这样一个关系。那么这个关系是我们这个 centralized 的这个这个设计是保持的那它其实在分布式里面，它其实也有一个对应的关系，叫这个 ledialized 这个 ability lediineze bility 啊，为什么？
24:47然后这个点其实非常重要，为什么呢？因为 leadless ability 是目前为止在这个分布式里面啊，它能够实现的这样的一个最强的这个啊最强的这个呃实实际过程中啊，最强的这样的一个一致性模型。就是我所有的操作。
25:00如果完序的，然后呢，同时我的这个这个这个一个操作如果完成了，再在它在客户端视角完成的，那么它后面发生操作一定是在是在在跟后面这个完成的 OK，那就是 lelearze ability。
25:12那么最个大家可能会有问题哦，我们前面讲 linlis bility 的这个 case，实际上是通过一个什么？通过一个这个中心化的这个服务器的例子去讲的，就是我们这个的 centralizq SO 它它能保证 indilix brility。那实际上你你一个比如说你一个恰 t 也好，
25:27你比如说银行的应用也好，对吧？你不可能说我这个数据只存在在一个 server 上，我需要把它复制多份。那么我们 linlis bity 能不能去实现这个在在一个副本上？比如说啊我们假设我们这个数据有两个 server，
25:40对吧？ p 零和 p 一 OK，然后他们两个存的是同一个数据，然后每个 server 它要去读和写啊，比如 post post 或者 poll。那么我们能不能这个这个这个让它实现跟这个 sunshx server 一样呢？
25:54比较幸运的是在 lidiu SS bility 里面啊，其实可以实现。但是实现方法其实也很简单啊，它的原则是什么呢？就是就是说我既然要保证有一个确定的序，那我就不要让两个人去同时的去读写啊，
26:08就是我所有的读写都交给一个人来执行。那么这个那我们一般叫做这个啊，大家可能听过这个名字，对吧？叫做啊 primary backup。就是说我虽然数据有多个副本 OK，
26:21但是呢我的这个这个所有的东西只能有唯一一个副本，这个副本我们称之为 primary 啊，其他 bback up。比如说在这个例子里面就是 p 零去写。那如果我这个 p 零，然后 p 零他干，
26:34然后如果其他其他的是副本收到到效怎么办办呢？我就去把它给 ford 到这个 p 零这台 server 啊去处理。然后 p 零呢他收到这个写，他会负责确定一个顺写的顺序。比如说我是 x 先写到，我会先等等把我这个操作啊全都给 forward 到这个其他人，
26:51那其他人都做完了，我才能够去做 OK。就这样这样一个比较简单一些。大家想想大家仔细想这个设计其实跟我们的什么跟我们的三叉 s 点，它其实是基本一样的，对不对？
27:05大家想想这个设计跟我们前面的中心化设计有什么区别？没有什么区别。只不过其他的数数据副本只是作为一个作为一个这个中转站，把它作为一个消息转发的这样的一个机制。当然当然它其实和三十 s 测比的话，它其实还是有一些不同啊。
27:21比如说啊它的不同点在于它的容错其实会更好。因为如果你的 primary 挂了，你那那那我们其实可以让某一个 back ackup，对吧？去去当当的的这 priprior y 做这样的一紧紧张一个请求，它容错其实会好。
27:33但是如果你是说从啊这个这个性能角度来说，它其实会更差。因为它这个 primary 会有一些这个这个 primary 会是很紧 OK。大家认为这个我们呃这个关于种容容错们们可能就啊再说。那我们说你在这个这个分布式情况下，你其实其实可以去啊模拟这样的一个 centers 的这个 server，
27:52去做一个这样的一个这个这个 unializzbility 的实验。我们其实也能很好的看，很很很直观的看出，对吧？这种东计实际上是啊 ununializability 的 OK。当然这边的话这个实现的细节方面，
28:05它其实有一些这个稍微需要注意的地方啊，需要注意什么呢？就是说我们的说在在 prime back up 里迭算里面就是 primary。他收到消息之后，他得把它比方说收到一个修改，那他得把它给 ford 到这个其他的这样的一个 server 去去做。
28:19那么其他 server 收了 for 的消息之后呢，他得按照他得按照什么得按照 primary 决定的这个顺序去写。对，比如说我这个 primary 决定，我 x 先写一再写二，那么我 p 一的这个 back up 一定也是先写一再写二，
28:31对不对？但是呢这在在实际的网络，它可能会发生这个 reorder 啊，就是我 server 它可能是先发了一的消息再发二十。但是你这个这个这个这个 p 一啊，它可能先收到二的消息，
28:43再收到一的消息。那这个时候的话，其实我们需要有一些方式，对吧？去让这个操作按序，对吧？
28:48当然大家也可能会说，大家可能会说，就是说这个这个我其实也可以等那个 right 一对吧，这个 for 的做完了，我再去发一个 for 二。那这这种情况呢，
28:59一般来说在在系统里面用的会比较少，因为为什么用为这个性能比较差，对吧？我得等一个这个 wrn trip 做完了，我才能才能做这个这个下一个这样一个消息啊，所以说呢一般。
29:08但是所以说一般来说我们希望有一种方法就是说在 PE 里面，对吧？它收到收到了这样的一个这个 reorder 的这样的一个消息之后，我们可以啊把它去做 fix。那这个怎么 fix 呢？这个这个其实方法其实很简单，
29:20因为我们其实发现你呃你这个 p 零对吧？我是实际上是有顺序的那我其实只需要把你的这个顺序给这个告诉 p 一其实就可以了。那告诉的方法就是我 p 零其实有个 c per standp 是吧？我告诉你就是说哎我这个 red x 一是一个第一个做的操作，然后 red x 等于二是第二个操作。然后呢，
29:39我这个 p 一呢他收到一个消息呢，他不会立即做。他做之前他会先确确认下下个消息的，比他这个 syp lus 是更小。这个这个这个操作是我都做完了。如果都做完了，
29:49 OK 我在我如如如果都做完了，我再去做这个。如果没做完是吧，他就等比如说我这边收到了这个 right 等于二的这个消息，对吧？我会发现这个一的这个消息没有来 OK，
29:58待会这这边它就就在那儿等在那等倒数么等到这个一的这个消息服务的过来了， OK，然后再做 OK。那这样的话就能保证一个就是在这个有服务的这个情况下的话，这个两个机器最终它的这个操作的这个顺序是一样的。 OK OK。
30:15当然这个就是就是我们目前的这个这个这个 linuize bility 的这样的一个简单的实践，对吧？ prime back 它其实也是一种主流的这样一个实现。包括其实像 raft 对吧？ raft 它背后也是实现了 linux bility，它其实用的也是 primary 啊，
30:29它唯一的区别就在于它有个这个 primary 是可以可以动态选的。这是这是稍微大家一个区别大家的车辆。那么我们其实到这个为止，大家也可以看到，就是说第一啊，我们在有这个 replication 情况下是能够实现，
30:43也是 prisiility ility 它是和 centralize 的 QS store 的这个 conconsency model 是一样的。但是它有一个很大的问题，就是它有两个很多很多问题。它第一个问题是它的性能其实比较差，对吧？大家想想，
30:54它的性能其实会比你这个 centralize design 会更差。第二个问题就是它会有一些人 reability ility 去，当然这些我们是可以可以解决的。这个后面的课程会讲啊，那那那么这个时候其实大家会发现这里面其实有一个什么 trade off，就是你要用一些很强的 consensus model，
31:09比如你就要实现这个 ENS ability 啊，那么这个我们就会遇到这里面所遇到这种信用的问题啊，你要你要针对性，你就一定会遇到这样一些问题。那我们能不能能不能就是说我们做一些小优化，对吧？
31:23我们能不能就是说这个这个把这系统问题干掉你呢？比如说我们前面说我数据，我们说 primary apple 点散，对吧？你的所有的 read 和 right 都都得走向这个 primary 才能做。那我那我其他的机器的数据不就浪费了，
31:35那我们能不能做个小优化，对吧？我让 priread 去读本地的这个副本，我不去读 primary，不不去 primary 读，当然我写还是得走 primary。
31:44因为为什么？因为你写你得靠 primary 去排序，对吧？那你读我是不是能够够读本地的？比如比如说我这个例里边啊，我这个 p 一这边我有多操作，
31:53我就直接就返回了。能不能这么做呢？其实我们发现这样做，它其实是不满足理解来自自被列的的。我们可以来看一下这个这个例子啊，这样一个例置。
32:04在这样个例子里面，我们一开始这个呃 x 都是一，然后我这个这个 p 一对吧，它自己本地读的是一，然后这边 PP 零它会有一个这个 right 啊 right 这样的一个操作。然后它会先 forld 到这个 p 一做完了之后，
32:17它再做一个本地的这样的一个更新，把这个本地这个变成二。然后呢， p 一的话它其实会这个这个呃之后比如说我这个本地更新完之后，它其实之后读的就是二，我们其实就会变成一这个东西。
32:29为什么不满足零零 s 四编形呢？我们其实可以这么看，就是我们就看这两个 read 这样的一个操作。这两个 read 操作里面呢，我们可以发现这个 read 这个 p 零的这个 read 啊，它是严格发生在 p read 的这个 complete 之后的。
32:43所以说理论上来说，在一个全局序里面，对吧？这个 read x 呃应该是排在这个 read x 之后，也就是说啊它这个操作应该排在操作之后，然后这个 read 它读到的是二。
32:53那么大家想想，我们一旦这个 x 变成二了，然后我我这个操作后面再发生的一个 read，这个二 x 之后，它应该返回什么，应该也返回二，
33:01对不对？但实际上它返回的是一，那这个其实就是一个出错的情况。当然大家也可能会说啊，你这个问题是因为你没有先去这个这个这个 update，然后你再你是先 forward 再 update。
33:12但其实我告诉大家，如果你把这两个顺序稍微调整一下啊，其实也也就是先更新 p 零，再更新 p 一的话，其实也会出现类似的这个情况，也可以构造出一个类似的情况。
33:23那么这个具体构造功能就就就就就是来改进趣可以推一下那 OK。那么从这个角度来说的话，我们其实会发现你一旦做了一些性能的优化，你其实在 consensucmodel 上就会其实变得更弱一点。那么像我们这这个图里面的，就是允许本地读的这个 consist，
33:38 momodel 它叫做这个 sequential consist，就是它保证了什么呢？就是最终的序啊，它只能保证我每一个 process 的这个序是是 match。但它并不能保证我这个 process 之间啊满足一个这个这个结束和呃呃开始了这样的一个关系啊，所以说它是会比这个 internewsibility 啊更加弱一点啊更加弱一点。
33:59所以我们今天这门课啊，今天这个课程也差不多。我们总结一下的话，其实就是啊我们讲了这个一系列的这种啊 consistency 的这样的一个 model 啊，从强到弱。然后比较关注的是实际上是这个这三个啊，
34:13这三个是比较强的啊比较强的。然后最弱的 eventure 的话，它只要关注最终数据集就就行。然后他们其实是会有一些这个这样的一个这个这个 trade off 啊，我们其实说分布系统的啊，我们可以画一张这个性能图啊，
34:27去去出去给我们。其实可以看到的是，对于这个这个比较这个这个强的这个一基性模型来说的话，它对开发者比较友好。它一激性比较强，但是它的这个容错也好，
34:38 salbrility 也好，它的这个 performance 其实都会都会比较差。那么在实际生活中呢，对于一些不大重要的就是呃不是说不大重要，就是说对一些比较娱乐的对吧？比如说你是这个社交娱乐的，
34:48或者说是你的这个是这个就是社交应用啊，它一般来说大家都会用呃比较弱的这样的一个一致性模型。比如说这个这个这个这个这个这个这个 iventual，对吧？然后其实我们会发现你 ivenge 好像出问题的时候也基本上是是什么？是因为这个这个因为卡斯卡斯出问题，
35:08一般来说也是因为这个网络的问题。但网络问题实际上在这个数据中心里面，它还相对来说比较稳定。所以这边 facebook 它曾经就做了一个测试啊啊，他就说说你你这个这个原装卡斯在自己平方里面到底有多少的用例会和零 DSS 体相违背它。其实发现里面其实你这基本上很少一百万个操作里面就一个操作，
35:27它可能是违反了这个 lie DSV 体。所以说明你真实场景中，我们其实大家用微信也会发现，对吧？微信大部分时候它的不不仅响应快，对吧？
35:35它的这这个这个这个这个这数理基本上也是正确的。 OK 行，那么啊我们今天这节课可能就先上到这吧。我们这个这个线下内容，我们下节课再说啊，我们时间也很多信号，
35:49这个你是否感情的足地不会退还行，一起继续一点半。对不起，还你说对，不是这个没有继续，他去愿意，
37:20你们在效务，我们是哪个？对，说这个不是去切大家这样一个机会，是一次就播。各种这个这个时候不行，
39:00因为因为因为因为我联系过，有一个在一个训一个训练，然后然后每次是你好是哼，就是这个是谁的，而是你是得解决一个一个检看，我们去世，
46:10我要讨虑谁呀？说一下是我第一次屁股的味道，拿到上去，这几天我姓还更好，好，自己自卑。
47:19对对对，你这个结婚，而且而且我今天不是一常，他说我已经就就他始阻止我。是嗯那个一点一不允许用心罩，你是不是节点不好？
47:50你把你把后面这个注视点，就是你人生遮顶，然后再重新试看你事情，那就是你几点嗯，分不清楚心心别心。是是见，
50:06还有这个你说嗯为什么真的是行游戏？你可以用 pose，就是就是你它里面可个就是用到你是天的。联系我去，你们下一开始就是备，你可以不用，
52:38下周这是一个。对，这个是靠是很有可能嗯挺便宜一点。就是你打开对对对，这样回事，但是当时那套是不是都是什黑色呀？
53:08没问题，每天拍始给你发，就是很多 log，就是他觉得这样放在你，你就不知道，以后可以还有发，
53:20也还不错，所以亲自刘总干干呢。首先那我也还是说刚刚天气在这呢，可以他给我看，你用这个一段落，这个根本没有用过特别好的，
54:01你不要去就给你在你有操作。对，这是接口，他不用中间一起。对，那个新代码可以用 pyon。
54:24宝宝们好多就是我需要一个点钻，就是有点说我先登今天什么，我给你，我差点说这个男的在冲张。好的，你这人说的，
54:49我喜欢穿这个扇衣放，看这上面有这个能不能接里的这个戏。