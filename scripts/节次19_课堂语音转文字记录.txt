00:00登录记录它是先是黑屏蔽的另一些直销地方，我不知道是电脑的问题，还是这个系统，你又别用我去买，没有我那那没有反应。他说他立脑法院人题什么这个我就没有听，
00:29就对，就去我解锁。就是那个刚才这我记住，还是你以前也没有声音破节的教程，他就是把那个应用商店里的 VIP 通话没权限，然后就改为那直接可以访问这个事。
00:59起天我就我就重装系统，因为当时那个没激活状态，肯经还个盗版的激活有机不会没办法，我就是好再等一下，跟以前最丑的时候，还有一次我记得我要格式化了这个但是没我们那个磁盘工具是嗯嗯喜欢一分散，
01:37不过我删掉我都没动，让我们去找工具，你不错，下次加工的很，这样我原本的只有没有吗？一百个一，
02:04我是知个你想办法去告诉你，你也从老师那还我一百，你买一个好亏啊。天气原因，几个一下，你还行，
02:24是一辈子。两个人仔细说你么回神。五八年以前他以前最便宜的是后面就涨涨不到，正常价格四百。我当时买这十六块，如果这些能买这些视量，
02:57有增长系数的营经验，这才四百五个有思位。现在没有过这方面没意思，他不太多东西，为什么不能确定？有一你型，
03:51我之前对无种说都可以。你大事主要是不是你是一个礼物，空三天是没有什么基本的那有这个没整天就整理啊。姐姐。今天我又黑色的拿去送一下冰箱。嗯嗯，
05:33那个啊今 SSST 开始，今天我们讲的是这个这个均域分布式存储语言这个话题。但我们今天会讲一个逍遥子来点的话题，就是说就是我们想要一个分布系统对吧 consistency 啊，我们之前讲过你有这个 logking 啊，有这样的一个这个这个 logging，
05:50还有这样的一个那个 primary back up，对吧？我们在讲 eventual consistency 和理念来自对介受。那这些东西的话，我们之前讲的这个 consistency，它的这个呃它考虑的故障模型是非常简单的。
06:02我们之前考虑的故障模型最多是考虑什么？就考虑说我要么整个系统全挂了，对吧？我 all n nothing 的时候，我怎么用 logging 来保证 all n thing。但这个时候我们说我们在之前讲这个分布式课的时候，
06:13我们说分布式系统它有一个非常明显的特征，就是它是一个 parture 类的这个分裂的模型。说明它就是我一个系统里面一百台机器或者一百个组件啊，它可能其中只有一台机器挂啊，它甚至可能机器都没有挂啊，它只是网络互相之间没有办法通信啊，
06:27那在这种没有通信的这样的一个情况下啊，我们怎么去继续的保证一致性和这样的一个可用性。所谓的可用性，就是我任何一个请求啊，它都是能在一个非常短的时间内去返回，对吧？
06:39那事实证明啊，这个事情实际上不不不存在的啊。就是说你如果是因为因为为什么？因为你的这个 parture feilia 的情况下啊，它有这样的一个这个这个 network party，就是网络分区。
06:49那有一个地名叫 CAP，告诉我们，就是你个 CP 下啊，你想要同时达到 viticity 和 consensucy 是不存在的那怎么办呢？那我们其实只能退而求其次，就是第一我们要在这个没有 natal party 性的情况下，
07:02要正确的保证 consisteny 和这个这个 availabity。然后第二就是说我们要保证在有馒 tal partity 的情况下，我们得保证正确性啊，保证保证正确性。因为很多啊，因为其实如果你这个系统如果不要求正确性的话，
07:16其实很多东西实验起来都很快啊，都很简单。行，那么我们怎么去呃也进来呢？我们就可以看两个方面。第一个方面就是上上节课，
07:25我们讲了这个 transaction 啊，我们当时 transaction 假设的是，我们这个 transaction 只会在一台机器啊并发的这个执行。但实际的这个生产中对吧？我的这个 transaction 它访问的这个数据可能会分布在很多台这样的机器厂商，它需要在每台机器去执行这样一个 transaction。
07:41那在这种情况下，如果有一台机器挂了，另外几台机器没挂，对不对？那这个时候它其实也会有问题。所以这个时候我们会啊需要一个协议，
07:50叫做这个 TVS conlait OK 啊 to viscal made。实际上是一个非常非常简单是协议，我们不会花太多的时间去去去讲讲它。但是 to to visccmit 会有一个问题，就是它即使是没有 network partition 的，这个情况下，
08:04如果你有机器挂啊，或者是 parsh 分裂了，那么你它仍然会没有这样的一个可能性。所以这个时候我们就需要用这个 realification 啊，跟我们讲这个 iventual conconsuenrereacation 差不多的技术来去实现 availability。但是实现 availability ility，
08:18它这个这个这个你要在既保保证又有 conconse consisttly 又又又要保证这个 liberty。同时你还你还是在一个 party 分裂的情况下，是非常非常困难。所以我们啊啊介啊两种这个更加复杂杂协议。第一第一，一种是 prime back up。
08:34虽然啊大家注意道，虽然这个名字叫 priry back up，但是它比比我们之前讲 eventual consun 呃 vidual fication prime maackup 会更加复杂，因为它带来我们容错。然后第二个的话，就是说我们会介绍一个更加经典的这个协议，
08:46叫 pxel 啊，可能多提中或者以及其实你要保证这个这个真正的这个可用的话，你还要去实现一个叫毛巾拍自拍摄次的嫌议啊，光拍摄子其实是不够的啊。行好，我们先来看一个这个例子。
09:00 ok 假设啊我们的有一个数据库，对吧？它分散在两台机器啊，因为数据量非常非常大，一部分机器放在 server 零，一部分机器放在 server 一。
09:11这个时候如果我想做一个 transaction，比如说我这边做了一个这个发工资，这个 transaction 啊，它在每台机器上去执行一个子 transaction 这个子 traction，或者是执执行一堆子子子子 transaction。他干的事情呢，
09:23就是把每台机器的这个账号啊的这个这个工资啊前头假了。好，那我们说这个一个很自然的公布执执行模，就是我上面有一个对吧？ cent 他发了两个 RPCC，第一个 RPC 是让 ve 零去更新他的这个 account。
09:38第二个 RPC 发给一啊，让 serserver 一去做这个事情。但是有个问题是，比如说 server 啊，这个事情情做完了之后，但 service 一它做到一半挂了啊，
09:47挂了啊，这个时候呢我们如果用只用 all nessing，每台机器用 logging 去保证这个 all neurauomaity ity，就可会出现现 ver 零做完了了，对吧？ server 一啊，
09:57他又没有 commit will go，所以它没做完。那么这个时候大家想对于这整个操作来说，它其实不不正确。为什么？因为他的这个账户其实被一部分的去改，
10:07另一部分没有改，对不对？所以我们希望的是什么呢？就是说当我一个操作，它涉及到多台机器的时候，他们也应该是一个 honnssing 原子的。
10:16在这个 case 下，我们叫做这个 moltain site 这样的一个 transtion。就是我我的这个操作会分成多个多个 set 啊，这种就是这样多个多个这这样的机器，然后而且我要实现么？我要实现的。
10:28就是说你你即使是有飞碟的这个情况下，我也要要保证帮到小特别斯林。那这个事情怎么保证呢？其实你们就发现一个事情，就是说在我们的一个操作涉及到多台机器的时候，我一台机器本身对吧？
10:42它是没有办法独自决定能否 commit。因为比如说 c 为零，它就决定它自己 commit。那一旦 server 出现没有 commit，那如不是操作我们就就就错了嘛。所以呢正常来说我们这样一个操作啊，
10:54它会有一个我们叫做一般来说叫做一个 high level 的这个 transaction 啊去做这样一个协调。那这个协调呢一般跑在一个叫协调者 coordinator 上，他负责去跟其他的这个这个 set 交互，然后呢由这个人去决定啊到底是否提交还是不提交。因为因为其他人其实他或者或者我们也可以 desenaction tion，对吧？
11:15就是让每个人自己去啊提交这个这个这个事。大家是通过协调，比如说我做一次广播，但这样的话通讯量其实就会大很多。所以这套情况下，我通通常一个比较简单的实实现，
11:25就是我一个 high levetransaction 去决定提交啊，然后呢这个 high level transaction 会负责把每个机器上的这个操作下发。比如说他就是告诉你 s 五零你要做一个这个 deposit，然后 server 一呢你要做个 deposit，然后每个 server 它做完了这个东西呢 OK 行，他们不能提交，
11:43他们得把这个结果啊返回给这个 high level transaction，然后这个 high level traction 去决定最终的提交。那么他怎么决定提交能够实现我们之前所提到的就是 all nothing 的这样一个特性呢？其实很简单，是吧，就是我收到了所有的这个楼底下的这个 traction，
12:01告诉我他们都能提交的嘛。那这个时候我再去下发一个这个提交的这个消息，给每台机下发一个提交，让他们去真实的这样的一个提交。那这个事情不就搞定了嘛，那所以说就那为那所以这套协议非常非常简单，
12:15它就叫什么？叫 two face comment。那其实第一阶段什么就是说哎我先去协调一下，看看底下的人啊都没有，有没有做完好。有做完了之后，
12:25我就用第二个阶段去提交第二件提交 OK，然后提交的过程就是我通过发起发起网络消息，对吧？就是我这个框 datter 先给每个人框框框发发传家去做完之后，好，我这个快就要提交了。
12:41我就去发一个 prepare 啊，问一下你有没有你有没有做完，你有做完啊？如果所有人都做完了 OK，那我就是给这个这个这个这个这个这个所有人发一个 comment，然后提交，
12:51对吧？那这个其实就是非常非常简单的一个这个 tubst comment 的这样的一个协议啊。好，那么这个协议有什么问题呢？这个协议其实啊没什么问题，他我只只是说需要一些 fix 啊，
13:02一些 fix，为什么需要一些 fix 啊？因为我们说在这条协议上，如果什么故障都没有的话，都正常跑下来。那么显然我这个是哦，
13:11 nothing 的。但是如果我们在这个执行协议执行到一半，有一个消息丢了。比如说 prepare 这个消息丢了，我们说你在分布式下丢消息是很常见的，或者我这个我这个完了，
13:22对吧？我告诉你，我已经能提交了，然后我这台机器挂了，这个时候怎么办？这个时候候我能不能去很丝滑的这样的一个处理呢？
13:31那这时候我们怎么去处理各种这样的一个这个情况呢？那么其实其实分析的方法很简单，就是第一我们要明确我们的目标什么。比如说我们在这个里面我们的目标就是我们要 honnsy moty set 的这个 ownsy，就所有的 set 要么都提交，要么都不提交啊。
13:46第二个呢，就是说我这个东西要尽可能的 progress，对吧？就是说我不能等在那边，等我得尽可能的就是说能够把我这个操作做完。因为你这个看了很久时，
13:55没有 feedback 啊，都都都都也不也不是很好。那么我们怎么去实现这样一个功能呢？其实啊我我我看分布式用的表格的方法还是一个就是分类讨论。就是我们把这个协议过程中啊，它出现的这个每一个 case 啊，
14:10每一个可能出错的 case 都分析一下。然后如果这个 case 现出出现这个错啊，我们去看一下怎么去处理。如果这个处理方法能够保证哦这个 or nothing 啊，那就没问题。如果他不能保证啊，
14:22那那我们就得想一些 fix 啊，其实就是这样的一个一套思路。那么这样的话，我们其实就可以来看这个整个协议的过程中，那会出现什么问题？那第一个我们因为这个协议本身是分两部分嘛，
14:33一个 to face，一个 prepare 一个 comitter，那我们就可以先看看，对吧？你这个啊 prepare case 对吧？到底啊出错会怎么样？
14:40那么说你 prepare case 出错的情况无非就是几种。一种是说我这个 prepare 的这个消息啊，没有发到这样的一个 server，要么就是什么，就是我这个 server 去挂了啊，去挂了。
14:52好，那么比如说第一个，我们看一下，假设啊我这个黄金 ator，对吧？我把这个 prepare 消息就问你这个有没有能不能提交啊，
15:00这个事儿能不能做完好，这个时候我这个消息挂了。那么大家想想，在这种情况下啊，我们的这个系统的这个 or nothing 有没有被违反，有没有被违反？
15:11我们其实很很容易发现，你在 prepare 阶段，如果出任何故障，你的这个 all nancy 其实都不会被违法。为什么？因为你的这个 commit，
15:19你你所谓违反就说明有人 commit 了，对不对？那他怎么 commit 呢？它一定得在 commit face 才能 commit，对吧？我们说机 face commit 有这样一个协议。
15:28所以在 prepare 阶段，我们出任何的这个故障，其实都是没有这样的一个没有什么很大的影响。比如说我们这个消息没了啊，我直接去做个捋出来就行了。当然我这个也可以 abbot，
15:40对吧？这个其实是不响。那一般来说我们会去做一些这个 retry 啊，让他去去尽可能的去把这个啊 transaction 这个提交 OK。那那这个这个回来的消息没收到啊，基本质上也是一样 OK。
15:55但是有一个比较 tricky 的 case 是什么呢？比较相对来说 tricky 点 case 是说假设啊我们这个机器发了一个这个 prepare 的这个请求，然后我这个 serserver 啊，它这个这个这个回复了啊，回复了。但是呢，
16:11这个回复的回复前啊，他这个挂就是说他认为他可能去去去去给了这样一个 server 一个回复。但这个时候这台机器挂，这时候大家想想看，会有一个比较 tricky 的 case，就是说我这个这个这个这个 server 对吧？
16:25它是一个它是一个 prepare 过了的这样的一个状态，然后其他的 server 也都是 prepare 过程了。那这时候，但是但是这个 prepare 的消息其实没有没有被发回到这样的一个这个 coordator。所以这个 coordator 呢，他会认为他这个 transaction 啊应应该是 about about。
16:43但是我们说这个这个 server 啊，他很有可能会出现那种情况，就是他知道他自己 prepare 过了。比如他重启的时候，然后呢，他又看到自己的这个 log 是恢复了。
16:52然后呢，他也没有收到这个的这样的一个 corordatabout 的这个消息，对吧？那么这个时候就会有一个这个这个问题，就是我这个 worker 本身他能不能自己去决定是否 commit 呢？那么在我们这样的一个 case 大代下，
17:09如果他自己去决定 commit，因为他 prepare 过了，然后他这个这个这个 log 也是全的对吧？那么他就想要去提交这个事情，可不可能呃做做正不正确，他其实不正确，
17:19为什么？因为 coordinator 这个这个已经决定啊，我要去 about。但是这个这个这个这个整个 server 啊，他去如果要自己决定的话啊， commit 实际上是有这样的一个问题，
17:30就是先先经典问题，就是我要做一个全局统一的操作。但是呢有两个人如果做做决定的话，那这个事情其实就就会出现这样一一个问题。所以在这个 commcorcommit 里面啊，它这个恢复啊有一个原则啊，
17:45有一个原则，就是说我所有的这个 commit 和 board 决定啊啊都根根据这个 coordinner 来啊，就我每一个 worker 它是不能够擅自决定啊，怎么去 commit 的。好，那么怎么去怎么根据 acordinary 里面啊啊怎么根据 coordinary 来呢？
18:01第一就 coornator 啊，他要把他自己的这个所有的这个决定都给 log 下来啊，他也是一个 log，用 honnesing rerelop 去记一下他的决定。然后呢，每一个 worker 啊，
18:12他到底决定要明台，没有 comcomatter。他如果没有收到 coornator 消息的话啊，他应该就要去主动的去这样的一个去问啊这样的一个这个这个这个这个这个这个 coornator 这样的信息。比如说在我们前面这个 case，对吧？
18:27如果我虽然 prepare 过了，然后但是呢我挂了。然后重启之后啊，我到底要不要恢复，他是不能自己决定的，他得什么去问一下这个 coordator。
18:36而这个 corddor 呢，他在决定 a boss 的时候，他得把这个这个这个这个 log 给记一下，说这是个 boss 决定。那这样的话我这个 server 对吧？它重启之后，
18:46去问一下，就能够问到这样一个决定。然后这个事情它就就不容就肯定不会出错嘛。因为我所有的都只有一个决定，对吧？就是在呃 coordinator 么对于这样的一个协议来说的话，
18:59那么在 QVC 呃我们跟之前比它的一个最大的 fix，就是第一这个 quordator 需要去 log 它的这样的一个这个记录 OK。第二个就是说我每个人的这个这个是否 commitit 要根根据这样的一个这个这个这个这个 coranda 来。那么这样的话，它其实也会让我们的这个系统的 commit te 变 point 变成稍微改一下。大家想什么叫 commit point？
19:19就是说我过了这个执行节点，对吧？就是我能确定这个操作一定是一个提交状态。那么在 q 跟 committe 里面，它的这个 commit point 一定是什么？就是 quordator，
19:28它不仅做完决定，还要把这个决定给 log 下马一下。当然还有一种特殊的情况，就是如果这个 connetor 它没有 log 怎么办呢？那这个时候我们其实可以默认都都属于 abort，对吧？
19:38其实就可以了，这样的话也不会有任何的错。就是说我们一定要确定 log 了 commit 之后，我们再去让响应 commit ter。那如果没有 log，那么默认其实 abort 都可以 OK。
19:48那这样的话其实我们就可以再重新看一下。在各种 case 的这种情况下，其实我们会发现它其实都是不会出错的。比如说我这个 coordta，对吧？它已经记录下来了这个 log 信息，
20:00然后他去把 commit 消是丢，怎办办办？没关系，我这个 server 对吧？他如果长他 prepare 过了，但我长时间没有收到黄间的消息，
20:07他可以往这个环间去问。那这个环间再看一下他的 log 说哦，你这个确实是旁面 ent 了。那么我去重新这个 resign 下啊，其实就可以了。那包括这个消息没有回到写写，
20:18要包括这个 server 挂了，对吧？挂了也没关系，我只要重启什么，再去问一下这个 coordinator 这个这个这个数据状态，那这一定是不会出错的，
20:28不会出错的。当然这个那么这边其实就会有一个问题，那么我们前面讨论几个错对吧？都是都是在这个 server 的这个角度来来看的。就是我这个 server 啊，如果它挂了啊，
20:40该怎么处理？但是会有一种特殊的这种 case 啊，就比如说我的这个 coordinator 挂了怎么办呢？这个时候在这就是 QV et tomatit，我们说它会有一个很大的这个缺陷，就是我们所有的这个决定都是 coordinator 去去去处理。
20:55但是一旦 coordinor 挂了怎么办？我就得等这个 coordinator 重启啊，一定得等他重启。不管你是什么样的 case，即使是我这个这个这个这个 quorneator 已已经决定 bit 了。然后我这个思路他没有收到恐怖的消息，
21:09他也不能自己 combte 他的什码，一定得等到这个 corneator 去发一个这个这个这个这个消息才行。所以说它其实是非常这个这个受制于这样的一个 corneator 这样一个 avaliabted 啊啊所以说这个这个是我们这个后面啊后面一部分课程的内容需要解决 OK 行。那么有了这样的一套这个这个 tupace scpate 这样的一个机制之后呢，我们就实现了一个东西。就是说我们的这个 transaction 啊，
21:34它能够在多机上，而且这个多机上它一定是能同样去将样的都不提要的。那么除了这样的一个支持多机这个能力以外呢，我们在支持多机的时候，还需要对这个之前的一些协议做一些 fix。什么意思呢？
21:47大家想我们之前讲啊 transaction 我们讲的一个协议是这个 t phace knocking 对吧？和这个 OCT。好，我们在 tupace stocking 里讲的是什么呢？就是说我这个 transaction 对吧？访问一个数据，
21:58比如在我台机器访问一下数据，我就去拿他的锁，然后呢，我不能放锁啊，我或者说我能放锁到什么时候呢？就就就是到直到我这个 transaction 去确保啊不去拿新的锁的时候，
22:08我就可以直直放锁锁。但是在 two face commit 的这个协议里面啊，我们不能够去提前放锁我们的锁。一定要在这个到这这 server ver 这个信息息才能够才能够那个叫什么放大一下。为什么？因为一旦你放了锁意味着什么？
22:24意味着说你这个 commcommtransaction 它修改这个中间的这个数据，它有可能会被其他产家性看到，对不对？那这个时候如果我们的这个 call nator，他选择了 bot，比如说有一台机器的挂，
22:35那你这个不就是把一个 partial 的这个这个结果给做人看了吗？所以在这个当我们把这个 TV scribit 用的 OCC 的时候啊，用到这个 TVITTVS scribor or 啊时候啊，它的这个放锁是需要 delay 的。一定得 delte 到这样的一个这个这个这个这个这个这个这个这个这个确保后 mate 口呃，能提交，
22:55或者他确保 about about 啊 about it，对吧？因为 a ort 我们得把数据回滚，对吧？但是一旦你你这个确定你要提交了啊，这个这个这个是才能去放松啊，
23:03有个这个 delay，当然对 OCC 其实也是一样的。因为大家像 OCC 本质上什么，无非就是我我我在这个 validc 的这个阶段也得去打个锁的嘛。那么在 two v sccopit 里面，其实无非就是说我去给每个 set，
23:15先把每个 site 的这样的锁全都拿了。然后呢，我去一下它能不能提交。如果这些功能提交的话，那我也是能提交过它 abort 的话，我们就直接就啊 pot 这样就行了。
23:26当然这个这个这个 two face commmit，它其实给我们之前的一些方法，还还带了了那些比较多的这个这个需要 fix。比如说我们直接讲 check point，就是说 check point 说我们需要定期的把每台机器的这个 log 给删掉啊给删掉，对吧？
23:39我们当时的方法，一台机器的方法什么？就是说我把那些这个 page 碳水的这个东西全刷掉啊，我们就可以认为提交的 transaction 的数据都 persist。但是在这个 two phase commit 里面啊，你不能够简单的这样的一个一个为为么么为为你的这个 traction log 可能是一个 parture 类的这个 committee 状态。
23:55它它其实不一定是需要这个 review 的那在这种情况下的话，那我们还是得把这个 log 给保留下来，知道什么？直到 call nator 告诉你啊，这个人 commit，那我才能去把这个 log g check point 掉啊，
24:09然后对这个其实是一个这个这个是一个比较大的这样的一个需要需要考虑的这样的一个事。当然这也是为什么就是说在 tuv s commcommment 里面啊，一般来说这个这个这个这个如果你是有 ND log 其实还好。那如果你是一个 review only log 的话，你其实在这个这个这个这个这个这个 TVS commment 里面，你不能够直接在这个 transaction 这个这个每个子 transaction，
24:32它这个这个这个这个这个每个子 transaction 它自己去写。因为什么？因为你一旦去 reredue 了的话，你其是没有办办法做一些 DE 的啊，所以啊在 TVS commment 里面，一般你要么是 n dulog，
24:43要么是原来就是你。在这个 commit 这个阶段啊，你在 commit 阶段去去写，就是确定完 commit 之后啊再去写啊，这这样的一个思路是对。好好，
24:55那么我们总总结一下啊，总结一下，就是说这个这个这个这个作为 formit 是一个这个当我一个这个 transaction 的吧，甚至在这个多个机器的这样的一个时候啊，我们一定是需要这样一套机制去保证这个所有的在每个一个操作，它归属于每个机器的部分，
25:12要么全做完，让我们要做完。那么它的核心思想就是说我有一个 coronitor 去做这个最终的这个决定。然后这个决定是要 log 的。然后它第一个做决定的过程叫做 prepare，然后后面个阶阶段叫 mte。
25:24然后这样的一个方法的话，在 partial 飞裂情况下，我们可以看到我们是能够保证正确性的。为什么？因为我们的这个这个正对性的原是什么？就是根据 corantor 的这个 log 来，
25:35但是我们这套方法其实有有一个很大的问题，就是它没有这个这个这个没有 availability。什么意思呢？就是说当我的 cornect 挂，或者说是我其中的一个 set 的这个挂。那大家想想我我用用的角角度说吧，
25:50如如如果这个东西是 commit 的时候，对吧？如果我是这个 commit 的的时候，这个这个这个这个这个这个这个这个我有一条啊路啊，不是不是，就是如果我其他机器挂了，
26:02然后呢，我这个时候恰好这个有一条这个 commit 的这个记录啊，这个时候我还能给用户 feedback，就就 corneator 啥了。但是大家想想，一旦我这个 core nature 挂了，
26:12但或 call nator 挂了。这这个时候我其实对用户来说，它只能什么等到这个 core nator 去恢复啊，它才能够去确保这个这个重启啊，所谓恢复就是重启，才能够确保这个传载器到底是可明 ted 还是不的。
26:26那大家想这个重启一台机器啊，你尤其是重启服务器，它的时间是非常长。重启服务器的时间大概是在啊十几分钟啊，十几分钟都都有可能啊。因为它要做很多的这个字典的这样操作。
26:39那么其实一般来说肯定是会影响这个 convevery beauty。因为我们说 a very tish 嘛，就是说你在这个这个出错，对吧？你在多久能够给用户一个一个正确的这个 feedback，对吧？
26:49一般来说你用人的响应时间是在秒以内的，所以我们一般定义啊 very beautish。什么是说我们一秒内就能够把这个错误给恢复过来。那么依靠依靠重启是是不能够不能够加密的恢复的 OK。好，那么就接下来就要到我们的这个这个下一个话题，
27:08就是我们怎么要保证，对吧？就是我我既然一台机器重启是不可靠的那我怎么既能够保证正确性，又能够保证这样的一个这个这个啊这个这个可用性呢？合起来。那我们其实再回顾一下，
27:21对我们所谓的正确性啊，就是我们一直在讲这个所谓的 indidiatsibility，对吧？ or nothing 和这个比如说 after，包括今天讲的 model side，那所谓的 availsibility 就是我们每个请求发到这个服务啊，
27:33这个系统服务一定要在一个给定的非常短的一般信秒内的这个时间内去返回。那么 CP 讲的一个很很重要的这个这个事，这个事情就是说你想要同时达到 valiabity consiancy 在这个呃在 network qualiity 的情况下是没有办法同时达到的啊，这个实际上是一个严格的这个定义。但是呢其实我们这节课还会看到啊，即使是我们不考虑 a valiability，
27:57再有 network qualitive 情况下要要要保证 neneconsensty 啊，其实也没有那么的这样的一个容易。好吧？行，我们接下来就看一个这个来具体的看法啊，怎么做这个事呢？
28:08其实我们可以看到这个，比如说 stube squted 的这个个目前其实是还比较挫的，什么意思呢？就就只有这个这个这个这个这个这个这个 consistency，那么我们能不能把它变成一这个 CCP 里面的这个 CA 的这样的一个版本呢？如果在没有 net 或跑记性的情况下啊，
28:26其实相对来说是可以的那怎么做呢？其实我们说所有的这个容错方法啊，它背后的原理其实就都一条都是一条。什么呢？就是你要做冗余就什么意思啊？我一个 coronator 会挂对吧？
28:39那我就多用几台机器做这这个这个 colonnet。然后然后我其实我每个 set 也是样样每个 set 一挂，那我把这个数据 rapid 给几分。然后呢，这个时候我讲什么有一个 rapid 卡，它这个他这个活着啊就行了啊，
28:55就活起了。那这个其实是这个用了这个基本的技术叫做这个 replication。当然 replication 其实我们也应该大家应该不陌生，对吧？因为我们之前讲这个手机的这个微信的聊天实现，对吧？
29:08它本质上也是一个这个这个 replication。好，那么其实理论上说大家像我们 rereication 实际际上是能够一个很方便的实实容错错什吧。我那我只要有一个 rapid ica 数据是好的，那么我们就从那个好的 rapid ica 读数据不就行了吗？对吧？
29:25那这个会有什么问题呢？它的问题其实在于它满足了 availility，但是它会有什么？会有这个问题，大家在正好回想一下，对吧？
29:33我们这边讲这个这个这个 consisteninntial consistces 加 leadless s 手，什么意思呢？大家想想假设啊我们现在为了保证可靠性啊，我们把这个 lacoornature 的这个这个或者说每个 siit 的这个这个数据啊给备份两份。比如说 s 二啊，我们就是一个五 s 一的这个 coornator 这个关系的备份。
29:53然后呢，我就 print 啊，我要去发一个 transaction 啊，然后我比如这个 transaction 是 right DEX 后这个市场我有另外一个 point int，然后它也要做一个 transaction，是 right right 二 x 那大家想想，
30:05我们当时在讲这个聊天记录的时候会出现什么问题啊？就是我一个 server，一般说它得怎么去执行执行消息啊，它一般来说我收到一个请求，对吧？它最最理想，
30:13就是我收到请不就直接做。但是呢因为我们说这个这个你不同的 point 发给不同的 server 的这个消息的这个顺序是可能会不同。比如说我这个 s 一对吧，他先收到了 count 一的这个消息。比如说他离看 t 表近，然后他先收到 right，
30:28一再收到 right 二。然后呢，这个这个 s 二啊，他收到了这样的一个这个这个他离 SCR 表近，他收到了先收到了， right。
30:37不对啊，这个啊，他可能会先收到这个 right right 二啊，再收到这个 right 一对吧。那理论上来说我们希望什么？我们希望的是他每台 server，
30:45它收到的这个消息的顺序是一样的。但是你如果是一个简单的这个 replication 的话，他可能收到的这个消息是不一样的。不一样。那我们怎么保证？就是说我们在有 repldly 这个情况下，
30:58顺顺序时间，你顺序不一样的话，意味着吧？你这两个 replt 它的数据最终都是都是错的啊，或者说就不一样。那我这个用户数据不就是错了吗？
31:07错了吗？那么我们之前其实介绍过两种方法来保证这个 rapiid ca 的操作顺序一样的。第一种我们就要做是一种比较乐观的方法。在这个讲 eventure concern 里讲过，那我们说 eventure concern 是吧？他默认就是我每台 server，
31:24他收到的这个消息的顺序可能就是不一样。但没关系，他就直接做。然后呢，他在某一个时间点，比如说某一个同步时间点，
31:31他把所有的 server 都同步之后啊，我们做了一个全局的这个排序。然后呢，我再说啊，我再让你去去去去去做这样的一个这这这个这个把这个顺序变成一样。我们说这是 eventual conservancy。
31:44然后呢，我们还介绍过一种方法叫做 linusibility 啊，也不是有个方法，就是说它的性质叫 inestability。然后我们实现 linlisibility 是说我们所有的这样的一个请求，对吧？
31:54都发给一个 server。然后这个 server 决定完顺序之后呢，把这个这个这个顺序啊给发到这个其他的这个 lip l 其他 liability。根据这一台，我们叫做 prime ate 这个 server 的顺序去做。那我们介绍过两种保证这个这个顺序一样的啊，
32:10那么大家可以思考一下，在我们这样一个场景，比如 to face commmage 里面啊，我们做一个 transaction，我们要做一个强 consistently 的情况下，我们应该选取哪一种这样的一个这个这个这个去排序的保保序的这样一个方法来。
32:25那我们大家其实可以选很明显想到对吧？我们应该是要做一个这个这个强强的这个顺序，对吧？为什么？因为如果我选择 eventually consistcy 不个去，因为那如果大家想想，
32:38我们如果这 corneor 对吧？他用的是一个 eventually consistency model，那么会不会有一种情况？就是你有一个 corneator 对吧？他先下发了做了一个 t 一的这个传载 tion。然后这个时候呢哎他他他看到的是什么？
32:52 t 一的这个传载 tion，先做 OK。然后这个时候我们如果做一次同步，同步之后呢，你这个 t 一的 transtion 就变成后做的了。大家想这个事情这个事情其实其实整个都乱套，
33:02对吧？大家想如果有两个 corneator 啊，我们可以去只要收到这个用户的这个传载值啊，我就直直接去啊直接去做啊，直接去做这个操作。这其实实实是完成软套。
33:12所以为了这类器的话，我们是希望什么？我们希望是做一个这个啊 ENS beauility，所以我们就需要什么？我们就需要这个这个 private backcup 的这样的一个方法。所以我们今天啊会着重的去介绍一下这个这个我们今天的这个 privy back cup。
33:26这个 privy back cup 是基于之前的这样的一个这个这个我们讲呃插点 APP 时候的这个 privy back ackp 这个方法。但是会有个扩展，就是我们会把它扩展到一个能保证 a valability 讲一个长期动动汽和什么区别的。 ok 好，那么在具体介绍我们的这样的一个这个这个新的 primary back 法方法之前，我们得介绍一个概念，
33:48叫做 replicated story machine 啊，什么意思呢？就我们之前的这个 primary back tuup 方法，它其实面向的是一个比如说 chat 这个吧这个聊天的这个应用啊来做的。但实际上你这个 primary backup 这个方法，你其实对于任意的这个分布式系统，
34:02它其实都是适用的，都是适用的。那么问题来了，你不同的分布式系统，不同的分布式应用，它们的这个这个这个 application logic 都是非常的这个这个这个变化非常多的 OK。
34:13那我们怎么有一套通用的这个系统方法，能够你任意的这样一个分布式。有，比如你是 qudidation 也好，你是这样的一个这个赛。就每个 set 做传单性也好，
34:23我都能够让你变得这个这个这个这个这个这个这个能用一套方法学来实现 consistency 和这个这个这个呢那么人们会发现啊，就我们所有的不不管你的这个应用是什么，它都能抽象成一个什么呢？叫做状态机模式啊。这个其实南大有个老师，有有有有老师，
34:42叫这这贾贾 vivica 老师吧。它其实假结有一些非常有没是说 everything is a state 模型。对吧其实大家想想，我们现在用的这个电脑，它本质上就是个 statement，它并不是并不能完全意义上来说是个图灵机。
34:53为什么？因为它的这个内存不是无穷大的对吧？你既然内存不是无穷大，你的这个 state 一定是有限的。好，有了 state 之后呢，
35:00我们其实会发现你任何程序它都能看成什么。就是我一开机器，它有一个一个程序，它有一个当前的这个状态。然后呢，我这个给定你一个操作，
35:09这个操作其实就是我的程序的这个执行 instruction，包括你比如说你是 quantor，就我 corneit 要做这个 decesion，对吧？如果你是这个这个这个 QS store chat BP，它的操作就是什么？
35:19就是你这个收发消息，然后呢都可以看成什么？我收我一个状态机啊，我收到一个这个这个消息，然后把它转换成下一个这样一个状态。 OK。
35:28那这个时候大家想想，我们要保证什么？我们保证的是，假设我这个这个程序它要容错，我们可以把它备份很多份。那我们的一致性问题就变成什么？
35:37就变成我们这些程序，对吧？它的状态是不是我用户在这个最终给用户暴露的一定是个最终的的致的一样的这样一个状态。而且这个状态它不可能会出现说有一个时间点，它的这个状态和其他人不一样啊不一样。那怎么做这件事呢？
35:52其实我们会发现，只要我们保证什么，就是我们的这个这个用户的这个所有的操作，我们把它把它记在一个 log 里，把它一个 log 里。然后我们保证每每台机器，
36:02它会按照同样的这个顺序去执行这个这个 log。那么大家想想这个时候我们这个操作对吧？每台机器它的这个这个做的这个操作的 log 是一样的。那么最终什么？它假如他们的初始状态是一样，然后你每个操作是一个确定性的。
36:17所谓确定性，就是说我我这个操作它一定是呃给定你一个 prestate，然后给你一个操作，它一定会转转成一个同样的 post st。而不是说你比如说你有些随机数，对吧？
36:28它可能会这样这样去选择，一般来说不会出这种事。那如果这种情况下啊，那么大家想想看，我们去保证这个 problem variability 和 consume，就会变成我们怎么保证这个 log 的这个一一模一样的这样的一个问题，
36:43对吧？那这样的话，我们最后我们其实讨论这个技术方案就很简单了。什么意思呢？我们就要只要去看，我们怎么把这个 log 保持一样就行。
36:51然后有了这样一个抽象之后，其实你剩及一个 application 转换成你的这个这个在用 crime back。它无非就是把你的这个应用的这个操作转变成你这个 log 里的操作 OK。那所以这个是一个实际上是个非常经典的这个抽价叫 ISM。所以我们会啊，第一个，
37:07我们先把这个 primary primary back ackup 对吧？根据我们这个这个 im m 啊稍微扩展一下，稍微扩展一下。好，那么有了这个 ISM 之后，大家想想我们怎么去保证我每台 raplid 卡它收到的这个 log 一样呢？
37:21那它其实方法就跟我们之前的这个 primary backup 是一样。随便呢就是我所有的 current ct 这些请求，就比如说他要做的这些操操作一和二我都发给这个 primary。然后 primary 收到这个消息之后，他会把它加到自己当前的这个 log 里。然后呢，
37:40他把自自这个当前这个呃呃加完 log 之后，他把这个 log 的最后一项被 forward 到所有的 backup。然后所有的 backtub 都都告诉你了啊，你这个 log 一定你这个操作一定是在第几个位置。我们当时讲过有个 sequence number，对不对？
37:53然后这个时候啊，我的所有的人都给 ACK 了。那这个时候我的 primary 就告诉这个这个这个 prime 对吧？你的这个操作已经被 replicate 到了多个这样的一个机器上。 OK。那这样啊这样的话，
38:06其实我们就会发现你任意的这样的一个，不管你是存储应用也好，或者计算应用也好，其实都可以用这种类似于 pran back of 法来保证证个 radicitate possisicy。好，但是啊我们说前面这套这套方法对吧？
38:21这套方法，它的一个这个这个好处是什么？它的好处是啊能很明确的保证 consistence。但它的问题是什么？问题什么？如果我们有机器挂了，
38:31怎么比如说我的 primary 挂了，但是想然挂了，这个时候我能不能能不能就是系证啊？包括我如果一个 priback up，如果一个 back up 挂了，这个时候我整套这个系统还能不能 work？
38:44按照我们之前的协议，它是没有办法 work，对不对？那我们怎么怎么能帮，怎么能让他 work 呢？那那那其实大家想这个事情看上去挺简单的吧，
38:52就是比如说你有一个 private 挂了，那我是不是是不是这个这个这个这个去把另一台机器变成呃另一个 back up，对吧？这样我也有数据，那我就把它给变成 private，是不是是不是就行了？
39:06那这边其实会有有有一些问题。第一个啊有有有有有一些问题，就是第一个问题是我们到底是怎么去做这个切换的这个过程，对吧？想想我们如果要做这个切换，哪一种简单的方式是什么？
39:20我就人为的啊我手动去把你的这个某个 backup 提升成 primate OK。那大家这个方法的话，它的好处什么它是比较简单，对吧？我就是人为去拼一下，你这所有的 back up 到底哪哪还活着，
39:34然后我就就去挑一台 back ackup 变 primit。这个这个这个看上去比较较简单美。那但是它的问题是什么？它能不能达到 avalidating，它其实没有办法达到 avalidating。为什么为什么因为你这个这个人的操这个操作 on 括的时间，
39:48基本上什么分钟到这个小时级别的，对不对？你这个我们要做的实际上是你只要在一秒内去恢复，我们人其实没有那么快的这样的一个响应时间。那怎么做呢？那么其实现在的方法，
40:00它其实一般来说是会用，其实有点像这个现在讲的这个 agent，对吧？就是我我搞个程序去定期的去检查你的机器到底活没活。然后我这个发现你你有机器了，然后我就自动的去把这样的一个这个这个这个白变成 ackprimit。
40:17这个问题能不能解决呢？这个问题会有一个有个这个问题，看上去是能解决了，看上去就解决。但是我们说如果你是程序的话，那它就一定会遇到这个计算系统里面遇到的问题。
40:27那么大家想想，我们在我们这个场景下遇到了一个很大的问题。什么？就是你这个 agent 对吧？你就 conneit 啊，你去做这个这个这个自动恢复的这个东西，
40:36它是不是也可能会挂，对吧？它是不是也可能会挂，那我这个自动的这个 agent 一旦挂了。好，那你这个你这个系统不是仍然是这个这个这个这个不可用的状状态了。
40:47那这个怎么办？我们得部署多个这个 agent，对不对？部署多个这个 agent 去做这个块。但是会不会多个 quanneta ent 的，大家想它之后不就会又变成一次一次嵌套逻辑？
40:58因为你多个 agent 他可能会做出不同的决定，对吧？比如说我如果把两个人两个 beta 同时都变成了 primary，这个时候大家想想，我们就 primary up 协议不就就全乱套嘛。我们 primary up p 决对能 work 的前提是吧？
41:13就我只有一个，但是我这个不就全套了嘛。所以这个时候我们就还是需要有一些机制去保证是吧？就是说哎我有这个多个恐位内症，懂了多 cornator 啊，它也它也能够保证正确。
41:26这其实就是说我在恢复的时候啊，这个比较 tricy 的这样地方。我问一看具体例子啊，当然其实还有目前 IP 三的方法可以提前去透一啊，就是说啊其实这个我们这个这个在分布世界，对吧？
41:39是有一些很神奇的算法，比如说 pts of rouft 啊，它是能够保证就是说我没有 quornator 啊，它也能去通过协商去协商出一个这个 prime ate 啊，这我们也会看到，但是它会更加复杂一点。
41:51好，我们先来看先看先看一个这个简单的 case，就是我们用一个类似于 corlator 这样的一个自动化程序啊，来去判断来去动态的去切啊这个 primary 塔。比如说比如说我们假设这个场景啊，一开始这个场景是我们有两台 server 啊，
42:09 SSR 它们互为备份。然后为了保证真实性，我们用的是这个 primary back up 的这样的一个 model 啊，就是我这个 s 一啊，先作为 primary SR 是它的这个备份。然后呢，
42:19我有个 quandator 啊去定期的，比如通过 habit 啊就心跳。我们去看这个拿台 server 是活着的 OK。然后我这个 point 通过这个 quore， dator 会去知道当前谁是这个最新的这个 prime。好，
42:33这时候如果这个 primary 挂怎么办？ prime 挂的这个时候的话，那么我们的这个这个这个这个 quornitor 啊，它就会去 detect 发现这样一个事情。发现之后呢，他就会发一个任命通知啊，
42:46说你这个 s 二要变成新的这个 prime OK 这样这是就是我们说用一个这个 agent 对吧？来来去自动化这样一个容错运维的这样的一个过程。好，这套方法有一个什么问题？有个核心问题是我如果这个 quornitor 挂了怎么办？这个时候我们需要用什么？
43:05就需要用多个这个 quandata 去去做这个判断。对，都有 quanneor 做判判断。那家有有没有过过一件事情，就是如果用多多个 corneator 会判断会不会出现一种情况，就是我两个 quanneata 它做的这个决定是不一样的呢？
43:19就是比如说我这个 quaneor c 一对吧，认为我这个 s 一是这样的一个这个 primarate。但是 quanneor 二它会不会做一个相反的这个决定，它认为 s 二才容是新的才应该 pripriate ate。这个事情其实很容易出现怎么出现？就是比如说我出现一个分区，
43:35大家都合个下，我们说网络分区是什么？就是说我以这个所有的机器被分成两个 group，然后 group 之间的这个机器呢互相通信啊，另两个 group 内可以互相通信，但是 group 间无法通行。
43:46那在我们这个 case 里面，就是 c 一和它的 client 能跟 s 一通信，但是 c 二和 s 二这个呃这个呃呃但是 c 一却没有办法跟 c 二和 s 二通信。好，大家想这个时候会出现什么情况？那么站在 c 二的角度来说，
44:01站在 c 二的角度来说，它并不通 s 一了，对不对？那么这种他只能认为什么 SC 是挂了。然后为了保证 availability，我们得做一个秒级的这个切换，
44:11秒级的切换。这个时候我就 CR 让 s 二变成了新的这个 primary primary。好，大家想这个时候我们就出现了一个很大的问题，对不对？什么问题啊？
44:21就是你的这个四 consic 就就被 broken 了。为什么？因为你的这个有两个 primary 同时出现，那么我这个 primary 它这个就没有办法在你的这个 log 的这样的一个顺序上产生产生了这样的一一致，产生了一个一致。所以我们怎么解决这样一种问题的，
44:40什么有问题呢？其实方法还是很简单，就是说你一个 primary back up 的这样的一个 server 啊，你要保证正确，你一定得有一个这个中心化的，就是 centrtialize 的这样的一个人啊，
44:53他去决定一个谁是 primary，谁是 back up，就是说不可能不能出现，就是说有两个人同决定。那么这个决定的人我们就叫做这个，一般来说我们就叫做这个 server ver 啊，
45:05 view server， view view server。这个 VU server 本身也有可能会挂啊，这个时候呢我们就需要一些更复杂的 technique。但是啊通常情况下呢，你如果用一个 BU server 的话，
45:15它的这个出错概率啊相对来说会少一点啊少一点。所以说 prime back att 还是会依赖于这样的一个这个这个这个 VO server 啊来做。然后后面会讲怎么这个 v view server 变得这个这个可靠 OK。好，那么有了这样的一个 VO server 之后啊，我们有多个 core nata。
45:31其实是什么？我们其实就可以这个这个比较容易去做判断。比如说我们一开始这个 view server 啊，它记录的是当前的这个这个这个 view 是什么啊？就是啊这个这个这个 s 一是 plany，然后 s 二是 fick up，
45:47它做好了这样的一个这个任命，做好这样的任命。然后这个时候这个时候啊，如果 client 要问这个这个这个到底谁是这个这个这个当前 primary 的话，他会什么？他会去跟这个 view server 啊去做一次查询啊，
46:01拿到了是这样的一个谁是 primary 之后啊，然后再做。然后这个 view server 它作为一个中心化的这个节点啊，它会去和 s 一和 s 二定期的这个 heart beat 啊，去做这样的一个这个这个这个通信啊通信这样一个架构。然后如果有这个这个这个这个机器挂来的话，
46:18那么 view server 会创建一个新的这样的一个利润，创建一个新的这样的利润 OK。好，那么它的基本的流程和我们之前的这个管理层啊非常像非常唯一的区别。就是啊我们只有一个中心化的 review server，什么意思啊？
46:31就是这个 view server 会去负责这个这个这个这个 primary 的这样一个个 cimit。然后如果某一个这个 habit 对吧？它这个这个没了啊，怎么办？这个 view server 它就会让这个这个这个 SR 去就是说好的这样的一个 server。比如说 SR 去当这个新的这个 primary，
46:48然后呢然后来去来 store。好，这个时候啊这个时候有几个细节需要注意啊，我们现在去先看一个具体怎啊，比如说啊我这个这个 primary s 一挂了，对吧？
46:59就是其实本质上体现什么？就是说它这个跟呃 view server 这个 pink 停掉了。这个时候呢我们这个啊这个 view server，它会说我要创建一个新的 bu 二。然后这个这个在新的这个 view 里面，这个 resern 是这样的一个这个新的这个团源，
47:14然后去做。然后这个时候啊，对对 OK 好，这个套这套协议目前为止就是如果这个 s 一啊，它就是挂了啊，就是挂。
47:25这个时候大家想想我们这道协议其实是非常简单的，对不对？那这套协议它的最大的这个难点是什么呢？难点是我们就是我们先说男朋友跑进去，就是说会不会有有种种情，就就是我的这个 view server，
47:38他认为你的这个 s 一挂了，但是实际上 s 一没有挂，它还在继续的做请求怎么办？比如像这这个例子，我们有一个这个难卡件，或者说有个网络连接问题，
47:50对吧？然后 s 一这个时候他还认为他自己还是这个 primary。那这个时候呢，因为 VO server 它和 s 一的这个通信断，所以他认为是什么认为这个 s 二 s 二 SS 二才应该重新是 primary。这个时候大家想想，
48:05如果我们有 quite 能够连接到这个 s 一啊，他还认为比如说他 cash 了一下这个这个这个连接信息啊，他说 s 一还是 primary，然后他继续再把请求发给 s 一。那这个时候我们不是还会出现就刚刚说的这样的一个问题，就是我两个人同时成为 primary，
48:23然后还在做嘛，他其实并没有从根本上去解决这个问题，那怎么办呢？这个事情其实我们可以去 fix 的，大家想想看，我们本质上要做的是什么？
48:33本质上要做的就是当我这个 view server 做了一个新的这样的一个的的候候。比如说他认为 assigsigns 二是新的 prime 的时候，那么我 s 一它的这个操作不能够去完成。那么大家想想 s 二 s 一它的这个操作能完成的这个前提是什么？前提是 s 一。我们说 i'm plan back up，
48:54所以我要做完得什么，我得等到这个 backup 有个 ACK，对不对？那么这个时候其实我们只需要什么？只需要让 s 二这个这个去 reject 掉 s 一的这个操作的这个 ACK。那么是不是这个本质上就有效的避免了 s 一去成为新的这个 public，
49:10对不对？那么 s 二怎么判断这个 s 一这个这个操作是要 reject 还是要执行呢？我们其实就需要有一套机制，就是我们在这个 view 上面得有一个 number。就是说我每一个请求啊，它一定得归属在某一个 primary backup 的 set up 上。
49:29比如说一开始我们的这个 view 啊，它是 ID 是一，然后它的 primary s 一，然后它的 backup 是 s 二。然后当我做了一个切换之后呢，我的这个 s 二的这个 view 就变成二，
49:40还有 privaces are。然后我每一个国外的这个请求，它得什么？他得带上自己的这个 view 号。然后我这个 back up，他要去 ACK 这个 so permit 的这个 view 的时候呢，
49:52他得去判断一下，就是说判断什么呢？就是说你这个笔友是不是比我跟我一样，对吧？如果不一样啊，那就说明什么，
50:00那就说明我这个你我如果比你新的话，那就说明你这个消息其实是不可用的那我就直接什么把你 reject 掉啊。这样一套方法就能够保证在有 netal 环境的情况下，我几个妹同时存在的情况下，我也能够保证这样的一个决醒。行，
50:17我们先学习，爱你你行。是我不意不好是嘘，是是啊，对，是。