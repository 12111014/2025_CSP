01:05是是是，听听是如何轻松唱饮。嗯嗯，嗯你好，我们继续。刚刚我们已经讲了一个 case 啊，
05:59就是当应用程序的 data 和 data 同时存在的时候呢，我们希望它以这样一个顺序写进来，对吧？就是这个这个这个这个这个对的哎，先进来，然后拿下来，
06:14然后没有电它进来再下来，放在这个 journal 啊，放 jeral。这个时候呢，如果断电之后呢，几点没事儿，
06:23为啥没事呢？因为我这个 meta data，它在这个时候在折诺里面，它没有覆盖，原来的原来的没有复联。所以断电之后的话呢，
06:34等价于上没发生。你说 data 会覆盖了吗？这个 data 它可能是 apppad 进去，对他可能就新写了一些东西，他就压根没有没有改。最后呢我有一个 commit，
06:48一旦这个 commit 进去了，那就会变成 ball nothing 里面的哦。因为一旦重启之后啊， data 也在， mtdata 也在，所以我是可以重新做一遍的。
07:00就算没有重启，我依然是要把这个 meta data 重新写到它该在的这个位置。但是我们有一个假设，就是如果这么做呢，它就有一个 data，它需要保证一定的 order。
07:11但是呢实际上它却不一定。因为你 data 下来之后，它其实在磁盘上有一个 cache。我们把磁盘放大之后啊，按磁盘就有个 cache。然后呢，
07:22一旦我们把 data 写进来，它返回了，这个时候数据并没有到磁盘，而是在 cash 里面，怎么才能够从磁盘的开始写入到磁盘的这个真正落盘呢？我们就需要去做一个 flash 操作啊，
07:37做一个 flash 操作。当时有人问说为什么这个操作叫 flash？就是数据啊，什么叫 flash 到磁盘上啊？他说这个 flash 就是就那个抽水马桶那个那那个 flash。所以呢我每次想到这个 flash 啊，
07:54我就会想到这个水的声音啊，这个这个冲下去啊。好，一旦 flash 了之后呢，那么这个 flash 就不会返回。直到这两个东西就真的写到副本上，
08:07这个 flash 才会返，它是一个红。好，然后呢我再 commit 这个 commit 写过来之后，他也要 flash 一下，不让医生呢他就进到真正这个地方，
08:20最后我才把这个梅和利塔写进去。那为什么要这么这么一个过程呢？其实有点简单，就是如果在这个地方不写不加 flasflash 的话，那么后面的这个这个 commit 这个操作到这儿的时候啊，就有可能发生他先下去对吧？
08:39他先写到磁盘，这两个还没起磁盘的情况，为什么？因为这有 cash，为了避免 commit，但是这两个还没有写到磁盘。
08:50我们必须要保证一个顺序，就是这两个 data 和 meta data 必须要在 commit 写到磁盘之前先落到磁盘上。所以呢我们用 flash 做一个分割来保证沟通。那么为什么在这儿还要加一个 flash 呢？为什么在这样 flash 这样子这样这样的 flash，这个 flash 是为了把 commit 这个操作和接下来的这个没法给他写操作的顺序保证。
09:17因为如果不加这个 flash，那么就有可能在这儿有一个 meta 给在写操作。如果这个 meta data 的写操作已经写到这儿了，这个 commit 还没有写到磁盘，就意味着原来的这个贝塔被覆盖掉了。对，
09:34被覆盖了。所以呢我们不能够允许这个事情发生啊，因为被覆盖你就回不去了，对不对？被覆盖了你就回不去了。没有被覆盖你还可以撤回，
09:46但被覆盖就回不去。但是如果你覆盖了这里这里的 mettata，但你还没有 commit。那到底应该是回去还是应该是撤销，还是还是重做呢？由于没有 commit，
09:58所以应该是撤销。但你的 meta data 已经被覆盖了，所以不能撤销。所以呢就出了问题啊，就出了问题，这也是我们说的这个两个 flash 这个座椅。
10:10好，那么怎么才能够在这？我们知道众所周知 flash 是很慢的，对不对？你写磁盘马上给你返回，为什么？
10:19因为他没写，没写到盘上没有落盘。他在磁盘的 memory 在磁盘的 cash 里面写进去后，磁盘就骗你就直接返回啊。他这个这个这个写磁盘本身啊，不能保证 flash，
10:31你一定要主动加这个 flash 才能保证落盘。但 plus 写字盘可定一定很慢，对不对？所以我们就要去想一个办法，减少这个 flluh，就这就是这个当时的一篇论文的公作，
10:44叫 journally without audering。我不加 flash，把这个 flash 操作就这样怎么办？好，一共有四个东西对吧？现在我们要把这个 order，
10:58我们希望这两个要在它之前完成，这一个要在它之后完成。所以我们才在这加两负二式。现在我不加法师结，有可能导致这两个写了，但是那天天还没写，
11:11对不对？然后呢，这两个写进去之后，这个这个就有可能出一些问题。什么问题？就是我们看在 memory 里面是这样的一个顺序，
11:22一二三四我们希望这么写，但是落盘的时候呢却是这样的顺序。如果是这样顺序的话呢，它之接就产生了一个时间的一个 window，就是当已经 commit 了。但你这两个还没写进去的时候，
11:33这这这个 window 就是一个非常危险的一个一个 window。在这个时候如果发生了断电的话，那这个车就完了啊，所以呢我们不能走不能够走这个核心原因就是我们如何去保证这两个一定他在他之后啊，在他之前就要写进去。我们来想一想，
11:55就看这张图来想一我怎么保证他认用他之后在之前写进去。换句话就是当我在磁盘上发现 commit 的时候，这两个一定是对的。磁盘上肯定是对怎么做到这一点呢？不能叫胡老师怎么做，这个看大家能不能想出来，
12:24想出来就是一片 SP 问题很清晰了。我就要把这个 flash 减少，能不能享真能想出来。我们再来想啊，最坏最坏的情况就是大家看这个我这个可以再写了， commit 啊，
13:16已经落盘了，但这两个地方没落盘。那么当我重启之后，这个数据都丢了，对不对？我只看到这个 commit，
13:24我怎么根据这个 commit 来判断这个 commit 对应的 data 和 meta journal of meter data，它们是对的 OK。就是当然这里有一个问题是大家看不见这个 commit 到到底是什么样子。对吧 commit 到底什么样子，我们可以把它画的再稍稍微具体一点啊，我们可以把它画的。
13:47具体啊我这里有一个 data，对吧？ b 这个 GM 这个 d 在这个地方，原来在这个地，他也应该落到这个地 GM 呢在这个地方，然后呢，
14:05我有一个 journal commit JCJC 在这个地方。那这个 JC 长什么样子呢？这个 JC 它既然是 commit，它一定会说我这个 commit 是要 commit 什么数据和什么原数据，对不对？那肯定要记住这两个位置在什么地方，
14:26这样的话当重启之后就发生断电了，重启了。我一看这个 commit 已经写好了，那么我就可以找到对应的 data，找到对应的 meta data 写在 journal 里面。然后我再把这个 meta 贝塔的值写到，
14:45再再把它写到这里，去去应该这样一个过程，对不对？所以我这个 journal of meta data 呢，在这这个时刻，它一定是要记录下来，
14:53哪些是我的 meta data，哪些是哪个位置是我的 data，哪个位置是我的 journal of meta data。它肯定要记一下它们的位置在什么地，否则它他重做的时候怎么找？现在他产生一个问题，
15:06就是当我重启之后，我找到这两个位置，我怎么判断这个数是这个是对的，这个也是对的。为什么？因为我们之间没有 flash 隔开了，
15:21对不对？所以很有可能我是我先写了啊，我这个 journal of commit 先写到磁盘了，这两个可能还没写。那我怎么才能仅仅通过这样一个信息去了解这个数据是对的，是完整，
15:40这个数据也是对的，也是完整。我怎么判断这两个数据的正确性不行？我就有一个 check song 对吧？哈希是 check some 的一种，对不对？
15:52所以我就应该去记录一下 data 的一个 checson 和 journal of meta data，或者说就是这这一块 meta data 在这里 check some 我把这两个 check sum 呢都写在这个这个区起证据 OK 写这个地方。当我重启之后，我发现有一个 check check 这个 commit，我发现有 commit，我也知道这个肯定对应的在哪。
16:20然后呢，我就去检查一下他们的测测，把它数据重新算一遍，选测看是不是一样，如果不一样，说明什么？
16:27如果不一样，说明我是 abort 还是 commit 啊？如果如果如果如果不一样的话，那不一样，当然应该是要 boat，对不对？
16:38如果一样，说明这两个数据是合法的，他们是跟我一块写到磁盘才发生的崩溃，而不是我先写到磁弹。通过这个方法呢，我们就可以很好的去通过这个方法呢，
16:59我们就可以呃哎通过这话我们就可以很好的去把这里的一个 flash 删掉。 OK 第一个方法师就被我们删掉，这道题来了，我还有一个 flush。第一个 fluh 呢大家应该了解了啊，我不去记 flash，
17:15是因为我算了一下，这两者的切 sum 把它放里面了，所以我可以不用去记，不用去这个这个 flash。第二个 flash，我怎么把它删掉呢？
17:24第二个 flash，你把它掉。我们来想啊，我我之所以要 deaffly，是因为我不能让 meta data 在我可谓 t 之前写，对不对？
17:34这里有一个 meta data 的位置，一旦被覆盖了，我就回不去了。所以我必须在 commit 之后才能够把这个 meaga 再写回来。但这个 mea data 写已经我们发现有个有做做了一个 observation，什么 observation 呢？
17:48就是它已经不重要，这个 meta data 它写还是不写也不重要，为什么？因为一旦我这个 commit 成功，我就在这个地方有一份 meta ata 的副本，对不对？
18:02你上面那个 mate 订看啥时候写回去，我出来，反正迟早，哪怕你比如说隔一小时写过去也没事儿。理论上来说啊，我就隔一个小时，
18:15我就把这个写进去，一小时内发生的 crash，我就从这里面走从这个地方里面恢复也可以。当然一个小时夸张了，太长了。所以呢我们就基于这样一个发现，
18:27就是说我可以把这个时间拉长嘛，对不对？我把这些拉长嘛，我先把这个写出来，然后我开始拉长这个时间，再把这个 mate 的价值把它给把它给写会。
18:42但是拉长这个事情拉多长呢？那不成，你说来十分钟二十分钟，那你总得有时间，对不对？拉多长，
18:54然后呢，他们呢最后就就想也想不出来拉多长。事实上从我角度来看的话，拉长一点呗，反正我们只要证明十分钟，他一定就已经被写到磁盘上了就行了。
19:06但是呢从课就学术研究者来看呢，我们不能够去假设这个十分钟，对吧？那你为啥不是十一分钟呀，另外不是五分钟呀，因为二十分。
19:14但这个就是大家写论文的时候，一旦有一个 magic membory 就会被人 challenge，这个也很正常。所以呢，他也没办法，最后想出一个办法，
19:22是这个改意见。怎么改意见呢？就是他发明了一种新的叫这个这个这个这个这个这个改一下磁盘啊。然后呢，就是说当你磁盘把这三个东西写到磁盘就落盘了之后， OK 给我发一个中断，
19:48 OK 给我发个通告。所以这里就有一个叫这个这个这个 delay right 的话，就是啊要求这个发中告要求这个设备磁盘要能够去发一个中断看啊，发一个中断者。那如果说能够做到这一点，那我这个 m 就可以等到这三个中断都收到之后才去洗，
20:11对不对？你要三个中考没得到，我就不信啊。然后呢就能够保证 m 在前面三个你都已经写完了，我才把它给写进去。这个呢就是用来解决这样一个中断。
20:24好，最后呢我们一个结果就是首先我通过这个 check down，写到这个 commit 的这个这个结汇里去，实现了一个第一个 flash 去掉。其次呢，我就不做 flash 了，
20:38我我写写完之后，我这个先不写，等到他来了三个中断告诉我写完了，我再把这个写回去看啊，再把它写回去。这个写回去啊这个效果呢可以提到提高四到十倍啊，
20:53四到十倍。这个是制片工作在叫 OPDFS 啊，影响力非常大啊，在 QSP 上面影响了我们整个文件系统的这个设计。那后来文英雄在设计的时候啊，就就把一些就第一个优化，
21:08把它给放进去。第二个优化，因为要改硬件啊，所以说还没有真的硬件厂商这么去做。当然不知道最近有没有啊，但是至少从我角度来看，
21:15还没没了解到有这个硬件厂商去用。所以呢大家如果想办法把第二个消掉，而且还不改意见的话，那这个就就出出很大贡贡献啊。好，这是我们说的 SP 的这个一三年的工作。
21:30这个我们可以看到其实这个文件系统发展了这么多年，对吧？因为一三年也才十二年前啊，其实说长说远说早不算，早就是在十二年前，就是计算机已经发展了四十多年的时候，
21:45依然是在文件系统。这个每天都用的这么一个系统，里面会存在啊这么一些这个问题，说明什么？说明还有很多可以改进的地方啊，不是说那些系统已经没有做了，
21:57而是说还有不少这改你看四到十倍啊，四到十倍。好，那么接下来呢就发生了一件事情，就是这个 NV ram 来了， NVM 来了了。
22:07 n ram 来了之后呢，哎我们说这个 fassystem 就发生了很大的一个变革，为什么呢？因为 NVM 非意识性内存，它到底是内存还是存储这件事情啊，大家都没有能够很好的去这个这个把它想清楚。
22:26所以呢就就就来有这么一些新的这个硬件的这个这个就就就就出现了这个新的硬件出现呢。这个英特尔呢又是提出了这个 CDX point，它是放在内存插槽上面的这个内存。那但是呢它是非知性的，所以呢他也是认为是 storage，这样的话他就把这个补齐了。
22:47来看早期 SH 呃， hello color 这个磁盘磁盘大概是在这个在这个位置啊，在这个位置。对啊，这个是容量对吧？然后呢，
22:56这个是这个它的呃速度越往上速度越快，然后呢往上走一个台阶差不多就是十倍十倍。然后呢这个 none SSD 比它快十倍，对吧？然后呢，最上面的 resior rerestor 的话呢，
23:10差不多就是呃中间就差了好几个数量级。而英特尔的这个 MADM 就是这个啊呃 NADM，不是英特尔的啊， MADM 也是这个非实应内存。它在内存上面放了个电池，电电池啊，
23:23大电池其实就电容了。然后呢去兼容已有的这个 dim 的这个这个卡槽是 NVDM，然后呢 PCM 啊等等，这些都是属于呃这个这个飞行的这个内存，它的容量越大，性能就越差，
23:41对吧？然后容量越小啊，性能就越好啊，它是这样一个这样一个关系。好，那么有了这个之后呢，
23:49就产生了很多相关的这个系统。比如说最下面这块是一个非异性的 for nobody tetell memory，非预性性的内存，然后传统就有很多种不同的方法。第一种方法呢就是我们把内存当成磁盘来用，在这里面放一层 block l 的接口，
24:06就是我们前面说的四 k 大小的 read， right OK。虽然我在这一层可以做到 biite level granlarity，什么叫 bad level？ brandarity 就是我可以一个字节，一个字节去索引，
24:20去寻址内存就是这样，对不对？但是我不要我把它变成 block IO 的这个 level 四 k 四 k 去做。然后呢，一旦我把它变成这个之后，我就可以对接传统的文件室，
24:33传统的为磁盘设计的文件信息。这是第一类思思考。这样的话我改动西很少 OS 啊，不太喜欢新东西。这个呢有好有坏，好处呢其实很明显，
24:46就是我用旧的接口去兼容你新的硬件。这样的话我上层的应用啊什么都能跑， OK 就不用有任何修改啊，这个应用就就很开心了。缺点呢也很明显，对吧？
24:59你你你必然是没有办法把这个新硬件的最佳的这个实力发挥出来，否则我还要以新硬件干啥呢？好，这是第一类。第一类思考就是用现有的磁盘接口去对接，对接这个相应的这个这个这个这个呃呃这个这个 NV。
25:19这第一。第二类呢就是我把它看成内存，我用 loadal store 指令直接实现一个全新的一个文件系统。这个文件系统它对上是提供一个文件系统 OK，对下的话呢是用 load store，而不是 block l 的这个方法去做啊。
25:36这是第二第三呢，就是我直接把它分一些内存， map 一下，直接把它给暴露，把这个软件这个呃呃把这个这个非一性内存啊直接给暴露，给应用程序换个音雄。
25:55那为什么暴露给应用程序呢？一旦暴露给应用程序之后，应用程序就可以在用户台去实现。文件系统 OK，你爱怎么实现就怎么实现啊，我底下反正都已经给你了。
26:10这个呢就属于叫这个这个 OS，就白 pass 啊，就把自己看一下， ok OSWS 或者叫 kernel WS。这个呢就是现在非常也是非常火的一个研究的这个思潮或者一个思路。就 OS 啊，
26:28它只要配好了，剩下就交给用用自己去用 OK，你怎么用才最好？你自己知道，你不要让往别人提抽象 block 也好， memory 也好，
26:38你你你你你自己管啊， OS 呢就把硬件报给你报给你。有个前提就是我给你的就不会给别人。同样我没给你的，你也不能访问 OS，只做这一件隔离的这个事情，
26:54而把怎么用交给应用程序。所以呢就做了一个 discover OS 管隔离。换句话说就是管安全管全员控制这些应用程序就要去管什么啊啊管抽象管怎么去使用。我们举例，前面我们提了 i node，对不对？
27:10 i node i node 谁定义的？ i node 是由文件熊定义，文件熊是归归谁啊？文件熊是操作系统管制，对不对？好，
27:17现在不是了。现在我 OS 把这一块 memory 完整的非执行内存啊完整暴露给你了。你要你应用程序，你要定义自己的 i node 没问题，你爱怎么定义，怎么定义。
27:29 OK，反正这一块都是你的，你用就行了。只要你这个别指到别的地方去，就算你指到别的地方去，我也不会让你访问。
27:37为什么？因为我只给你这一块啊，别的地方我用我用隔离的方法，通过列表等等一些方法把它给隔离起隔离隔离掉啊，我就我就管起来，不让你跑。
27:48这样来的话呢，应用程序就发现哎呀，太好了，我以前从来没有机会还能自己去管癌的，对不对？都是我你说啥就是啥啊，
27:56 i 的里面有多少个一级多少二级多少三级，这个我都改不了。现在我什么都能改，应用程序呢，就可以更自由。好，
28:05然后呢，就是就是这是这是这种啊，就是属于叫做这个这个这个这个白 pass 掉， OS 把自己白 pass 掉。那么还有一种呢就是 OS 和应用程序配合一下应用程序呢，他也会说我自己有我自己的需求，
28:20我希望这么去设计文件系统。 OS 呢说好，我给你提供一些接口和一些抽象啊，让你设计起来更加方便，做的事儿更少一些。来怎么配合？
28:31那么整个的这个研究，我们说在 NVM 展开的 system 方面的研究都逃不掉这几种范式。 OK。我们是从接口这个角度去看看待这个这些相关的这个科研。大家把这张图记下来，将来看到一个 NVM 相相关的论文的话，
28:51你只要落在这个里面，就就基本上逃不出你的这个这个这个整个的整个的认知的这个这个范围 OK。好，那么我们后面简单讲几种。因为文章是看不完的，但是一旦发现他们的范式之后，
29:08那么看起来就会方便一些。如果大家真的要做这方面的研究啊，可以进一步的去深挖。我们就讲几个 case，一 dcase 就是 discenfss discf fss。我们前面说的就是它通过这个叫 block translation table BDD，
29:22去做一个 block i ver 接口对象，去兼容现有的文件系统啊，去兼容现有的文件性。然后呢，第二类呢就是 NBA ram 的这个 FS NV rank FS 呢它的设计是就就是包括这个比 PFS 啊， PMFS、
29:40 nova super FS 等等啊，这 super FS 还是我们实前是都没开老师做的对吧？然后呢，他的这个这个思路的话是它依然是 build on FS，就是大家看它这个这个地方依然是叫 FS。它对对上提供的很多接口都是文件系统相关的这个这个接口。
29:59同时呢它也可以更灵活，就是它可以有 object 的接口， transaction 的接口，那可以慢慢铺等等。这些接口的话呢，其实跟文件熊都没关系的。
30:09就 object 跟文件熊是啥文件，熊里里面就 fine 没有，但是我可以提供更新的 object 结果。为啥？因为 application 觉得 object 好，我就给他提供啊，
30:19其实这个原因都非常简单啊，非常简单。那还有呢就是我们最后一个就是蚪 curmodule curde module 的话呢，大家看这个 interprews 这个这个这个是呃这一层画在这个地方。但是呢他们这两者呢又是紧密的去做这个这个协作，通过 module 科蚪 module 去完成一些需要特权派才能够完成的事情。
30:45而把一些不需要特学派完成的事情呢，全部都放在 BMS 里面。这样的话呢我们就形成了配合啊，就是我们说指的好，为什么还要 FS 这个问题啊，没有答案。
31:02我已经到比较前沿的这个年龄，对于一个 a 米软的喜欢说一对于一个 NV ram 的系统来说，为什么我一定要用 FF 这么原始的抽象的这个面四 k 大小的这个滚滚滚 larity 这个这个这个这个抽象去做呢？没有必要，或者说有人觉得有必要，有人觉得没必要，
31:26这并不是一个有百分之一百正确答案的这个问题。那么支持的这一方呢就会说文件使用很重要。为什么？因为我们很多很多的这个应用都是基于基于文件手去做的，所以我们可以更好的去保证向后的这个兼容性 OK。那好，
31:46反对的一方呢就是说哎你屏蔽了啊信誉度索引带来的好处。好，我来看对于 DSFF 来说的话呢，它传统是这样的啊，看啊这个我们前面看的是一个比较简单的地方， driver 加上一个 fasis，
32:04对吧？其实我们打开看的话，其实更复杂。 give ver driver，上面有 IO schedule， IO schedule 上面有 genscheplay 啊，
32:13叫通用的快层，再上面才是 DCFS。再上面有个 VFS，这是虚拟网络层啊，虚拟文件系虚拟拟件系统，我就就去对接不同的文件系统，
32:22对吧？ find 三二还是 i node based EXT four 或是 NTFS，都是在这一层去做的。然后呢，上面带一个 system， cord 就 internex 啊，
32:32这是我们说的 DCFS，就长成这个样子。然后呢，对于一个 NV ram FS 来说的话呢，这一层就不要了。为什么？
32:42因为内存的接口就 low， so 远比这个 device driver 要简单，所以这层就完全可以不要了。还有 scheduling 呢，同样我们在访问内存的时候要做调度吗？我们访问磁盘的时候要做调度，
33:02为什么？因为你访问器那个磁壁啊，你要你你转的要转对吧，转到外圈还是内圈啊，这个是有讲究的，你来来回回它就很慢啊。
33:14你如果一次就把所有的都写了，再回来的时候呢，又把所有都写了，那它就会效率更高一些。这个就跟我们电梯算法一样，对吧？
33:23但是呢对于内存来说呢，没有这个问题。为啥？因为内存访问的时候，所有的办都是一样的，叫 constant。
33:30但是常量的访问时间，所以我们根本没有必要去做调度，所以这一层就不需要了，不需要了。此外呢这还有一个 general block layer block。对，
33:40有之所以要 broke laer，是因为我们很多时候这个四 k 的写密度啊，其实是很麻烦的一件事情。我给大家举个例子，比如说我们现在要去写一个 i note 前面我们有个 case 吧， i know 的，
33:59我们要把它的 size 里面有个 size，对不对？我把那个 size 从四改成五，假设啊从四改成五。但是我为了去写这个四把这个四改成五，我要先把 l 的读出来，
34:12为什么呢？因为磁盘的最小读写单位，最小读写单位是四 k 就是一个 bite 啊，一个一个 block。然后我们前面提了，你一个癌六的只有一 k 对不对？
34:25你边上还有三个呢？ ok 你没有办法，直接把那个四改成五，你要把整个四 k 就是你这个矮 node 和它边上三个邻居全部都读出来在内存里面。改完之后再写回去，这个就是所谓的 read before，
34:41 right 其实是很花时间的一件事情，但没办法没有办法，因为它的访问的力度是很粗的。好，那么有了这个 battle level 的 gradueity 之后， address adjusibility 之后，
34:54我们就可以直接想改哪就改哪，不用再去做这个 read to or right。这样的话呢，传统的 flock layer 要做的事情，比如说这个凑到四 k 一块写都不需要 OK，直接写就行了，
35:09直接写就行了。这个呢就是我们说的这个这个这个这个这个 ministone 带来的这个这个好处啊，就是这个要为了这个新的文件情啊，全新文件系统要去做这个修改 OK。好，然后呢我们发现接下来呢我们要去这个这个讲一个讲一个这个在在 NVM 里面的 crashed 这种问题。
35:41我们曾经在讲 crash condition 的时候，我们发现你这个 d one 里面数据是易丢的，对不对？然后你要 flash 到磁盘就不丢了。好，现在问题变了，
35:54变成什么了？变成我这款内存里面已经非一致性了，对不对？那我是不是这个问题就就没了呢？我还要考虑断电导致的 inconsistence 的问题吗？一致性的问题还在吗？
36:09那我们就要去想了，还有什么东西断电之后，数据就丢了，还有啥 CPU，对不对？你说 CPU 本来是内存断电，
36:19没了，硬盘上面数据是不一致的，现在变成什么呢？现在变成内存断电，数据还在，但是 CPU 里面有些数据它有可能会不一致。
36:31所以呢我们就要去想这个问题，就是这个 rap p cash 就从 CCPU 啊， CPU 呢它要写一个数据到到这个 direct 到 direct 这个呢也是 CPU 里面的一个 cash，他给他发过去是 a 然后是 b 但是在这里由于我存在一个 rap back cash， CPU 内部存在一个 rap back cash，所以呢有可能会导致 a 和 b 或者说 AB 变成 BA 啊，
36:54顺序换了个这样的话，我们我们选用 case，比如说我现在需要写 data，零 data 一再写一个 valid。我这我的预期是说，当我 value ed 等于一的时候，
37:06我 a 和 b 这个这个 data 零和 data 一就应该已经写完了。但实际是什么呢？实际很可能就是先写了这个 valid，再写 data 一再写 data 二二零对， data 零 data 一。这样的话，
37:21当你唯一的被被设被写到这个 NVVR 女婿之后，突然发生了断电，对吧？那问题就来了，跟前面是一模一样的，只不过它的边界从原来的内存的磁盘变成了 CPU 核电池。
37:33第一遍 OK 怎么办呢？地域不好，第十一步开始，我想想都觉得慢，对吧？第二个办法，
37:43 bright through，想想觉得比原来低一个好一点，但还是很慢。第三个，每次 commit 的时候， flash 所有的开始呃，
37:51怎么就这确实也是一个办法啊。于是呢我们就就用 flash 开始看看怎么着，能够让它尽可能的不要对性能有太大的这个损耗。于是我们就开始做这个事情。就是说我们要有一条叫 CL flash 的加量指令，这个就是类似于磁盘的 flash。
38:08但是它是对于 cash line 的 flash， cathe line flash，简称 CL flash OK。但是呢 cash y fllush 会把整个 CPU 的拍坏 stop，导致没有什么东西可以在这个过程中写。于是呢可以变成这样，
38:23就是你看你你调一个 store 指令，对吧？写写写进去了，然后你调 CR flash，调 CER flash 的时候，他他 store 的判断。
38:30于是呢，你等他做完才才才才才调。这个 data 一的这个 store 指，然后又是一条 CR flash，最后才是 SD valry 的这个 beach，从而通过两条 CR flash 去保证它们之间的 order 怎么去做。
38:44这个优化呢软件说实话还是比较难的。于是呢就有一个硬件叫做 CL flash OPD 听名字就知道它这个是一个 optimize 的这个这个版本啊，有了这个 CLOPD 之后呢，它就可以把原来的很长的一段时间的 store pieline 这个操操作的话，把它变成可以并行，而且我只 store 你对吧？
39:07然后我只停下你对吧？然后你这两个还是可以并行，等到这两个都结束了，我才做做这个事情。 ok 但是这个问题还这这个这个操作还有一个问题，就是 intel 的这个 flash 操作啊，
39:20其实它会把 catch 里面的数据清掉，就什么意思？就是你你 flash 完了之后，数据确实到了到内存了。但是呢 catch 里面的也没了你说，这意味着什么呢？
39:33意味着你下次比如说你有个数据，你一直在访问，对不对？访问访问访问它 catch 里面，然后你把这 catch 里面数刷到刷到这个内存里去，不意味着你就不要不要访问它了，
39:45你只是想把它刷进去而已。接下来你还要访问，结果你再访问的时候就 catch miss 了。因为他认为已经刷掉了，他就把内存的 cathe 里面的数据把它给清空了。所以我们需要的是，
39:56我们需要的是你把一块数据从 cath 里写到内存，同时还在 cathe 里面，下次别人用你还可以用于是呢英 l 又出了一个叫 CLWB，叫 cash line right back 这样一个这样一条指令，就是每次运行完这个等价于 CL flh OPT 运行命令之后，不会把 cathe 点掉，
40:17 einadadcache 依然不在，这样的话能解决这个问题。所以我们可以看到到这一步的话，软件能做的事情那就比较少了。为啥？呃我们控制不了 cathe，
40:27对吧？我们以前 cache 对于软件是可见的，我们控制不了 cache。所以为了控制 cathe，我们只能够让英特尔多给我们一天使力，英特尔确不也给了啊，
40:40所以后续的很多就底层方面的研究的话呢，就需要用到这个软硬协同的这样一个方案啊。我们今天只是给大家举几个例子，今天我我觉得重点的还是要记住这张图。这张图呢就是呃我们说后余很多工作啊都可以划归到这个两张图里面去。好吧？
41:00好，我们今天就上到这儿啊。好，那先下课吧，四点这个有嗯那个 ok 今天我给你说，对我回家不就能那个这首歌我已经在这里过。
42:22对啊，这边一个日梦不是自己写的，日梦中于空有豪达天文。那个现在我也看自己啊，这样有很多卡。对，
42:47有过七点，我知谢谢你。只有一个，你不需要还有没打完，不能走了给你的，我自己开始所谓的只讲什么东西啊。
44:13再说一批，我我也么感觉听不懂我们他的那个。那你这个不感对急分不清楚是，但是你点的这啥我还得不喜欢。其实这边其他眼圈，一个黑糖波波等一下有 least 嗯，
46:23我现在就是其实一直在点，那嗯，我可怕还分傻，就是那个叫什么浆果酥吧，就是我今天跟九然一起点，虽然他不是他们要这个什么将果蔬忘这样看一下，
47:23你是去。对，为什么？我是那个我就是给你们发有有人群啊啊老哥，我知晚了，把环境给太好看，
51:21把那个用我后端又跑起来了，后端哎我们后端跑起来了，我不知道，我可不起来，他说然后他是 JBK 版本还是 java。哎喂，
51:35你刚该试一试活动吧，试活动吧，你是没意思吧，全部一个为什么要出问题，对不对？我上去算了，
53:37是世界排强运动的突播，我不记得我给你拿去。昨天晚上买这个中多，是因为今今年了一年了，像是啊这样子。对，
53:58减少那个是不是开始游习，而且差不多字幕我吃了给你走掉，你想这个颜色是怎么么？你有吗？因人他的一个信息有点好，不会那上一节课讲的 RPC 以及这个会讲，
54:29那肯定是哦，然后我就不想我看一下，我寻思回家去别丢了。我为啥家小吃你最亲爱的还有一个防晒衣啊，那个防晒衣一个月一个月前刚买，那我能把伞伞都不一定住，
54:49记住了天晚不是，本来还还来，我当时买了一个挺贵三百单，我当时想就是我之前那种丢了。