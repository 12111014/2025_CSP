00:47是嘘嗯及几点嗯嗯，不见。那么我们呃开始今天的上课 OK，今天我们上课的主要介绍的话题是 consisteny model。然后我们会呃比较大的这个篇幅去讲这个这个分布式下的这样的 consist model。然后最后有一些时间我们会去讲一下啊，
05:46在出错的时候，我们怎么保证这个 consistence 那么简单来说的话，这个卡瑟斯斯它其实涉及到的是你的这个系统里面的数据存储，它包括你的这个单机存储文件系统，它其实也会有这卡瑟斯斯问题。然后分布式系统当你的这个应用对吧？
06:04它需要把数据存在在多台设备的时候，一定会遇到这样的这的问题。那么大家如果以后去面试，对吧？人家就会问说，你说我我懂一些分布系统，
06:12那肯定就就就就别人会问对吧。那你知不知道 model？那么什么叫卡戴斯 model 呢？我们讲了那么多，它它中文名叫一致性，对吧？
06:21那么一致性它到底隐含着什么呢？一般来说它其实指的是我们这个数据啊，它在不同人看来啊，它是一个正确的这样的一个一致的就是顺序。操作顺序是一样的，这样的一个一个一个一个一个改呃一个一个一个方式。
06:36那么为什么这样的一个方式，它能导出这个这个正确性的那我们之后会有一些具体的例子，然后会会讲。然后然后再讲这个一致性模型的时候，我们大家一定要记住这个观点，就是这个一致性模型啊，
06:49它其实有非常多非常多种类啊，有的有的其实看上去不是特别的对啊，但是它实际上为了为了保证比如说系统这个性能啊和可能性啊，我们我们我们有时候会牺牲掉一点一致性或者叫正确性，来保证这个系统的这个可靠性。比如说现在比如说大家手机里这个微信对吧？
07:07它里面采用的最多的模型就是叫做这个 eventually consistence，它是一个比较弱的这个模型。但是它的性能其实非常好，所以大家平时用微信会比较丝滑 OK。然后在介绍完了一些模型之后，我们会去探讨一下这个不同一致性模型的一些实现的这个方法。
07:23因为我们其实会看到啊，即使是你是一个最弱的一致性模型啊，如果或者说相对较弱的模型，你如果不考虑啊，这个你果要考虑到用户的这个体验的话呢，其实它也会有这个这个会有很多的时间种方法在不同方法是有取舍的。
07:38然后这里面就会涉及到这个分布式里面一个最最经典的这个这个概念叫做 teststp。就始终就我在一个分布式的事，怎么去啊给事件去去去标记顺序啊，我们会看介绍一些比较经典的这个使用方法，包括像这个 lanport clock 以及这个 bad clock。然后最后的话我们会呃讲一下，
07:58就是说你一个比较弱的一些模型，在某些场景下它可能并不适合应用。所以我们需要定义并且去实现一些这个比较强的一级性模型。那是到底什么叫强呢？对吧？我们会介绍呃会介绍，
08:10然后以及不同强的一些模型间它们的取舍是啥？即使是强的一级些模型之间，它其实啊不同的呃实验方法啊，其实也是有挺多的啊。然后他们也是各式渠道道后最后我们如果有时间的话，我们会啊讲一下，
08:22如果你的这个系统它如果啊出现了故障之后，我们的数据怎么到底怎么样才算正确的 OK。那我们先来看一下这个分布系统里面啊最最经典的一些问题，就是我们存储的数据对吧？到底是怎么样才是对的，怎么样才对的。
08:38然后我们就拿一个例子，就是大家手机这个微信，对吧？我们的微信现在其实是非常重要的一个应用。那大家这个例子，我不知道大家在有有微信用微信的时候，
08:47有没有遇到图中的这样的一个例子。这个例子表示的是说哦，有一天对吧？比如说我下我的微信办公，然后我下派任务，就是我先发一个文件 OK。
08:57然后呢，我是说哎某某某你照着这个文件啊改一改。然后这个时候呢某某某在另一台设备，大家看到说哎，我看到这条消息，对吧？
09:04微信它实际上是会有一个 reference，就是说我 reference 到之前一条消息，然后说我要处理这个文件。好，然后大家这个时候他呃不知道有什么心情，对吧？
09:14那反正他会点开这个文件去做处理啊，这个时候微信他会告诉你引诱内容不存在。大家有没有在平时日常用微信或者说其他的这个聊天的这个软件里面遇到过这样的一个问题，对吧？我相信大家应该遇到吧，这个就是我我我日常用过程中对吧？
09:30我截的一个一个图。那么大家有没有想过这个东西它本质上什么呢？你显示的是什么？微信显示的实际上是你的聊天记录，对吧？那么聊天记录本身是什么？
09:40是微信它为我们每个用户去存储的这样一个数据，对不对？如果微信它展示我们这样一个数据，说明什么？说明这个数据它的呈现的至少它是不符合我们的一部分的预期的，对不对？
09:51因为因为我如果看到一条引用了某一条消息的消息之后，那我引用的那条消息，它里面所蕴含的比如文件也好，图片也好，它都应该是被同步到我们这个设备上，对不对？
10:02那实际我们在用这样的一个微信的这样的一个程序过程中，它其实确确实有可能违反了这样的一个这个原则。那么它背后的原因什么呢？它其实本本本质原因就是啊就可以归结为啊不同设备之间对于不同操作发生的这个顺序啊跟的观测产生了这样的一个规制。我们说分布式里面基本上所有的这个数据的这个不正确的这样的一个问题，都都可以归结为这个不同设备观测不同这个数操作顺序产的位置。
10:31那怎么理解这句话呢？我们来看一个具体的例子，就是拿我们刚刚这个例子，我们来一点点的抽丝剥茧的去看一看，对吧？我比如说假设让大家去实现一个微信啊，
10:40你你的你实现的微信会不会出现这样的一种场景。其实我们大家如果自己在脑海中去用思想实现，对吧？我们去实现一下微信就会发现啊，其实微信它出现这种现象是非常非常正常的。它就应该出现这种这种情况啊，
10:54不然的话它那个我们平时会会没法用这样的系统 OK。我们先来理解第一个第一个事情就是为什么我们说这个这个这个这个所有的数据不正确，对吧？都能归结为这个操作的观测不一致。那么首先我们想想看，如果我对于我们一个聊天的这样的应用，
11:10对吧？那么它最基本的这个这个系统抽象是什么呢？它无非它就是第一，我们每个系统都有一个它自己的数据结构，对吧？比较维护的数据结构。
11:19那么对于你的聊天软件来说，它的数据结构就是啊我一一个 list，对吧？这个 list 里面包含了你的这个聊天聊天的这个内容啊，它可以是文件，也可以是这个户呃语言啊，
11:31这个信信息对不对？然后对于我们用户来说，它其实的操作很简单，它就两个操作。第一个操作就是把 pose 就是我在这个 list 里去加一个这样的一个这个这个这个这个这个这个这个消息也好，文件也好。
11:44那么对于我去翻看微信，它本质上什么就是个 read。就是我去把当前的这个我系统里的这样的一个聊天的这个 list 去给读出来，对不对？他就这样一个简单的这样的一个系统抽象。那么假设啊我们要出现刚刚这种情况，
12:00那么至少我们要出这种情况，前提是什么？肯定是有一个人。比如说我我先 post 的一个文件，然后我再去 post 一个 reference 这个文件的这个消息，对吧？
12:09所以说假设啊是是 alice 对吧？他破他做了这样的一个操作。那么在站在他的视角里面的话，他这个系统里面，他观测到的顺序应该是两个操作。先 post 文件，
12:21先再 post 这样的一个这个这个这个这个引用这个文件的这样的一个这个这个这个消息，对不对？那这是 alice 的这个视角，但是为什么包 b 他会啊看到对吧？就是说我这个这个消息引用的消息不存在呢？大家想想看，
12:37本质上就是站在包视角，他先看到了这个这个后面一条消息，对吧？他看到了后面一条消息，先到后面一消息说。我这个是不是这个文件啊，
12:47他先到。然后可能系统某一段时间它同步后了之后，才会把这个文件给传过来。这个时候什么系统把这个这个这个前一个库存文件的操作往后移了。那么这样的话站在这个 bob 的视角，对吧？
13:00他其实就能看到我的这个消息，对吧？它其实在两在 i 的 bob 视角，他们对于两个操作之间的顺序是不一致的，对不对？那么站在 alice 的的角度来说，
13:10他觉得这个顺序符合合辑符符这个先先发生的这个因果关系系的那么大。想想如如这个站在在 alice alalice 这个符合条件的这个这个允许情况下的话，如果它不一样了，反反转，那那么怎么办？那么其实站在就站在 bob 的角度来说，
13:25这个数据就错了，对吧？这个其实就是一个很明显的就是我们在说在分析秀里面会出现的这个不一致的这样一个现象。 OK。所以这个就是我来回答我们前面讲说的一个问题，就是说什么叫做呃这个数据一致性的这样的一个问题。
13:41那本质上来说，就是我们希望数据有一个一致的操作的这个顺序。然后这个顺序是符合我们应用预期的。比如说 IS 先 pos 文件在 pos 的这个这个引用这个文件的消息。那么所谓的不正确，那就是说我有一个人观测到了不符合这样的一个一致顺序的这样的一个这个这个这个操作。
13:58 OK 这个这个事情啊，在在这个分布设计系统里面非常非常常见。基本上大家如果作为一个分布系统，很多时候遇遇到这样的一个问题，那么大家这时就会想，对吧？
14:08为什么我的这个 check 这样的一个应用，对吧？它会或者者其其他的似的这个分布应用，它会会出现样的一个问题呢。对吧为什么说我这个系统里面会啊以这样一个非常不好的方式把这个数据给给给展现给我，我能不能把它做的展示的这个没有问题呢？
14:26其实我们可以看到啊，就是包括我们后面的个也会一直在讲，就是说它其实本质上是个吹道。就是我们可以永远给用户展示一个这个这个正确的这样的数据。但是这样的一个实现的话，基本上是不符合我们大大家所用的这样一个系统的这样的需求的那这个怎么怎么理解呢？
14:44 OK，那我们就得先打开的对吧？去看一下去看一下什么呢？就是说假设啊 OK，我们有一我们假设让大家去实现一个微信，对吧？
14:54你会怎么样去实现这样一个微信？我们说我们去，我们现肯定不要要实现这个微信的这个各种花里胡哨的这个功能，对吧？我们就实现微信最基本的功能，就是我两个人在这样的一个聊天 OK 聊天。
15:07那么大家想想，如果站在大家的视角里面，我我们该怎么去实现这样一个应用呢？那其实我们前面提到这个，如果你要实现一个聊天软件的话啊，在现在这个年代其实是应该是个非常简单的事情。
15:18对吧因为我对于一个聊天来说，它的这个所有的数据都可以用一个 list 来表示，对不对？这个 list 里面的都是无非就是要不就是个文件，要不就是一个消息。然后这个消息可能会带一些这个原数据，
15:30对吧？它可能是 reference 之前的一个消息的啊这样的一个这样的一个内容。然后我的这个整个消息软件里面，那么它的这个操作无非就是一个 post 一个 read。那这个时候大家可能就会想一个问题，就比如说我要两个手机去互相通信。
15:44那比如说我肯定需要两个人的手机去互相的这个这个交互，对不对？互相的交互。那很很多时候如果有一种情况是说我一个手机对吧？它可能离线了。我这个这个消息不就发不出去，
15:55我这个系统不就是显示不可用嘛。那这个钱而不是一个非常好的这样的一个一个一个思想。所以说一来说我们会会什么？我们会有一个这消消服务务，对吧？我们把所有的消息哎都放在服务器上 OK。
16:08然后我每一次比如说要 pos 也好，我要去域地也好，我就跟这个这个这个这个这个这个这个这个消息服务器框境，比如说我要发一个消息对吧？我就是把一个用 RPC 对吧？我把一个这个消息的内容，
16:22比如这个文件上传到这个服务器，然后告诉他 OK，我上传一个文件，你把这个 list 改成一个有 file。然后呢，我假设我要去 reference 一个另一个文件 OK，
16:30我就是把这个这个这样的一个这个这个这个这个这个呃这个消息也是也是这种同样的方式发过去就吧。那么 server 收到这个消息之后，我可以很简单的去把这个消息给 append 到这样的个个中心的服务服器器里。然然后如果另一台手机对吧，他需要看消息了。 OK 他就是发一个 read 的这个请求，
16:48然后 server 就可以把这整个这个消息发回去发回去。然然后后后为为了了实现这个这个效率率，对吧？比如说这个假设我有个文件，那么 server 的时候，它一般来说也不大会说我我我要读这个整个消息，
17:01我把整个文件都发过来，对吧？大家如果用微信的话会发现啊，微信它其实会先给你传一个文件的，这个类似于名字，对吧？
17:08等你真实访问的这个文件的时候，他才去帮你下载这个文件，对吧？为什么呢？这么做呢？因为一般来说我这个文件对吧，
17:14它是会比你的这个消息的列表大很多的。所以你如果整个文件这个都都都都传，每次 seek 都要把所有文件都传开，那这个肯定就是做的太慢 OK。好，大家想想看，
17:26我们就假设以一个这样一个最基本的这样的一个呃用中心化服务器去实现微信的这样的一个例子，对吧？微信这样的例子，这个是大家应该是能想到的最简单的这样一个实现，对不对？对，
17:39这个实现应该都比较直观。那么大家想象一个问题，就是我们在我们这个实现里面会不会出现之前我们说到的这样的一个这个 reorder ded the case 什么意思呢？就是就是比如说我用户对吧，他就是 ES，比如说他 post 了文件和引用这个文件的消息，
17:59然后呢，这个这个 bug 对吧？他看到他没有看到这个文件，然后没有看到这个文件的 handler，他看到的实际上就只有这后面一条消息。那大家想想在这个三 tres 的这个实现中，
18:09它可能会出现这种情况吧。其实呃我们其实可能很明显的想到它不可能出现，为什么呢？我们可以来做一些简单的推导，对吧？假设啊我们说 bob bug 对吧？
18:21看到了就是说后面这条消息，那么我们可以看到在这样一个例子里面，对吧？ alex，如果他是等到这个这个这个这个我第一个消息完成了之后，我再去 post 后面的一个消息的时候，
18:32对吧？那么大家下他就会出现什么情况，就会出现说我这个 bob 看到这个消息，一定意味着是说我整个消息列表它更新了这个这个文件的这个 handlle，对不对？那么这个时候如果我报了再去读的话，
18:44他一定是能够把什么？一一定是能把这两个这个这个这个这个这个这个消息全都读回来。那么所以他看到的顺序其实是和这个它 pos 的这个顺序一样的是吧？所以说我们可以看到的是，当我们用一个这个这个这个中心化的这样一个服务器，对吧？
19:01去实现这样一个微信的应用的时候，我们发会发现它其实并不会啊存存在我们之前所说的这样一个 reorder 里面这样一个问题。那么大家这个可能就会好奇，那为什么对吧？为什么平时我这个用这个微信对不现这样一个 reorder 一个问题的那它肯定是源于什么，肯定是因为微信它背后用的肯定不是种 stantralize 的这种非常简单的设计，
19:21对不对？那么为什么微信它不采用这样的一个很简单的这样的一个设计的。那么它肯它肯定背后会有非常多的这样的一个这个这个这个开销，对吧？非常多的这样的一个系统的这样的一个问题。比如说我们可以来举一些问举一些例子。
19:39第一个问题就是说我每一次在这个 check t 是呃这个应用的交互过程中啊，我都必须得发一个 RPC 啊，给这样的一个呃中心化这样的服务器啊。不管你的这个我本因为我本地其实是每个手机，对吧？它其实是一个空的状态啊，
19:55它看消息都是问问 server。那么这时候再来想一想我任何的这个如果大家设想到你手机上，如果每一次微信我点到一个聊天记录里面，它都要发一次这个 RPC，然后才能把这个东西返回过来。大家会出现什么情况？
20:09那手机体验就会非常的这个卡顿，对不对？你这用起来就非常卡顿。因为你这个这个明明我很多消息明明我已经发了，但是我为了拿到这个最新的这个消息，对吧？
20:19最新的这个文件的消息，我得每次都得跟服务器访问。这个不就是意味着这个这个这样的一个你会很卡顿吗？而且它对于这个 read 来说，它的这个卡顿尤为明显。为什么？
20:31因为你 right，可能我就是 post 的一个一条消息就结束了。但就 read 的话，通常来说，我得把这个整个这个消息记录对吧？全都拿过来。
20:40然后那这个显然啊显然是一个这个这个不是特别理想的这样的一个对于微信来说啊这样的一个设计，对吧？当然这个设计其实还有还有很多问题。比如说大家想一想啊，假设我的这个手机 offline 就离线了，对吧？
20:55大家如要上飞了啊，那它它现在飞机好像都有 wifi 或者进了隧道。这个时候如果你想看这个微信，对吧？你会发现好，所以这个这个 centralizze 的这样的一个设计，
21:05它其实你根本手机上看不到任何的这个这个这个这个微信的记录，对吧？你得等到这个服务器连接上来 OK 才行。好，所以这个其实也是一个很大的说，我们需要你在没有网的情况下，
21:16通过这个历史的这个聊天记录去去办公的或候或者做一些其他事儿。那这个时候其实就啊也是没有办法处理好，这样是包括这个设计。其实还有一个我题是我们现在想到用一个 centralizze 的操作，就是我只有一台 server 去存这个负责接收所有的这个 post 和绿的操作。那大家想想我们在这个讲分布式课的时候，
21:36我们讲过一个很重要的事，就是你在分布式下，对吧？我一台 server 其实很容易会出现单点的这个故障。也意味着说一旦我这个 server 挂了，我整个这个微信服务就会挂了，
21:46对吧？那么在这个这个数据中心的话，对吧？它服务器一般是每个小时都会有有服务器挂，对吧？但是大家想想，
21:52我们微信会出现这种每隔一个小时就就不可用的这个情况嘛，显然不会对不对？那么也就意味着说我们不能够用这样的一个单点的这个服务器，对吧？去接收啊所有的操作这样一个这个这个这个比较简单的这样的一个方式，对吧？
22:08去支持这个微信里面的这样的一个所有操作。那大家想想，我们现在现在学我大家大家应该都有点印象，对吧？就是我们微信它背后到底是怎么样去去实现的。比如说大家我们如果要解决我们之前的这些问题，
22:22对吧？比如说我微信要去解决这个 offline 的问题，那意味着什么？意味着说我每一个这个手机册得去存一份这个完整的历史记录，对不对？得存一份完整的历史记录。
22:36不然的话这样的一个这个这个这个我的这个这个这个这个我就没法理解看，对吧？那么为了解决这样的一个这个 server，一个单点服务器，它挂了我这微信不能用的这样一个问题。他像微信，
22:48他现实生活中怎么做，他肯定是会把这个自己的聊天记录录在在很多个服务器，比如上海一份，北京一份，对吧？你上海的服务器挂了，
22:55我直接去连北京的就行了，对不对？所以我们就会发现就是说你的这个这个一个简单的非常简单的这样一个三叉 s 的用 RPC 这个 build 起，这样是一种是系统啊，它没有我们前面讲的这种啊这种一致性的这样的一个问题。但是一旦我们这个系统啊，
23:14你要求加上可用性，对吧？你要加上这个这个用户的离线的这个需求， OK 各种各样的这个问题啊，我们就我系统最终终会变成一个你的数据据 replicate 多多的这样一个方式。然后这个多样的方式其实就会会比我们之前讲的这样一个三出来设计要复杂很多，
23:34对吧？那首先我们来看一下，什么叫做数据是多份呢？就是假设我们现在的这个还是我们要实现应用，对吧？对我聊天应用，
23:41那我们这个应用的数据它就是一个 list，它的核心数据是 list。然后为了保证离线，为了有容错，我们这个 list 会在每个手机侧，用户的手机侧都会有一个。
23:51然后呢，我为了保证容错我的服务器有很多个副本，然后每个副本也会存一份。一开始是一样的这样的一个这样的一个这个这个这个这个这个这个这个这个这个 list，那么这个设计对吧？我们从直观上就能看出，
24:06第一它那个离线肯定可以支持啊，第二它能做很好。那大家想想它这个代价是什么呢？这个带系统这个系统如果我们要我们说 data 这一块我们已经搞定的话，那么它的其其的的三， trs 三它不同的一点是什么？
24:20大家想它的这个 read 和 post 这两个操作的实现，系统实现是不是会变得非常复杂？大家想想，我们如果要在这样一个 replicate 系统下，我们怎么去实现不同的操作呢？比如说我们先举个例子啊，
24:34假设我们要实现这个 read 这样的一个操作， read 操作就是我要看一下我当前的这个聊天。那么我大家想如果从我们刚刚的角度说，你为了支持离线，你为了把性能做到最快，那么我们最快的一个最好的一个呃最方便的一个方法是什么？
24:49就是我直接去把本地的这个存的这个数据对吧？给返回出来，给渲染出来，我就结束了。好了，大家知道这样的一个操作有什么问题？
25:00有一个问题是比如说我的这个你的这个这个这个假设啊，我们其他人对吧？他也是本地发了一些消息，把这个 list 更新了。这个时候我们会发现什么？比如说其他人的这个 list，
25:12他变成你好了啊，有有一条消息。但是我本地一直没有更新，就会出现什么情况，就会出现我本地的这个 list，它没有拿到最新的这样的一个 list 数据，
25:22对不对？所以我们就会发现啊，在这个然后呢我们又不可能说我每次 read 都去往所有的服务器都去要数据。但这个你每次 read 开销会比之前的那个那个实现其实还会更大，对不对？所以说大家看一下现在手机里面它怎么去做这个消息的更新的，
25:40它其实会有一个叫做 think 的这个步骤，就是右上角对吧？大家加看，如果你这个微信对吧？如果切到后台了，然后你第一次打开的时候，
25:48它其实会有一个一个一个叫收取中这样一个操作，对吧？它其本这样什么，它本质上就是说它会去跟其他的这个设备对吧？做一次通信通信 OK 通信，然后把他们的这个最新的比如说消息内容给拿到拿到，
26:03然后呢再去把这个本地数据据更新一下。 OK，这样我就能看到到这个这个这个数据了。也就是说在我们的这样的一个这个分布式情况下的话，如果你要保证这个 read，要保证读到最新的，
26:17你得什么，你得有一个 think 的这样的一个操作。但是 think 的操作它会有没有问题是什么？就是它 think 的开销实际上是比你 centralize 的 KV 里面去读一次，这个开销要大很多的。所以呢我们现在系统得什么得得去控制 think d 我们得去控制 think 的这个频率，
26:33对吧？你不能说啊很快很快就就一一天到晚在 think。那你这个每天发那么多消息，你把手机可以爆爆掉。第二个就是说我啊对，其实主要就是控制 think 频率。
26:43所以说大家可以看到这个现在手机厂商它会提供一个叫什么叫做这个 push 中这 ducaation service 的这样的一个嗯一个功能。什么意思呢？就是我有手机上有一百个这样的一个应用，一百个应用。然后这版应用呢，它并不是每个应用啊，
26:57它都自己去发 think，而是什么呢？是是厂商啊，它会把所有应用的推送啊，都放到一个这个手机厂商管的这个啊，比如说苹果管的这样一个服务器。
27:06然后这个服务器会统一代表所有的应用去做这这样的一个 siink。这样的话我相当于是每个应用它的通信量都小很多多吧 OK。那么这是我们的一个基本的这个过程。就是说我的 read OK 去，我我的 read 最快我我先访问本地数据，然我本地数据去后台去这样一个 periodically，
27:24去和所有的服务器系统啊，去拿这样的数据 OK 得这个数据的话啊这样的一个系统模型下。大家想想看，我们是我们我们真实的手机 think 它是不是就是这样的一个一个模型呢？那就是是不是我就是每次 think 我就跟所有的人都通信一遍都完事儿呢？它其实没有那么简单，
27:42没有那么简单。其实有两个问题，还有两个问题需要解决需要解决。第一个问题就是我到底要 think 多少台服务器，对吧？大家想想，
27:52我们为了保证可靠性，为了保证容错我的这个服务器可能会有特别多，对不对？如果每次 think 都要跟所有的服务器的话，那它其实从它性能是比较差。我们这个已经讲过，
28:01但我们可以通过频率控制频率来解决。那还有一个问题是说，如果我有些服务器都挂了，那有些服务器挂了怎么办？那我这个 think 是不是做不了了呢？对吧？
28:12 think 做不了。那我难道要完全抛弃这样的一个这个这个这个这个这个设计吗？其实其实不是的对吧？其实不是的。然后然后那还有一个问题是说啊，我这这个这个这个如果我要 think 的时候，
28:26我是要 think 什么样的内容。大家想想我们这这个每次次去 think 的时候，我是 think 是整你是把用户的整个这样的一个聊天记录，对吧？都上传都上传回来，还是说我每次只需要去 think 这个里面的这个一点点的这样的一个操作呢，
28:42对吧？这个其实也是因为你每如果你需要上传整个内容的话，如果我们会遇到的情况不同 server，它的这个聊天记录啊它的内容不一样怎么办？你这个 think 时候，你到底其实一个这样的一个这个这个这个服务器传过来内容为主呢。
28:56所以其实为了解决这些问题，对吧？人们其实会两个这个一般来说的比较直观的实现方法。什么？就是我 think 的时候啊，我不去 think 这个具体的聊天内容，
29:06而我是去 think 就是你到底发了多少条消息，然后有了多少条消息。比如说我我告诉你说，你这边有一个消息，比如谢谢，对吧？
29:14一个消息是不同的案 d 哈，然后我收集回来之后，没关系，我只要把这两个消息是吧都给去 push 进我的这样的一个 list 的对吧？它这其实我这个聊天也可用啊，对吧？
29:24但是其实解决了第一个问题，就是我两个 server 对吧？这个不同的不同的这个消息流段，如果不一样啊不一样怎么办？那么还有一个问题就是我们就说如果你要去 think 很多个 server，如果你 think 很多的这样的一个 server OK，
29:39如果他有一台 server 挂了怎么办？你这个这个比如说我就是要 think 一台手机，这个手机它离线了，你能不能让这个 think 继续活下去？其实现在在微信他做法是什么啊？其实是是可呃他他其实就是说可以对吧，
29:52他推的原因是什么呢？他就是说我每次 think OK，他不要求不要求去 think 这个这个很多的这样的一个这个服务器 OK。它其实只需要去，你只要有一些服务器反回过来 OK，我就直接把当前的这样的一个 list OOK 做一个更新就结束了啊，
30:08那这是微信现在这个这样的一个设计。其实也我我类微笑不是微信，我微信具体是行能能能能能讲下去。那我们可以大概猜出来了。它答案大概这样 OK。那有了这样一个设计之后，
30:18我们其实就实现了一个什么什么什么能力呢？那我们实际上就是说哎我每一次这个这个 plint 对吧？这个 read 的时候，就是说我这个发消息的时候，这个这个这个是比较快哦，读消息的时候是非常快。
30:30然后呢，我这个消息通过定期的这个更新对吧？也能够很快的拿到这样的一个最新的数据 OK。那这就是我们就是说大家想想看，我们讲那么多的区别，大家这个我们讲只是一种可能的这样的一个实现啊，
30:43那这个实现它背背后跟我们 centrrest 的这样一个非常简单的这样的一个实现来说，它大家想想看，它的复杂性其实会高很多。这本上就是一来源于这个数据的这个不一致的来造成。然后我们现在其实讲的只是一个非常非常简单的实现。其实在真实的场景中，
30:58它的实现会更加复杂，到后面会啊会继续涨价。对，那么有了这样的一个 think 之后，我们其实还有一个问题嘛，有 think 呃有 read 你就有 right，
31:09对吧？那么 right 在这个你在这个分布式下，其实也也很复杂。比如说我要发一个消息，对吧？我发一个消息，
31:15我把我本地更新了，本地你这个本地数据更新的并不够，对不对？因为你你这个这个你这个远端的这个服务器，它其实都没有都没有更新，那我怎么办呢？
31:24我需要去这个去把它 post 到这个这样的一个这样的一个这样这样一个所索服务器嘛。那么其实一般来说我们呃会会呃大家可能会想说，我其实我也不需要 post，对吧？其实我可以，我可以我不用不用所有服务器，
31:39我也可以去用不同的机器，让不同的机器去。但是 think 它其实会有一个问题，就是说它其实会有一些滞后性，对吧？大家想一想，
31:47所以说就是我的我我的这个数据的更新，一定得等到 think 的时候我才有。所以在厂商中呢，一般它是会用这种 post 和 think，它会以一种并存的这个方式去做。比如说 OK，
31:58我这个我发一箱，我都先往消息服务器对吧？去 post 一些信息。然后呢我一每台设设备更上市，更新的时候呢啊我或者说我连在线的时候的时候，我我去定期的去服务器这边去拉一些，
32:11像是以这样的一个这个这个这个混合的方式来做。那这个时候 post 对吧？其实会遇到我们跟这个 sink 一样的问题。就是我在一个这个那么多服务器，那么多设备的这样的一个情况下，比如说我考一个一百个人群，
32:24对吧？难道我要每一次 post 都给一百个人都都去码码？显然不行，对吧？那我肯定是得给提供呃某某一些发，对吧？
32:31其实做完就行，所以说其实在这个这个这边其实和 think 一样，对吧？为了保证我这个应用啊这个应用，它这个这个微信和类微信的这样一个应用啊，它的这个工作流失比较啊这个用用户前是比较丝滑的。
32:46所以呢不管是 think 也好，还是 right 也好， pose 也好，它的思路就是啊我要在 write 时候，我本地先更新好 OK。然后呢我去跟其他的这个设备做一个推送 OK，
32:57然后推送呢我不要求啊我的这个每个设备都更新到啊，我只需要什么一两台设备，或者说保证三个副本，对吧？三个副本的这个设备返回了啊，告诉我这个消息写出了 OK，
33:07那就好了。然后我认为这个消息息很好了。那至于其他设备没推送到怎么办也没关系，对吧？他们自己会通过这个 seek 的这个方式啊，去把这个消息给诉回来。
33:17 OK 行，那这边的话就是我们啊花那么多篇幅，对吧？我们去讲讲了这样的一个这个这个微信啊这样的一个应用的这样的一个啊比较可行的这样的一个实现，对吧？它是有可能的这个实现方案，
33:31它其实真实的实现方案啊，我们可以猜到跟这个也是大差不差。那好，那么大家想想看，我们这么一个复杂的方案啊，在设计上的目的初衷是为了嘛是为了说我的这个消息能够特别快的响应，
33:45以及我这个数据可以非常离线呃，非常快的离线的去看。但是大家想想看，我们之前啊回到我们之前讲的这样的一个例子，我们有没有可能会出现啊我某一台 s 它关注关关呃那个叫什么这个看到的这样的一个聊天记录，对吧？
34:04他是先有这个文件，再有这个引用这个文件的记录啊。 bob，他看到了这个文引用这个文件的这个聊天记录，但是他却发现这个文件没有更新上来。有没有可能有没有可能会出现这样一种情况？
34:17就是像这样一个消息，对吧？消息这个乱序的这样一个情况呢。大家想想，其实在我们刚刚那个例子里面，我们是可以非常容易构造出一个可能会出现这样的一个情况了。
34:28比如说我们举个例子，假设上面是这样一个 alice 这样的一个这个服务器，对吧？然后我们要去这个 post 这样的这样的一个请求 OK。然后呢，我们的这个 post 这个请求框色请求，
34:42然后到这个这个一到这个两有我们假设啊这个数我们微信的这个服务器有台来保证可靠性性。后我到了了一台器的时候候，写成了了。第第台台器 OOK 它失失败。因因为可能是网络络这样的一个问题，但为了我们保证应用可用性，
34:56虽然我们当一个服务器这个请求上传成功 OK，我们 alex 就认为这个文件传成功了 OK，然后他刚才就去 post。第二个请求 post 第二个请求啊，就是说哎这个请求很很顺利，他把两个服务器都更新上都更新上 OK。
35:11然后这个时候呢我们 bog 要去读数据呢，它会发起一个这个 think think。然后这个时候它很不巧啊，他只能够 think 到这个某一台，就是只写了第二条消息的这个服务器，他他 think 不到那个第一台的这样的服务器。
35:26然后这个时候他其实大家想他拿到的消息什么，他呢他就会只拿到什么，只拿到后面这个消息，他拿不到前面的这个第一个这个 pose，对不对？然后他等什么时候拿到呢？
35:35得等到他后边有一次 think 和这个这个这个这个服务器对吧？他通信到了的时候，他能够达到。但是站在 bog 的视角来说，它其实就会有一段时间，有一段时间它的这个这个这个数据，
35:50它的这个顺序其实是错的对吧？那这个其实就是一个为什么就是说我们这样一个这个分布式的这个场景里面， OK 会出现这样一个消息，对吧？顺序被 s 和 bog 他们看到的实际上是完全全一样样的这样一 case。那么这个 case 一旦出现了，
36:05对吧？对 bog 来说，它的这个体验就就是非常不好好。所以我们这边看到的一个，我们这边其实只是一个非常简单的这个 motivation 的这样的一个 case，它能给大家带来是什么事情？
36:18就我们想告诉大家一件事情，就是说啊，大家要知道你在分布式系统里面，如果你的数据有备份，然后我的这个 read right 了，我又要有很快的这个速度去返回。
36:28我不能说我得等所有的服务器都都响应了，我再返回。那么就不一定会出现我不同的人，他可能是不同的手机设备也好，也可能是同一个手机设备也好，他看到的这个消息顺序，
36:40也就是操作顺序是不一样的。那么这个时候大家想想看，但在我们应用层角度来说的话，它就会有一个问题。就是我们如果是个前端开发者，对吧？
36:50我到底要不要去处理这样的一个问题，这是一种可能会出现的问题，对吧？我到底要不要处理它？就是我底下的这个存储，我这个聊天记录系统到底会不会出现这种啊 post 操作乱序的情况。
37:03那么怎么定义这个乱序的这个情况会不会出现呢？那么我们在系统里面有一个就用一个概念叫做这个 consistent model 这样一个概念来这个这个定义这个哪些会出现，现哪些不不不出现。那具体来说的话，就是我某一个一般是数据存储系统，对吧？
37:19会告告我上上层 dedep 啊，我有哪些 consistent model，你可以选，或者说你可以选一些实现某些 model 的这个系统。然每一个好，这 modedel 定义了啊哪些操作出出现，
37:30哪些操作不会出现 OK。那这样的话，我的应用它就会去看，对吧？如果我这个你这个系统里允许出现的这种 consensent 问题啊，我的 application 能够容忍。
37:40好，那这个时候我的就选选你这个系统结束啊，如果不能容忍怎么办呢？那我就自己得去写一些 fix 的代码，对吧？比说说像这样一个例子，
37:48如果我这个应用其实很好 fix 啊，如果我我发现这个引用的消息不存在，那我怎么办？我得我再去做一次 sink，对我到这个引用的这个消息拿到哎，我其实就就就能够完成，
37:59对吧？那这个时候这个东西其实我们应用应用层其实是可以考虑的那为什么我们还需要在系统层考虑虑？因因为本质上的一个原因，很多不同的系统它都会有类似的这个的需求。比如说你聊所有的聊天应用，对吧？
38:13不管是微信也好，你这个是像小红书后面有聊天，对吧？你支付宝又聊天，它其实背后都可以用到同一个 consisuconsists model。那么它们背后我们只需要挑同一类实现这些，
38:23我们不需要把相同的这个实现啊，从可以实现很多份，然后这是一个个原因。第二个原因就是说你这个你要实现一些比较强的 consistence model，它并其实并不是什么好实现。所以我们一般来说在系统可能我们会有一些，
38:36比如数据库系统，对吧？会把这个 consists model 去实现好，然后这样用户他只需要用就行了 OK。所以说我们需要一个 consistent model l 来嫁接这个使用这个数据和这个开发人员这样的一个这个桥梁 OK。好，
38:51那么我们讲了半天，对吧？到底那到底是什么叫做 consistent model 呢？这边啊引用的是一个这个这个大佬的这个定义啊，这个 top leleft 它是写作那个 CQ line，应该 CQ server 的这样的一个作者。
39:04那 CQ server 它其实就是微信，对吧？微信叫做本啊，他不是微信，它是那个微微软那个这个微软的那个那个那个数据库的一个一个一个一个专家这个 OK。然后他其实怎么定义这个这个这个 concerst model，
39:18其实大家会想跟我们之前讲的这个这个定义其实是差不多的。它说 consumer 是吧，它还可以定了我不同的这个观测者，对吧？它对于我这个数据的一系列的这个更新，它的顺序观测上是否会有这个不同。
39:33那如果是相同的顺序 OK，那我们就认为是一个相对来说较强的这个 consensuable 的。如果它的这个顺序是不一样的啊，不一样，两个人观测出来不一样，结果说 IS 观测出来先文件再消息，
39:46对吧？然后暴露关系出来是先消息再文件，对吧？那这个其实就是一个不一致的，我们知为它是一个相对来说啊较弱的这样的一个这个 consistent model。那这边我们大家要注意一点，
39:58就是我们说 consistent model 对吧？我们说有些 consistencmodel LL 有些某呃 model consistency 强对但但是其实并不是说某一个 consistency 不好啊，它其实因为你一般来说相对较弱的这样的一个 consistency model。我们可以看到历史上是人们定义过很多 model。它有个特点，就是说那些模相对弱的 model 啊，
40:21它的这个性能就是你实现出来它会比较高效，然后呢它做容错也比较好做。那你一些相对强的这些 model 呢，它的它的好处是说，你其实对用户来说体验非常好的，它的 develop 其实它不需要去管。
40:34这里面出现了各种这个 quite case。那它的它的其实问题就是说啊，它的性能一般来说会比较差的，这个这个这个它容错做的不知道。所以说我们并没有想想说这两个到底是啊并不是说谁对谁错。而说我们说这里里它实际上是有一些脆豆腐。
40:50那如果大家再去设计对应的这样的一个系统，如果你涉及到分布式的话，那一定是需要去仔细的思考。你到底是要一个啊强的一致性系统还是弱的一些？当然具体需要我们待会会会讲 OK 行行。那么在人类的这个历史常常客中对吧？
41:07其实我们啊其实这个领域已经基本上已经比较确定了啊，人类已经定义了很多一致性的，比如像 eventual、像 cosle，像这个 seseququal、 indiditisibility，
41:15还有一个 street 啊，不知道大家有没有听过内容，对吧？如果对于上说过数据顾客，或者说啊上回也通过有些分布技础的课，对吧？
41:22大家可能已经或多或少的都听到过这些嗯这些名字。那么接下来我们要回答的一个问题就是这这些名字背后到底代表什么呢？我们肯定不会全都讲，全都讲，大概这个课时肯定不会来解，没有意义。
41:35那这个这我们会介绍一下它背后的一些共性的问题是什么？就是我们其实了解了一两个这个卡斯的 model，其实我们就只能大概推导出另外几个 del l 到底是在讲什么内容是第一点。第二点，其实更重要的是呢，我们想给大家看一下，
41:48对吧？如我们为什为什么这些 model 它是这样？其实我们可以看到的是不同的这个 model 啊，它的设计其实是为了满足某一类这个应用的这样的一个需求啊，要啊不是为了满足应用需求。要么呢它就是说因为物理限制，
42:03比如说像 strestreet consistency，是是人类能定义出的最强的这个仪器模型，但是它基本上没法实现的。那么人类目前能实现的最强的基本上就是叫做 lianzzbility 这样的一个特性。它其实结果上是等价于我们一个中心化的这样一个服务器这样的一个实现。那为什么说我这个 strict 对吧？
42:23这个东西它不能实现，对吧？ unitizzability 我们才能 forback ununitibility 对吧？这其实我们也是啊等下各位讲的内容啊。行，那我们接下来就是就去就去介绍一下是吧？
42:36就是第一，我们要看一下应用它到底需要什么样的一个一经性模型，就对于不同应用来它其实是不一样的。对吧？然后以及更重要的是我们应用需要的这个一 g 性模型，它能不能实现。
42:48我们会看有些已机性模型，它其实啊虽然应用对应很符合应用的这个需求啊，那那其实并不是特别好实现。好，那么我们的例子还是这个这个这个我们的这个大家比较熟悉，对吧？
43:00聊天聊天聊天软件，我们说现在的这个聊天软件，它其实是会出现这个顺序不一致。就是我的观测者啊，他可能会看到这个不同设备的这个聊天记录是不一样的，对不对？
43:18比如说我报告的聊天记录是这个反过来的爱 ice 聊天记录是对的。那么其实对于聊天应用来说，大家想想它是可以接受这样的一个不一致的对吧？我们还是我们说我们考察它那个叫什么考察他的需求，我们一定得先考看看他。我们要考察他要什么样的 model，
43:34也得考考察他需求。那么我们就得看一下这个 model，那么对于他来说，他想要的是讲什么样的一个 model 呢？比如说我这样就是这样的应用，对吧？
43:44这样的一个分布式的这个应用。我们说对于这个 chat 的这个应用来说啊，它其实并不需要一个很强的一个模型。为什么？因为对于对于聊天记录来说，它最重要是什么？
43:55是说我每个消息对吧？发出去要很快的发，然后我每次刷，我能很快的看到消息，对不对？但是大家想想，
44:02你有没有大家有没有去思考过，就是说我这个这个读的这个这个消息它是不是是不是最新的对吧？大家想想看，我们每次微信刷新的时候，对吧？我们有没有去考虑这个问题？
44:14其实我们并不 care 这个微信的这个消息是不是最新，只需要什么只需要微信他那个叫什么给我们有一些这个这个消息就行了，对不对？所以我们会发现在微信里面它其实并不需要一个很强的自语。比如说对于 concerread 来说，就是我每个 read 看到当前这个系统里面发的这个最新的消息，
44:36它其实并不需要这点。然后我们也知道，就是说我们我们之前讲那个分布系统时候，我们也讲过一个叫叫叫那个叫啥，叫叫叫那个呃那个 CAPD，对吧？
44:46我们 CAPDD 大家说我们虽然没有讲细节，但大家可以想象它的名字叫什么？叫 consistency availability 和 natural partition 是不能够同时达到的。那么大家想想我们前面要讲的说一个系统的这个呃聊天记录，对吧？聊天引擎它一定得有一个这个 always on，
45:00就是一直呃一直在线的那这是本账是吧？本账就是 availability。那么我这样 availability 不能达到呃， availability 我要达到，然后呢， neatal partition 是物理限制，
45:09然后我这个这个这个这个这个这个这个这个这个这个这个嗯嗯然后我我就哦然后我就然后我又想到了 consists，对吧？但想想看，这个事情实际上是不可能不可能完成的。所以在微信的这样例子里面，它其实牺牲的是什么？
45:24是一个这个 consists y level，对吧？就说我的这个它会允许我这个消息会出现乱序。但是大家想一想，我们这样的一个外需的这个消息，对用户体验来说好不好呢？
45:38比如说我的我有十台设备，对吧？登录了同一个我的聊天，然后我会发现我十个设备的聊天都是不一样的。那大家想想这个东西其实对我们的用户体验其实也很不好，对吧？
45:48大家想想我们最我我我我们平时用微信，比如我电脑登录的跟我手机登录的，他们的这个聊天记录其实大致上是相同的，对不对？所以对于微信来说，这个应用来说，
45:59它只需要什么？它只需要一点，就是我不管你在这个发消息的这个过程，你的这个消息我看到乱序啊，或者说我有些消息没到这个没关系。但是我最终看吧，
46:11最终我的这个消息都同步过来的时候，我不同的设备，它的这个聊天记录得是一样的得是一样的。这样的话我这个呃用起来它很方便，对吧？我比如说我用不管是我用电脑也好，
46:22我用手机也好，看到的是都是同一个版本的这样一个消息，对不对？所以这个基于这样一个原则，然后我们会发现或者说很多的这样一个系统啊，它所需要的一个特性就叫做这个 eventual consistcy eventuconconstency。
46:38那它的这个定义呢是说我的这个不同人，他就是观测到这个不同的这个操作的这个修改的这个顺序。但是没有关系，只要到我搜这个这个系统啊，到某一个时间节点，这个时间节点呢没有这个这个消息啊，
46:55所有所有的搜有都收到了同一个 set 的，就是就是说他他说的消息的内容都是一样的。那么我最终最终啊我给用户呈现出来的这个聊天记录。对，都是一样的。 OK 就是这样的一个简单的这个这个限啊，
47:10简单这条限制啊，它其实对于微信来说基本上就够用了。那么这个比较简单的 model 有什么好处呢？就是它只定义了这个微信的它这个聊天记录最终呈现形式啊，它并没有定义这个聊天。在这个所有的消息到达之前它的这个形式。
47:28所以说呢我们的这个用户主要是在或者说我微信的一个系统对吧，它可以选择任意的这样的一个这个数据的读取和修改。这样的实现只要能满足它的什么，这个 always on 和这样一个这个 right 这条线线，就是我们其实前面看到的，它就是这样的一个这样一个事间。
47:47比如说我的 read 对吧？我就直接把本地的就返回就可以了。这个是最快。那我 right 也是，我只要某一些 server 有 ACK 啊，有 ACCK 了，
47:56然后呢，我就就就用我这个 server 已经做完就结束了。 OK，这就是这个这个我们今天引引导出第一个对吧？就是说我们对于很多应用来说啊，它只需要保证这个这个 retiket data 是最终一致就行了。
48:09好，那么我们接下来就看看一下怎么去实现这个 eventure 考试的思想。大家可能会觉得说，我这个数据要最终一致这个事情啊，这个看上去其实比较简单的对吧？其实我我最终假设啊大家收收到的这个写都是一样，
48:25对吧？然后我我是不是按照同一个顺序，比如把它们排序，对吧？然后我以这个顺序去看看到这个 list 啊啊是实现的啊，其实其实就是掉，
48:34对吧？其实就就其实大概大大致实现一般都是基于这样的一个思想。但是这里面其实会有呃两个需要注意的这样的一个这样的一个内容点。第一个点就是说我们的这个用户啊，他他其实我们为了保证可能性，对吧？
48:49我们每个用户他发消息是我们其实会去直接在本地的这个 TIS 上去到 pro TS 上，就是这个数据上去更改，意 s 上去更改。那么就会有一种情况，就是我两个人他其实同步完的时候，同步完之后，
49:02他们虽然有同样的这个这个这个这个这个呃消息呃收发消息内容，但是他们的消息是不一样的。我们大家去看一下，那么到这个时候，到底以哪个人的这个消息的更新顺序为准，这个是我们需要去解决的这样一个内容。
49:15然后第二个其实是即使你能保证我每个人的最终的聊天记录长得是一样的。但是对于我们应用来说，有些的这个聊天记录的这个顺序啊，其实会比另一些顺序会更好。因为你大家想想，我们如果有一堆操作，
49:30它其实会有这个那个这个不是那个那个那个的排组合，对吧？你排组合它其实有非常多种显示的顺序，对不对？但是你最最不是说所有的这种显示顺序都是用户期待的对吧？所以这个时候我们就需要一些呃比较轻精巧的这样一个排序的方法啊，
49:47去让这个这个这个用户他看到的最终的这个聊天记录，实际上是用户啊比较想要的这个技术 OK。好，我们来具体看一下这样的一个例子。 OK 这个例子，我们现在先做了一些简化啊，
50:00简化什么呢？就是说我们我们我们还之前的这个 rabei icate 的这个设置啊，呃然后我们先休息一下啊，待会再下节课再说，不是出请。是是七是啊准备嘘嗯，
53:13是行。