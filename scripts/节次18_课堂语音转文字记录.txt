00:38也就是说什么我喜欢的，你现在是残差的一批，但是我还有自己形成一下。但是我觉得行，七我喜欢呃最丑就干一些，更满意一些，
03:03你就这个不行。整理我现在了大数据千里鱼什么情况？就是 OS 那个不是是是也是四川玩游戏。 HBC 还找到一批，不给不知得，然后他只有一页，
04:19第一点就只有一个才有预取。新学期，这个呢不能去，我型，没那种嗯嗯，如果我想的哎嗯行好，
05:36我们继续 OK。那么上节课我们讲到就是说你 OCC 对吧？虽然想法上很简单，但是你去实现一些里面具体的时候是有些会比较注意。比如说你在读取的时候有 ABA 的问题，对吧？
05:47然后你这个提交的时候，对吧，我们得保证一个 critical section OK。然后我们上节课讲到我们其实提交的 practical section 这个实现其实就 follow 了这个 to feace slocking，对吧？我们直接去把这个 v to i set 都打锁就可以了。
06:00 OK 那这边啊会有，然后这边 OCC 它其实没有 to feace slocking 的锁问题。因为我们有了所有的读写集合，我都知道的，所以我就可以去这个按照某一个确定的顺序去打锁。比如说我按照所有的数据 p 去拿排序 OK，
06:16那么这边就会有一个问题，我们能不能做的更进一步，对吧？就是我们虽然这个 OCC 对吧？它那个叫什么拿锁，它也拿锁，
06:25但是它拿锁的时间。大家想想它其实是会比这个这个这个这个 TVS shopping 少很多的对吧？它会比 TVS 少，但是它只有最后一个进来拿锁，但是我们觉得这还不够，因为你本身你拿锁的数量一样意味着什么？
06:36你这个 stoshoblock 的这个数量， block 只要甩开是时间，其其实其实其实跟 TV stopping 其实理论上来说没有什么特别大的这个区别。我们能不能更进一步去把这个锁少拿一点的？大家想我们在在这个 OCC 里面，能不能能不能有些有没有可能有些锁，
06:53我其实不用的啊，不用了，那我哪些锁可以不用拿呢？我们其实可以观察一下这样一行代码。我们会发现，如果大家想我我们如果这个传性 about，
07:04那这个锁拿不拿，其实不重要，对吧？关键是我们得保证什么，我们得保证你在 commit 的时候，我少拿了一把锁，
07:11它不影响正确性，对吧？我们得保证这样一点。那么大家想想我我在 commcommit，也就是我我在写第一个数据的时候，我拿哪把锁能够保证这样的一个这个我我不拿哪把锁能保证正确性呢？
07:26大家可以看到写锁能不能不拿，其实是不能对吧？因为我这边正在写，我写的时候肯定得拿着一把锁，对不对？那么我堵锁能不能不拿呢？
07:36其实我们观察下这个代码，其实我们会发现这个堵锁锁锁其实是可以去去不拿的。为什么为什么呢？大家想一想啊，我们假设一个 transaction 在这边 validate 过了， validate 过了，
07:51然后呢，完过只是它的这个版本没有变。那么我如果不拿无所它，是不是等价于我这个 transaction，在这个时候拿了一把这个这个这个这个毒锁。大家想一想，
08:05就我如果这个 verdica 过了这个事儿本身，对吧，是不是等价于我这个这个这个这个是有一把隐形的这样的一个锁，拿拿着对不对？那么其实这个时候我不拿毒锁，只要我这个 transaction compete，
08:22它其实并没有什么特别大的这个影响，对不对？大家其其实有没有发现这点？所以我们在这个 OCC 里面啊， OCC 有很多实验，它其实是啊不需要去拿这个这个读锁的。
08:36我们在 critical section 这个阶段，我只需要把这个解锁全都拿掉。然后呢，我这个时候我读锁，如果呃呃读怎么去判断它，就去是用 a boat 来判断。
08:48那判断条件是什么？判断条件是啊我这个这个这个这个这个这个有没有被改变啊？有改变。这样的话我这个锁它其实就会少拿很多啊，少拿很多。这样的话我性能其实就会变啊，
09:01但这个时候 OCC 的这个实现啊会有一个问题，什么问题呢？什么问题呢？就是如果我这个 abboss 的时候，我这个检查的时候，数据虽然没有改变，
09:14但是另一个人他恰好拿着这把锁怎么办？这个时候其实按照我们拿锁理论，对吧？理论上拿锁应该说我这个喘塞事件，在一开始前我去拿着这把锁。但是这个时候如果这个锁已经被另一个人拿住了。
09:28那理论来说，我这个这个人应该要等另一个人，对不对？但是我们如果 read 不去拿锁的话，这个事情其实是没有办法给检测出来的，没有办法检测出来。
09:39那它其实就可能会造成一些问题啊，我们可以来看具体一个例子，我们假设我们两个 transaction t 一和 t 二对吧？ OKT 一干的事情呢就是 a 加等于 b 啊， t 二干的事是 b 加等于 a 啊。两个人其实互相操作对方数据。
09:54然后我们一开始我按照我们前面的这个这个方法，就是我只拿写锁，不拿读锁，我读就用 check 来做啊，用检查来做好。我这个 t 一读了这个 t 呃两个数对吧？
10:05然后 t 二读了两个数，然后呢，这个时候我们按照之前做，我只只写只只 lock 写的东西。那么对于 t 一来说，它 lock 的什么 lock 的就是 a 啊，
10:15把 a 住后后对于 t 二就是 locked b 啊。这时候两个大家看是可以看到都可以成功的拿到这个锁。然后这个时候呢，我 t 一因为读的是 b 所以我是 vid 的 BOK。大家想想这个时候 t 一的 vdation 过没过，其实是过的对吧？
10:28因为这个 b 没有人去修改，那么 t 二的这个 vdation 能不能过，其实也能过，因为没有人去修改。好，这个时候我们最后两个人去写。
10:36这个时候大家想想看，发现了什么题，他并不是并不是正确的。为什么？因为如果你是正确的，如果你是符合正确，
10:44就是 t 要么 t 一先在前做， t 二在后做，要么就 t 二在前做， t 一在后做是吧？但是它不正确，原因是什么？
10:50 t 一和 t 二它都没有看到对方的值，对不对啊，对不对？说按照这个条件的话，如果他没有看到这个值，所以 t 一 t 二都得排在对方的前面，
10:59这不打架了嘛，对吧？这其实是不正确的，他不正确的核心原因是什么呢？是因为我这个 t 一啊，他 lock 住了这个 a 那么 t 二的话，
11:07这按正常的去 face working，它就不应该去去去 dit 这个 a 他应该等到什么应该等到 t 一把这个 a 给做完他才放。那么他为什么没有检测到这个事情？是因为现在 t 二他只检查了什么，只检查这这个 a 它有没有变。但是实际上这个 a 它处于一个上锁的状态。
11:24那么按照我们前面说的这个 lock 推导的理论，他其实也不应该也不应该做，他也应该等，对不对？所以我们如果我们要去避免拿这个读锁的这个读的数据这个锁的话，那我们在这个 OCC 里面啊，
11:40得得得做一扩展，就是我们要去检查这个这个 reset 有没有改的。我们不仅要检查这个数据有没有改啊，我们还得检查什么呢？这个数据有没有被上锁？如果这个数据被上锁，
11:50我们也得去 boss 掉。因为它也是有可能意味着说你一个这个类似 condition 没没有检查 OK 好，到到到这边为止的话，这就是啊现代的这样的一个数据库里面啊，就用的比较多的这样的一个 OCC 实现啊，它它的性能其实也是非常好的啊非常好的。
12:09那么我们总结一下，那才这个 OCC 它性能好，我怎么想好呢？它其实来源于三块啊，第一块就是它的这个 face 一啊，就它在执行这个业务逻辑的时候是非常非常高效的。
12:20因为它没有任何的价格拿锁，它只有一些这个 read set 的 check 和一些这个 right set 这个缓缓。然后呢，它的这个第二个阶段和第三个阶段，虽然有这把锁拿锁，但是它第一它拿的锁可以比 req v socking 少很多。
12:34第二就是它拿锁这个时间段会比 QV socking 短很多。因为 QV shopping，你在执行整个业务的时候，你都得拿锁。但是 OCC 的话，你只有在最后一个提交的阶段才会去拿锁，
12:45所以它其实也会很快也很快。然后第三个可能是嗯少拿锁啊，少拿锁这个东西其实对于系统的这个性能是非常重要的。就是我们可以来点一点，就是说这个不管是 OCC 也好，对吧？
12:58 QPSP 也好，我们可以去看一下它为了保证这个正确性，它额外做了哪些操作。我们可以看到在 QPSOP 里。好，我的这个为了保证正确性，
13:09它其实有一个上锁和放锁的操作。那么上锁的操作在系统里面，它一般来说至少会有一需要有一个原子的这个实现啊。因为它得拿着我们道来讲一下为什么为什么原原子。然后它这个就是说放锁，它一般来说是个写操作。
13:24那么对于 OCC 说的话话，它它对于写操作跟 QPL 一样的。但是它对于读操作来说，它其实是这个这个这个只需要多读一次就行了。因为他做这次干嘛，他去做这个 validation，
13:36对不对？那么还还还有一些本地的这个 truck，那这些其实其实是非常非常高效的，非非常非常高效。为什么呢？为什么说这样？
13:44它其实本质原因什么本质原因就是我的这个检查这个事情应该要比你这个上诉这个事情要快快很多快多，但实际在系统里面也是这样。为什么为什么是这样呢？我们先来看一下啊，看一下我们得这个这个这个这这个我们先来看一个基本的这个锁实验，对吧？
14:03大家有没有想过啊，我这个前面我们说我们所有的这个 be force 理论是建立在一个很好的抽象上。就是说哎我有一个锁，这个锁呢，我两个线程或者更多县城同时去拿的话，只有一个人能拿到。
14:15但这个事情我到底该怎么实现呢？该怎么实现呢？它的最基本的时现叫做 spin lock 啊，它这核心思想就是啊其实这个其实就是说哎我有一个 flag， OK 这个 flag 标志着说什么呢？这个锁有没有被拿？
14:31然后呢，如果果多个人去同样去制这样的一个去去去拿锁，我就多个人意味什么多个人我去尝试去改这个 flag。然后第一个改成功的人啊，自认为拿到这个锁 OK 其他人，他就他会先读一下这个 flag，
14:46发现如果哎他拿到，那他就会一直在 retry 这边。那这个就是一个基本的这样的一个 lock 的这样的一个实现。基本上但是我我得说一下，就是说拿锁这个事情，在这个系统领域里面是一个非常非常大的这个考虑者。
14:59你关于他配外，今年好像都都都我都有看到一些啊，今年看到一些这个那它核心在于这个打锁本身这个事情你要做高效，那其实是其实其实是比较难的。但是啊我们我目什么难，我们其实可以用一个最基本的 spin lock 去实现 OK，
15:15那去看一下是吧？好，行，那么大家像我们前面讲的这样的一个非常简单的这样的一个实现，它的核心逻辑是什么呢？其实就是说我的这个它它写成伪代码，
15:28就是我假设有个锁对吧？然后我就先去，我先先讲，我先去这个这个这个这个这个这个这个这个这个它我先去看一下，对吧？当前的这个 compleflag 是不是我有个 flag 标志是不是被上锁？
15:42然后呢，我上锁，无非就是我把这个 flag 啊先读出来，然后把它变成这个一零，从零变成一。然后这个过程 compare ssup 呢，
15:51基本上什么就是我去这个这个把这个值读出来，然后再判断一下它是否等于我的需要了。如果需要，我就把它变成一个新的值。如果没有我就什么都不动 OKOK，那这样的一个这样一个操作对吧？
16:03这个其实非常直接，但大家有没有想过一些事情，就本身我去实现这个 compare and sap 本身它是由多条这个指令实现的。它跟我们前面讲的这个 deposit 其实没有，就是说我们那个加起来的操作本质上没有任何区别。所以我们会发现一些事情，
16:19就是很多时候你要实现这个 lock 啊，这个本身你也得需要什么，你也得需要这个 before are for the misc t 你要让这个操作变成原子，那这个时候怎么办怎么办？我们说我们需要 lock 去去去实现这个原，但是你 lock 实现的本身也要跟自信，
16:35这个时候怎么办？这个时候其实没什么办法，你啊当然有一些非常非常复杂的这种算法能够保证，但这种算法基本上是不大 practical 了。那么现有的这个呃是什么呢？就是我们求助于硬件厂商，
16:48就是 practicc PU 啊，它给你保证你这个 compare and swap 这个操作啊，它是原子的。什么意思呢？就是如果大家写汇编的话，就会发现在在现在的汇编。
16:59比如说英特尔为例，它会有个叫做 lock preficx 啊， lock prefx。当你发起了 log prefx 这条指令之后呢，这个 CPU 啊它会把你的这个 log prefit 下面的这个总线给锁住啊，意味着说其他的 CPU 不能发起这个内存操作。
17:16好，这个时候我去发一系列的这样的一个一个一个计算计算指令啊，那个指令就会就会做完啊，就会做完。那么通过这样的一个硬件的这个方式呢，我们保证了拿锁这个操作的这样的一个原子性原子性。
17:30好，那这个就是锁的一个基本的实现。好在这个时候大家想想，我们会发现一件事情，就是我们这样的一个 complaion x swab 这个操作，作它它传统的你的这个这个这个这个内存独立操作不一样的不一样的点在哪？
17:45我里面有个这 lock ficx，对吧？它要锁总总线啊，在最早的英特尔十里面，它是会锁整个整总线。当然高级点的实现是它它现在总只会锁一些你就是你访问的那些开始按钮。
17:57现在 anyway 我们会发现它有个这个锁总线的操作操作。这个时候他就发生发现，我们就会发现一个问题，就是一旦我们要涉及到拿锁的这种 automatic 操作，它的性能就会非常非常慢。它会比你的这个正常的内存访问慢很多。
18:15这边啊这边实际上是个非常经典的这个这个这个这个图啊，我觉得大家如果做性能优化对吧，对不对？这个概念就是我不同的这个 computer 的这个操作，它的速率速度是不一样的。比如说我访问 LE cash 延迟只有一纳秒，
18:29对吧？但是我一旦这个 CPU branch 优 ase 三大大表，然后 l 二开始也只有四大秒。但是一旦啊我涉及到一个总线的这个这个 low prefex 这样的操作啊，它的声音会变成十七大秒啊，十七大秒，
18:42这个其实是会比它高了快慢了快十倍啊，当然这只是一次，如果你上所失败了，对吧？你可能要就反复的在那边 retry，那你的这个性能就非常差了。
18:53这是为什么？我们说这个在系统里面优化锁实际上是是很重要，但是有些很难做的特别好。然后你在这个你尽可能的减少锁的操作，其实对于你整个系统都是会有收益的。 OK，
19:06那么到这里为止的话，我们其实把 OCC 放在一起。看来我们就会发现你如果能正常执行下来。 commeate 的话， OCC 是个非常高效的这样的一个这样的一个这个这个这个这个这个这个闭环控制方法，因为他拿的锁是非常少的对吧？
19:22我们简单来看的话，它其实就能够啊分成这样的一个几步啊，在第一步还就是说这个这个这个这个这个这个这个执行就是我两个用户提交任意的操作 OK。没事，我就正常的把你这个数据读到我的这个本地啊记录在这个 read set 里。然后这个 read set 里面除了要记这个数据值，
19:41还得记记什么记这个版本啊，版本记完之后呢，我去提交，比如说 t 二对吧？我们会发现它的这个 AA 的值都没有人没没有人修改。所以呢 t 二它其实就就可以提交，
19:55就把这个值更新到这个 data a store 上。那如果这个这个时候 t 一他搬这的时候发现哎，它里读的这个 a 啊被这个 t 二改了，那么它认为这是一个可行的这个 with 可能 reconversion，所以呢它就把这个给 abboss 掉。 OK，
20:08那这个就是这个这个 OCC 里面的这样的一个整整体的这个执行流程。然后它里面只有在这个 commit it face 会去查一下这个 right right 数据的这个锁是非常方适 OK。那么前面讲完了，我们说讲完这个 OCC，对吧？ OCC 是一个这个这个这个非常好的这样的一个方法啊，
20:28它的这个整体的这个这个这个这个正常执行的性能非常非常好。那 OCC 啊它其实有有一些有些挑战啊一些问题。就比如说第一，我们说你 OCC 怎么判断你是正确性啊，它是通过检查是否有可行的这个 reace condition rerease contion 来判断。就是说哎如果我有一个 transaction，
20:46它 read set 对吧？被别人修改了，那么是不是啊？那么被被修改，那么我这个我就弹性我叫叫 t 啊，但是有时候啊其实并不是所有的这个 reconconnetion，
20:57或者说都一定会造成这个真实性影响。比如说我们来看前面的这样一个例子，我就是我们刚刚这样的例子。在我们刚刚这些例子中，大家还有印象吗？就是 t 二这个 a 乘以一点一是提交的。
21:09然后 t 一这个 b 等于 a 加 b 呢，它实际上是被有报掉啊， about 的原因是在 t 一做的过程中， t 二把这个 t 一的值改了，对不对？那大家有没有想过一件事情，
21:20在这个过程中，其实并 t 二和 t 一并不 t 并没有违反 COS bility。因为为什么？因为我们这样的一个执行，其实等价于什么？等价于这个 t 一在前面做这个 t 一，
21:34 t 一在前面做 t 二在后面做对吧？大家想想为什么为什么，因为 t 一在前面做，意味着它它是通过 a 和 b 原来的值去修改 b 对吧？然后这个时候 t 二再去被 a 更新，对吧？
21:44但是像如果我们让 t 一提交的话，它的结果其实是跟 t 一 t 二是一样的，对不对？但是我们为了保守的检查啊，这个这个保证正确性。我们 t 如果遇到了一个 reace connection，
21:56我们就认为这个 t 一要排到这个这个这个这个这个 t 一啊，它可能就会受到这个影响，我们就把它爆掉。那这个其实是 OCC 里一个问题，就是说我有些东西其实是没有办法去去呃没有必要去 abboss 掉啊。但是但是 abbot 所以说有一系列的这个研究啊，
22:13大家可以看前几年的这个 c bod，对不对？就就会会说，我怎么的尽可能的减少这样的一个 abot abboss 掉啊，这是这是 OCC 的一些一些问题。那总体而言的话，
22:25 OCC 它确实啊 about 的这个现象还是还是比较明显。为什么大家想想我这个一个 OCC，它到底啊 bobot 去什么？因为你的这个执行过程中对吧？到底读了多少数据？那一旦你这个喘载性做的这个东西越多这么大，
22:40它读东西越多，它其实就会啊越容易越容易去发生这样的一个 abort t bot 啊，包括 OCC。其实还有一个问题，就是说它那个会有个 lightlock，就是如果我有个喘单，
22:52就一直都被人打断怎么办？其实在 OCC 里面是没有办法去啊影响呃完完啊去改变历史的。所以呢其实关于 OCC 和 tufiace talking 对吧？到底哪个好啊，哪个好，其实是一个啊，
23:04其实很难下定论。所以说现在所有的这个保证这个 before after 的，但一般都是 OCC 或者是啊 to to feace talking 的啊这个一些变种啊一些变种。然后通常的比较方法实际上是这样的，就是我们假设 y 轴是它们的这个性能。 OK 横轴呢是你的这个系统里面有多少正在跑的这个 transaction，
23:25就是在多少少跑跑这个操作。那一般来说当你跑的这个操作比较少的时候， OCC 比较好，为什么？因为它执行的这个效率比较高。那一旦你这个操作啊这个这个这个多了之后啊，
23:37 OCC 性能会比 QPPQPQP 稍微差，为什么呢？因为一旦你 abort 掉，你这个费 c 就得重做对，你就会浪费很多的这样的一个计算这样一个时间。所以差不多这是这张图。
23:48其实当时是有一篇配文把它测出来的，我觉得是还是非常形嗯，形象的代表的这个这个 OCC 和这个 stoking king 的这样一个关系。 OK。好那么好。那最后我们介绍一下这个这个一个一些其实 OCC 它本质上是一个并发控制这个思想啊，
24:07那那它的应用的领域其实不局仅仅局限于这个 data abase。它其实很多地方，包括我们硬件的这个实践啊，其实也可能会借鉴 OK。那么我们最后介绍给大家介绍一下一个新的硬件 feature，叫 hardware 承载 memory 啊，
24:20还是比较有意思的。好，那什么叫 hardware transaction memory 呢？就是它实际上是一个硬件的这个 feature 啊，它用来解决什么呢？就是你用户啊写的这个并发程序啊，
24:30它来保证你其实就是保证 before offer。那那为什么要在硬件去实现的？因为它有个观察，就是大家想想看，我们前面介绍了 to face stocking。对吧介绍 OCC，
24:39我们发现里面有各种各样的问题需要解决 to to face blocking，有什么有这个死锁问题，有这个三层的问题， OCC 什么？你得去自己手动的管理 visual i set，对吧？
24:49然后我们还得去管理这个 brosion，对吧？和管理版本，然后我们还要去管理这个这个这个这个 critical section 这些都都比较麻烦。那么我们有没有一种办法，我就直接硬件帮你全绑定。
25:00我硬件告诉你，你这个执行执行一旦一定是这个一定是这个就这个这个背方 outline，而这个硬件就叫什么？叫做 hardware、 transaction memory 啊，这个东西呢它的好处是，
25:12第一它的实现会比你用软件自己去实现 OCC 也好，去 facesock。一般来说啊如果正常的话是要快的。第二呢，就是说它的实现是非常容易的，就是你的用户应用啊，
25:22你完全不需要考虑我这个 lock 怎么实现，我这个 OCC 怎么实现 OK 它自动的帮你保证。然后这个硬硬件实际上是真实存在的啊，英特尔在一四年的 hasword 的这个机器上去啊。大家虽然现在笔记本上可能没，但是服务器上一般都有啊。
25:37通过一个叫做 RTM 的这种形式提供。然后 arm 其实也有自己的这样的一个扩展扩展。好，那么这个硬件非常非常神奇，就是说它大家看是不是是不能解决我们所有的问题呢？其实我们会发现不是的，
25:50因为为硬硬硬硬件，它本质上来说也还是我们今天讲的这些软件的这个 proticle 的一些一些一些实现，好不好？大家可以看一下，那我们说哎这个硬件那么神奇啊，那么神奇，
26:02大家都看上去很神奇，对吧？那为什么说它它不奇？那我奇看一下他的能力是什么，然后我们得去剖析一下他这个背后是怎么实现的，其实大家都都都应该能了解。
26:11那 OK 啊，那么首先我们来看一下这个硬件是啥？这个硬件呢相当于英特尔它给你提供了一些新的指令集，叫萨时扣。然后呢，它新提供的两个指令集就叫 isx plk 和 XM 啊，
26:25这是汇编指令啊，大家可以直接去去写。然后这个指令它调用了之后，它的效果是什么呢？一开始就告诉你，你调了这两个这这条指令，
26:35然后呢，你跑一个程序，比如说你跑个函数，然后你再调个 XM。那么在这个指令中间的这个程序啊，它的执行是不会受到 rease condition 影响。
26:44就是他如果执行成功了，那就一定是 rescondition free 嘛。就告诉你你了这么的的一个限制。具具来说的话，你个用户一般使用的话，它是有以这样的模式，
26:54就是我先调一个 x again，然后调如果他返回 started 就告诉你处理。 CPU 就告诉你， OK 你进入了一个这样的一个这个这个这个这个受保护的区域，然后你就可以执行一些 critical code。比如说我们刚刚讲的这个 OCC 的这个这个这个 validation。
27:09好，做完之后呢，我用 exam 去提交。那么一旦我 exam t 成功了味味着什么？我我这代代码执行的结果一定是 restt 这些复 ing OK。在这个时候呢，
27:20如果有我这个有 restalletion 怎么办？比如说我有一个进程，对吧？我再用这个 x begin 啊这个 XM 去保护一段关键代码。但是我这中另外有一个程序，它写了我这个写了我这个读的值啊，
27:33这个时候怎么办呢？这个时候处理器会帮你把这个代码的效果给全部擦掉。然后呢，你用户会走到这样一个 else 这样一个判断，判断那个叫什么这样的一个这个这个这个执行 OK，这个就是这个基本的流程。
27:48当然你也可以也可以这个这个这个这个这个你也可以自己手动啊 out，那这个实际上是没有什么区别的。 OK。好，那么这个就是 HTM 的这样的一个使用的这个这个基本的这样的一个范式，基本上看起来是比较简单，
28:02对吧？那么这个执些时候就有个问题，它一个关键问题吧。大家讲我在这个 RTI 的时候，如果我这段执行成功了啊，那这个没问题，
28:10我这个代码肯定正确。那么问题是我执行失败了怎么办？直接失败了，我这个代码它不就没有用了吗？没用了嘛，我到底该怎么怎么做呢？
28:17因为一种方式是说，如果我这个 RTM，对吧？告诉你我这个代码跑挂了，那我可以去做一个 retry，对吧？
28:24我做一个 retry，但是有一个问题就是我 retray 了一定能成功啊，一定能一定能成功啊。它其实其实其实 RTM 呢，它又会有一个有一个非常非常重要的特性，就是它的这个或者说也不是特性嘛。
28:40就是你得你使用它的时候得知道一点，就是 RTM 它其实没有办法保证你的这个嗯执行是一定成功的。为什么它没有办法保证呢？因为很简单，它的这个 RTM 啊，它的实现是用我们今天讲的这个 OCC 来写，
28:56就是它硬件上实现了一个 OCC 的这样一些。那大家想想 OCC 这个这个实现的时候，它有遇到什么题题？一旦有一个 recoconnition，它就要 boss 要去 try，对吧？
29:07 OCC 有保证，你这个 try 一定成功吗？没有，所以你的这个 hello transaction al 一 memory 也没有，对吧？这是第一点。
29:15第二点就是 OCC 啊，它这个实现会给这个硬件带来很一些负担，一些负担，导致一个结果就是有些程序它明明没有 reconcontion tion， RTMM 下也也没法跑，为什么呢？
29:27为什么呢？大家想想，我们在 OCC 里面有一个很重要的点是什么？就是我跑的时候，我得去 track rerun set，对不对？
29:34那么你在硬件上我怎么去 track 这个？那当然硬件我不像是软件啊，或者说软件，我看上去是一个无穷无尽的虚拟内存，对吧？它实际上硬件不是你所有的数据都得在一一一些电电子原件里 track。
29:46那我怎么去串，而且我这个 track 我能用内存去 track 吗？不行，因为你一旦用内存，别的人就会看见你，对不对？
29:53所以在 RTM 它实现的时候，它是用的什么 CPU 的这个 cash 去 track 你的这个读和写的这个几何。然后 cash 实现有两个好处。第一个好处是就是我回滚的时候很方便，对吧？因为我只要不写回内存，
30:07我就瞬间就可以把这个程程序执行给擦除了。但是然后它看第第个个好处，就是我去用 cash 去 detect 的，就是 recoconnetion 是很方便的。大家想想看，我们这个有 recocondition 意味着什么？
30:18意味着说我一个其他的处理 CPU 写了我的这样一个数据，对不对？那么在现在的处理，它 CPU 之间实际上会有个叫 cascash toillpportal 啊，如果有个 CPU，但凡它写了一个数据，
30:31另一个 CPU 它是人知道的。 OK，它这个是现成的，就是根本都不需要你用这个，你没有 RTM 也有。那么所以 RTM 呢，
30:38它其实是复用了你这样的一套机制机制去做一个快速的这个 decision OK 它是通过这样的方式来实现 OCP 的。看上去很精巧很精巧，对不对？但是大家想想看，这样一个精巧的这个设计就会有两个问题，两个非常大的问题。
30:52第一个问题就是 RTM 它的这个能 track rereal set 大小是有限的。因为我们一个 CPU 的这个 catch 是有限的对吧？这边其实我们就之前做了一个实验，对吧？就是横轴，就是这个你的这个 CPU 访问的数据大小，
31:06纵轴是一个 IRSRTM 的这个访问报税。就我们可以看到当你的这个访问的数据量，对吧？如果它超过了你的这个 cathe，当时我们的这 cathe 洗澡一旦超过了好这个直接这个 ball er 率就变成百分之一百，就是说你么么 RRTM 都跑不过了，
31:24这个也很合理，对吧？就是说它其实就是说你这个这个你觉得我们 CPUU ck 不下的 US set，那怎么办？我只能只能 uphead，这就是 RTM。
31:33虽然看上去是一个这个这个很好的就把它引入的一个很大的这样的一个 overhead。那其实 RTM 还有一个很大的误害，就是啊假设我的 real al i set 恒定啊，那么我能不能保证就是说我这个 RTM 一定能稳定的这个执行下去呢？就能一定百那百分之一百值成功了。就我 real al set 很小也不行啊，
31:53我们当时做了个实验，我们发现你这个 RTM 的这个包 to 位啊，它是随着时间增长，就是我一个程序，比如说跑五五秒钟，而它的包率率比说百分之十，
32:01但是我跑十秒钟它的包包率就变百分之二十。为什么会出现这样的一个情况呢？我们发现一个核心原因是什么？就是我一个 CPU 在跑的时候，它其实并不是只给你一个一个进程。大家想想我一个 CPU 跑的时候，
32:16它背后有什么啊？有个 OS，对吧？这个 OS 它怎么把这个 CPU 的控制权给抢回来呢？它是通过 interrupt 对吧？如果 OS 通过 interrupt 这种方式去做这样的一个分时 OK，
32:27那么做这样的一个分分之后，它会有什么问题啊？大家想如果我有一个程序在做 RTM 的呃 RTM 的过程中，我收到了一个 interrot，然后呢呃不是 OS 硬件 intertrrop，然后我得切到 OS cno 里。
32:39这个时候大家想想这个硬件就很难办了。为什么？因为它有一个这个 RTM 正在跑，然后它的数据在 catch。但是呢我有了 interinteract t 可能把我这个程序给切到另一个 cero。那么切到另一个 co 意味着什么？
32:53我得把你的这个 cache 给刷掉，对不对？但是呢像 RTM，我能不能简单的把这个数据给刷掉呢？它就不能为什么你这个数据它还没有 commit，它可能会被 roll back 掉。
33:03所以这时候英特尔呢他就做了一个很简单的实现实验啊，实实现就是一旦我这个 r 键波中啊收到了一个 s counal demand。比如说 indrug 好，我就我 boss 掉了，我就默认你这个跑不了。好，
33:16那这个肇成的问题什么？就是如果你有一个操作做 RTM 做的很长很长，那怎么办？你就跑不了了，跑不了。所以呢这个时候我们就我们当时就做了一个啊比较有意思的这个实验啊，
33:30这个实验呢我们就比较了这个这个这个这个硬件时间的这个 RTM 和一个软件实现的 OCC 啊，就 cyal 赛 al 就是我们前面讲的那个 OCC 的这样的一个目前应该是最快的一个时间方法。我们就会发现对于不同的 workload 它的表现是不一样的。比如说你对于一个这个这个 workload 很小，他比如说就是有个 benchmark 叫 smallback 啊，他干的事情就是做一些银行的这个操作啊，
33:55这个 back 这这操操作，因为他就访问了一两个数据很快，所以呢他 RTM 肯定不会遇到这个呃呃 picity 的问题。然后就是 real i set 的不够的问题，它也不会遇到这个执行时间过长一些，所以呢它的性能就会比软件时间快很多。
34:08因为相比较软件，它其实它省的指令数非常多。因为我们其实不需要去维护 real， i set 也不需要去打索。但是一旦我们跑一个比较复杂的应用，比如说这个 TVCC 啊，
34:18我们就会发现 RTM 基本上就跑不了了啊，基本上跑不了。因为它这个温控线实在是太大了。 OK。好，所以呢这边啊到这边为止的话，
34:27我们其实就把这个啊简简单简单给大家介绍了一下这个 RTM。好吧， RTM 就是说就是说本质上是一个利用软件的这样的一个 OCC 的这样的一个实时实现，把它给放到了硬件上。但是硬件上它其实并不能帮你解决所有的问题，它里面还有很多的限制。
34:43为了解决这个限制，其实我们也还是需要一些软件的方法去处理，好不好？行，那那那呃今天这节课时间比较久了，我们要不就先上到这吧，
34:52剩下的钱我们下一点比较说，好不好？你不是他，那个我希望嗯，这不是对不起，像戒指。
35:28等一下，我之前地位很高兴，你那个你电脑你是不是换了个拉手啊，不是偷偷摸在勾物呀。昨天我知道**，我被那个整整整麻了，
35:52我读了一个数据，肯定都是连贵。但我一看你这个指标误分，你看好像就嗯但是你这边的话就是逻辑，然后文件掉了一个其实的。你说你说哪，
36:08我做了一个游戏回机，然后后面两个是那个一个是微博就好啊。我用的就是而且直接用这个直接那个拉手跟的拉手 CV 做穿，就不会取光，还是有个人。对对，
36:27整理无管。他相信我的最近下个月就多了，有下个月人的嗯，拉锁味巴，包括简单，你看一下就那个 s 些就有一个就这个呀也是人人那个人，
36:47我们喜用这个。对呀，为什么对我也是嘘嘘，是嗯嘘嗯，咦嗯不可能嘘，是没事，
43:32是你去。我先明确一下，就是他那次提供的就是然后所以好的就是一七年七学七年十底是整理能的影量。我我回回我的是也可以，我觉得是有无数个，你给你这里是对。
49:14对对对对，不变量就是啊让我们就是追不到我，我们一经因为导师不能听，但是没睡，我给嗯爱你对他。所以我其实什么最好是在一些工，
50:38我这个有争力把我说同步啊，要不就是我会在北京工作，绝不身体一个软件，完全不知道那个是什么原因。这是想正就是我这个是是是是关系，还有较大这一个六六 a 这一起是是就是我们这里吗？
51:59约付是不是的需要你是哎，对啊，好好好好来，我坐第二排这个是什么丝绒拿铁，我觉得觉得挺好喝的。但是我现在用的是面粥，
53:30很甜，我觉得有点甜了，可以用它们少年为这个更简单。我喝怕他们家那个就是那个椰，椰是声音吗？就是声音有点，
53:42我觉得加糖会很甜，它有点香味。为什么你在哪里？没可以，但是我要的这个大概是就这个椅子还不少很小一个。我觉得他吃这么甜应该是蛮好的。
54:06这个你太可对，这就是我用的甜肤钱。我主要是他用觉得但是太空。对对对对对对，有一事哦，我看看他躲进来，
54:33你这么消息饿，就是天气胆字一场，是不是这个东西比你你说的比好好哎。