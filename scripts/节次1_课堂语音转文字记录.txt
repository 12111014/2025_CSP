00:01对不起，根本不是我没有时间，等一会儿让我重新我们这种，我当然要去，你找比较长，这个就是这个原觉这其情加油加油加油，
00:45说的硬烦没有，能不能听不到，你让我放的那这个纯棉的，你找到吗？对我没有嗯，你这是多少回该是卖这个事情一十七了没天生存不来，
02:05***不想脸，那还有抖音把的，咱们就不给你这个他是不是你个直接问一下二，因为嗯嗯到底，然后还有什么嗯你天直接捡到，所以个老师就三月份欢迎坚持这个。
03:05好的，几点我明明白，我们那些中一年不是不行，你说的这个嗯走没有啊。对啊，你听不是啊，
04:04我不能坚果，他那个都西好，这边就这样给我们做成一家应家，都真的是。你那个发展费也是。对对，
04:45这个月你是不变变了，今天把你不愿意再看，随便的眼睛。好，我们开始上课了。今天是我们的 CSP 的这个第一节课。
05:43然后每年的这个这个时候呢，我们都要呃简单的介绍一下这个 CSP 这门课本身大概是一个什么样的一个呃这个这个来龙去脉和这个前因后果啊，我们先说一下，就是这门课的话呢，其实是这个我我刚来交大就开始上了，我看了一下以前的记录啊，
06:01从这个这个一二年就开始啊，我们就开始上这门课。这门课呢最早是呃脱胎自这个 CSECSE 的话是叫，比如说就是 engineering。那门课的话呢是 MIT 啊，它这个呃专门为了系统系统计算机系统的这个学生啊打下一个基础啊上的这个课。
06:22然后呢，他们会指出一本书叫做 computer system principle 啊，这个这个计算机系统的这个设计原理。然后希望能够大家在一些呃案例系统的案例中啊，去学习一些 principle 一些原则。但是呢那门课遭遇了一个滑铁卢啊，
06:37什么滑铁卢呢？就是不仅那门课在 emo 上面的评分非常低啊，咱们的课的话呢，说实话这个学生吐槽也很多啊，这个 MT 的学生吐起槽来比较在学生，我估计还还厉害不少。
06:50可以看一下这本书的评论。对，然后我们在把这门课放到我们自己的这个这个这个这个交大来的时候呢，也发现了类似的问题。什么问题？就是在本科的时候，
07:01上 principle 有点过早了当你还没有经历过这个系统的这个这个这个被系统这个毒打之前的话啊，想 principle 很多时候是没有办法去切身体会到它背后啊是怎么来的。每一条 principle 其实都是我们用很多教训换来的。但是很很很可惜的是，这个教训往往是必须亲身经历之后才能够深刻的去体会。这就像一个给一个没有做过大型工程的人讲软件工程啊，
07:28他会觉得为什么我要写文档，对不对？他觉得写文档是件很麻烦的事情。 anyway，于是呢我们就做了一个改进，就是我们把一些这个一部分的内容啊下沉到了这个 CSE，
07:41就是偏技术的，偏系统的啊，偏实在的不是那种抽象的原理性的东西。我们把它下沉到了这个本科生的课程。然后呢把一些原理性的课程呢放到了这个研究生的课。就是我们一开始这个这个做后来发现还是有问题，
07:57为什么呢？因为不是每个研究生啊，就上这门课的研究生都学过这个 CSE，对吧？导致他们依依然是没有太多的这个这个这个这个相关的一些切身的这个体会啊，所以呢我们又做了一些改进。
08:10我们把一部分的这个能够让大家引起呃能够能够给你在不亲身经历的情况下也能体会到的一些系统的一些这个这个这个这个内容的话呢，我们又把它给放到了这个研究生的课里面。然后再加上一部分偏原理性的东西啊，然后呢还有一些是偏研究性的相对前沿的东西。然后我们把它组合在一起，形成了我们这门课。
08:35所以我们这这课课话最终终话是希希大大形，形成两个有两个收获。第一，收获获做对一些当前的比较前沿的的，或者是就经典加前沿的一个系统，能够有一个比较呃相对比较深入的这个理解啊，
08:51就说我们嗯这个这个去去讲这个去讲这个在大大家遇到一个系统的时候呢，会知道哦，我听过啊在这个 CSCSP 的这个课程上，我们介绍过这个课呃，这个这个这个系统，然后不会觉得很陌生。
09:05而且也知道这个系统大概的一个来龙去脉，以及它背后的一些一些原理。这一第二呢就是要所谓的以系统化的思维去思考问题啊，就是最后能够把这些原则融会贯通。不不仅仅是在脑子里面有一堆这个不同系统的这个这个这个这个内容，而是要以点及面对吧，
09:26能够从中啊挖掘出一些共通的一些特性。最终的话呢变成我们大家思维的一部分啊，变成思维的一部分。这是我们这门课啊，希望能够带给大家的这个两个收获。那么今天呢我们是第一节课，
09:40第一节课呢我们就来讲一下这个复杂性与简单性啊，就是我们的这个呃可以说整整个 CSP，包括本科生的 CSP 的第一性原理就是控制复杂性。是我们说这个系统设计中最重要没有之一的这么一个这么一个要做的这个任务啊，就是这个控值复杂性，我们可以为了控制复杂性，
10:05牺牲正确性 OK 这点可能很多同学已经不同意了啊，这个后面我们会看历史上的一个争议啊，在正确性和复杂性之间，我们选择控制复杂性啊正确不断。好，接下来我们来看这个系统到底是什么？
10:20什么什么是系统呢？我们前面说了，系统第一层定义就是软硬件一个软件加一个硬件组成了一个系统，就是我们这门课里面对系统的定义。当然你到别的系统里面去，对，
10:30还有生态系统对不对？还有呼吸系统啊，有各种系统，但是在我们这里系统就是软件加上硬件，对吧？然后呢，
10:37我们需要大家了解 OS 是什么，对吧？然后这个呃 CPU 找什么样内存啊，硬盘这些基本的概念。然后呢 comilder 啊，什么是运系统对不吧？
10:47运行时，包括我们的手机上面的这个 android，它也有自己的这个运行时， javascriript 也有自己运行时等等。这些是我们本科时候应该都已经学过的这个知识点，然后呢也包括了比如说列表对吧？
10:58什么是 TLB，对吧？然后这个文件系统啊是什么？对，这个呢也是就是我们这门课会涉及到的很多的内容。我们后面很多系统的话就会围绕这些展开。
11:08比如文件系统我们就会非常深入的去介绍文件系统的设计，遇到的各种挑战。尤其是这个崩溃之后，数据怎么保证知信等等。围绕这些方面进一步的展开，包括前沿的一些研究大概是在做哪些方面？
11:23这是第一第二，就是 we to seesysystematically。就是系统化的这个思维啊，就是当一个系统当一个问题出现的时候，我们怎么去分析这个这个问题，我们要考虑哪些哪些地方啊，
11:36你这个剖析的角度是什么啊？就像一个问题来了之后，你要解题解题，需要你把手术刀把这个题拆开来 devide and conquer。对吧分而治之，然后你怎么去拆角度是什么啊？
11:48不是拿把菜刀乱切，而是说要有精细的很条要有条理的很精细的去做这个任务的拆解。你要从这个不同的属性的这个角度出发啊，这是我们这这节课会讲的十四个属性去思考一个系统，它会面临什么问题，有些重要有些不重要。
12:04在不同的场景下啊，这就是我们做的这个 system 的 design principles。 OK。那么一个 system 呢，我们再做一个具体的定义的话，就是我们前面提的这本啊，
12:16虽然评分不是很高，但依然很经典的这个教科书里面的这个内容就是 relaction set of components with specific behavior at the interface with this environment。就是说它本身一个系统的话，会有很多组组件，这个组件呢合在一起。然后呢，
12:31还有一个外部的一个世界叫 environment 叫环境。然后呢，这个环境和这个系统呢通过 interface 去做这个交互。所以大家听到系统之后就会有很多概念。比如说呃既然我要去定义系统，那么就意味着有内和外内，
12:46就是我这个系统外区这个环境，他们之间是有交互接口 environment。同时我内呢又不是一个完整的整体啊，不是不是不是一个完整整体啊，是说我不是一个全部就是融合在一起的一个整体，而是有很多个 component。
12:59比如说我 OS 有文件系统，有磁盘驱动，有缓存管理系统、有内存管理系统，有 IOS 系统等等等等。这些组件合在一起，
13:07形成了一个 OS，形成了一个系统 OK。这就是我们说的这个系统啊，它内部是有会进一步拆分的啊。然后呢比如说一个 weserver 对吧？或者一个 android 一个手机啊，
13:18它是一个软硬件，对不对？反正你文件系统的有死等等。那么这个系统呢，我们计我们这个随着我们这个计算机的这个飞速发展，它非常的复杂。
13:28比如说我们的 linux 对吧？它代码行数已经达到了数千万哈啊这个是数字不断的增加。最早的时候一千万哈，后来变两千万，变三千万，那就是四千万。
13:39然后其中列这个表原因是让大家看 linux 里面代码量最多的是什么？是 driver 啊，不是 driver，为什么是 driver 呢？大家看啊 driver 占了百分之五十六，超过一半是 driver 啊，
13:53这是 linux 的一个巨大的财富。因为它装了 linux 驱动，装了 linux 操系统之后后，很很多硬件驱动它都自了。那你不用再去写写额外驱驱动。你如果自己写一个 OS，
14:04说实话不难，但是如果你要去支持那么多的驱动，那就很难那就很难 OK。这个这个提到这个呢，我们要去讲这个这个这个鸿门克隆啊。如果大家看过鸿蒙内核的话啊，
14:16会发现鸿蒙内核跟 inux 是两套东西啊，它是一个微内核啊。然后鸿蒙内核在当时做的时候呢，其实就遇到过这个问题。什么问题？就是你写一个内核，
14:29你写个内存管理系统，你写一个调度系统啊，其实都不能说是非常用的。但是如果你要去支持各种各样的硬件，要去支持这些 driver 就很难。所以呢他们当时专门设计了一套系统，
14:41能够去部分的去兼容这个这个这个 linux 的这个这个 driver 啊。但是呢要把它排在一个额外的地方啊，因为它就它不是一个完整的一个红内核，所以呢它相当于有组件有有一些这个组件之间的隔离。但是呢它也要考虑这个问题。 OK 大家知道鸿蒙内核它作为华为的这个这个这个这个内部来说的话，
15:03其实很多驱统都是自己可控的，对不对？就是芯片是海所所有的这个 SOC 面面各各零部件，其其实都是有一定的这个掌控权和语权权。这种情况下啊，这个鸿蒙那这种情况，
15:15他不是说我这个鸿蒙内核要要要要要一下子支持所有的这个 driver，他不是这个情况，依然都会遇到这个问题。所以呢我们说这个 driver 的话，其实是 linux 的一个宝藏哈，就是它这个积累了很多很多这个 driver。
15:27但是呢 driver 也成为 linux 的一个拖后腿的一个这个这个这个部分。为什么？因为大量的 bug 出现在 driver，大量的 bug 出现在 driver。我们以前说为什么 driver 里面有 bug？其实很简单，
15:40就是因为 driver 啊，它不像 curdo 的，比如说文件管理或者是这个这个这个调度调度的话，大家想调度 leadx 调度的这个代码是由谁来写的？是写来写的那都是第一批程序员啊，上古时期对吧？
15:55九十年代的一些程序员啊，他们他们这个这个花了这么多时间啊，然后呢这么多的人力啊，然后呢这么多的 review 一次一次迭代，最后沉淀下来。在无数的设备上跑下来之后没有问题，
16:07形成了这个代码。 OK 这部分代码我们说就是属于非常 rous，基本上有的 bug 都被人找到了。如果你能找到一个新 bug，那恭喜你哈这个立大功啊，你一下子就就就就就知名度就会上上涨了。
16:23找到一个这么多人都没有看到过的一个 bug。但是 driver 不一样，比如说 AMB 出了一个新的这个 NPU，对不对？那写这个 NPU 的 driver，全世界可能也只有 AMB 能写，
16:35别人写不了。那 amd 在 linuux 上面 AMD 里面为这个 NPU 写 driver 的人是谁呢？肯定有一个 driver 的一个小分队，对不对？ driver 小分队里面他有自己的任务，比如说一部分人要写 windows 的这个 driver，
16:50对不对？那 windows driver 肯定是我们要花很多人力的啊，要要写的很好的那写的不好的话，这个这个这个广大的 windows 的这个笔记本用户，你就会抱怨，对不对？
17:00对， windows 嘛，反正开源嘛，对吧？那这个先写一个呗，然后这个这个有问题，
17:06反正大家提交 pch 就行了嘛。那任务是分给谁呢？大概率啊就分给一个实习生，对吧？说你看哎我们 windows 只要都写好了，你照着这个你照着这个 windows 写啊，
17:17然后呢写一个这个 linux OK 开源啊。然后呢我们再 review 一下就就提交了。反正他们提交呃是会给你更很更多的这个这个 feedback，咱就这么做吧。这当然就是我假想的场景啊，但是大概率啊就是是是是是是八九不离十的啊。
17:33因为开源，所以呢 driver 这部分的话呢，就会有带来大量的这个这个这是事实啊，就大量的这个驱动呃，驱区里里面大量这个这个 bug，这也是个事实。
17:43 OK，那你说你们管呢，你怎么办？你怎么办？明白不为啥？因为只有这个事实就是这样，
17:50只有 AMD 等程程序员才有有能力去写这个 driver。别人的话你又没有这个手册，你也没有更多的知识，你只能你只能够看着，这是一个现实。好，
18:03那么在我们的 linux，除了 linux 之外，大家看 mac OS 啊，其实它也是很大的对吧？ mac OS 代码行数啊，已经到了这个这个八千万行啊，
18:13八千万行。然后呢我们这个 car st way 就是一辆车。一辆汽车。它的整个的这个软件的话，已经到一亿行这个级别了。就我们今天一辆一辆车这样好的软件啊，
18:26这这张图还比较早啊，这张图这张图出现的时候还没有电动车呢啊还没有电动车啊。今天有了电动车之后啊，这个代码行数都已经肯定要超远远超过了。大家看这个是一只老鼠的基因行数啊，老鼠的基因行数。
18:39就如果我们把基因一行变成是一个一行代码的话，对不对？老鼠也才一两千行业啊，然后我们这个车已经跟一个老鼠差不多复杂度了啊。大家想想老鼠简单还是车简单，三高书还是很复杂的，
18:54希望我们还做不造出一个老鼠，那我可以造一辆车。这也是意味着我们的系统在不断的复杂，不断的复杂，而且是越来越复杂，越来越复杂，
19:03越来越复杂之后带来的一个问题，那就是人的大脑它的理解能力并没有在这么多。这这最近就比如说五十年，它没有成一个巨大的一个增长吧，对不对？人的理解能力啊，
19:18虽然我们说人越变越聪明了，但是大脑毕竟仍然有限，理解能力也有限，但是我们的系统呢却越变越复杂。于是在这带来了一个冲突，就是人系统这个复杂度的增长很快，
19:30人大脑理解能力增长很慢啊，于是呢出现了一个剪刀差，就越往后你越不理解。在一九九一年的时候啊， linux 代码函数 v 零点一版本才几千行啊，七八千行代码。
19:47到现在还有很多高校拿着那个当时的那个版本来教训大家，还是能够理解这个七千行代码每一行代码在干什么？还是能理解，今天已经已经不可能了，在哪一万倍已经不可能了，而且是越到后来越不可能，
20:00越到后来越不可能这是为什么。当时华为说我们要做鸿蒙内核啊，还是得到了很多的支持，并且做出来了一个重要的原因，就是因为 linux 代码甚至没有人愿意看啊，就是太复杂了。
20:11里面的各种红，就是你你打开一个 linux 的这个，尤其是跟硬件底层硬念相关的这个代码的时候，你发现你看了前这个五百行，可能还没有看到一行代码，为什么都是衣 fty 放人，
20:27 define up 怎么样怎么样，对不对？ if define mix， if define 这个 risk five， if define risk，三二二一都是你发，
20:37然后呢，你还没看到一行代码啊，这个前前五百行代码就过去。那你说对于一个程序员刚入门的程序员来说，你是更愿意看这样的代码呢？还是更愿意看一个重头啊，
20:47重新来把这个史战代码全部都不要了啊，重重新新一一对吧吧微微核的这个方式，你更愿意用哪一种？所这也是为什么我们说这个大家对这个词的怨是越来越多的这样一个原因。毫无疑问他很伟大，对不对？
21:00但是现实也是他确实有很就是积累的这个问题的话，也是越来越多的。好，那么怎么才能去理解那么一个复杂系统呢？就算我们重头写一个这个新的系统，随着一段时间的积累，
21:15它代码也是会越来越复杂的。 OK 这个就是我们说的这个这个复杂性啊，它是不断会增加了这一点。所以我们没有办法去通过像我们在上课的时候那样，对于每一行代码，每一行代码去读的方式，
21:30去理解一个复杂的这个系统，我们怎么办？我们就这个时候呢，就要去从系统的角度去思考这个问题，而不是从某一个单个的这个这个颗粒的角度去思考这个问题。这是一个这是一张气体的这个这个这个这个分子图啊，
21:47气体的分子的这个示意图。你知道一个分子，一个分子，它运动表征是什么？就是它的动量，对不对？
21:58动量是有方向的啊，动量就是质量乘以它的速度本身。还有一个方方向，只当我们知道一个分子的动量之后，我们就能够描述这个分子所有的行为了。但是当一个当一瓶气体里面有成千上万更多的这个分子的时候，
22:14你要去理解里面每一个分子的运动，这是不现实的这是不现实的。因为太复杂太多了。于是呢我们想出一些新的变量，去从宏观的一个角度去衡量一瓶气体里面分子的并动情况。这个变量叫做做什么？
22:32东哥上过就比较熟了，我课没上过的同学，能不能了解一瓶气体里面宏观的描述分子的平均运动状态的这个参数教育是伤伤有点不够伤啊，不算不算伤不算啊，伤不算其实可以测量的，有一个有一个直的啊温度啊。
22:54对对对，是温度啊，大家还记得吗？这个高中物理对不对？就是温度代表了一瓶气气它的内部的平均运动分子平均运动的这个这个速度。分子平均运动速率快，
23:07温度就越高，运动越慢呃，温度就越低。 OK 温呃，绝对零度就是分子都不运动了，那就绝对零度了，
23:15对不对？这个其实我们高中都学过了。好，那我的问题是一个气体分子有温度吗？有吗？一个气分子是没有温度这个概念的。
23:25 OK 只有大量的气体分子，他们聚集在一起之后，就产生了一个变量，产生了一个我们说叫 property，这个 property 就叫做温度啊，叫叫温度。
23:38好，同样以此类推，我们一行代码我们去看它的执行。我们要了解的是这个这一行代码它是怎么加载到 CPU 上啊，叫取址怎么解码，怎么去执行无写回等等啊，
23:54防存泄回这些是一行代码我们要考虑的问题。但是当成千上万行代码组成一个系统在运行的时候，你这么就不能这么去思考这个问题。同样对于 CPU call 来说，一个 CPU 扩，我们可以想代码怎么上去运行。
24:08但如果我现在有一百个空我一千个空，我们要思考的问题就不是代码怎么运行这个问题。 ok 而是别的问题，什么问题我后面会讲第三 network。当我们 network 只有两个节点的时候，要考虑的是我们怎么互联。
24:24如果有一个节点啊一个节点，那你就考虑的问题就远远不是两个节点，怎么互联的问题。同样对 web service 是一样啊，我们今天大家可以很轻松的用自己的笔记本也好，服务器也好，
24:35你买台服务器也好，可以搭一个系统出来。然后呢可以去服务。比如说啊这个这个一个学校的这个用户啊，事实上曾经有一个叫童趣啊，就是童趣。
24:49童趣就是就是鲁迅道称童趣童趣的那个童趣啊，不去他是什么呢？是一个交大的学生。在在这个在这个宿舍里面，他说哎呀这个啊你演唱会好像他说我都不知道这个演唱会，如果有人告诉我的话，
25:06我就会去了，但没人跟我说。然后他又做了一个网站，专门去收集这种信息啊，尤其是交大宜照周边的这个这个这个各种演唱会的信息。后来变成了演唱会加讲座的这个这个信息，
25:17后来又变成了更多的这个信息。然后呢，他就自己做了一个这个这个网站啊，他做一个网站，就放在交大自己服务器服务交大用户。后来还被收够了啊，
25:26还被收够了，这当然是史前的时代了啊，互联网时代的早期啊，现在然已已很很少这种创业成功的这个故故事啊，然后呢它一台服务器就可以服务整个交大，甚至辐射到华师大等等啊，
25:39周边的一些高校一台服务器。交大的 DNS 服务器就是用来做 IP 到域名啊，域名到 IP 转换的这个服务器。交大的 DNS 服务器有两台啊，一台是主的，一台是 back up。
25:52那这两台服务器其实也就是普普通通那台，就就是机器而已。 OK 没有什么特别复杂的啊。最早的时候，我知道啊，复旦这个 DNS 就是一台 PC，
26:03它都不是什么机柜里面插的服务器。一台 PC 它能够服务一个这个交大。但是一台服务器你就算能够服务交大的这个师生去做一些服务。双十一这种流量你 hold 住吗？春运期间，幺二三零六的流量你 hold ld 住吗？
26:19都是 web site，都是网网页，对不对？你幺二三零六的量级和这个交大学生的量级完全不在一个档次上，对不对？所以呢我们怎么去去控制这么大的这个复杂度，
26:31对不对？一二三零九我们做的还是很成功的，虽然开始有吐槽对吧？但现在已经比较稳定了。这个双十一每年都创新高，整个的这个 trraaction 的这个数量每年创新高，
26:43怎么做到的？好，这就是我们说系统的这个复杂性，以及这个为什么我们要去呃是什么？接下来是我们为什么要去学它呢？我们说叫 for 放 the profit 啊，
26:54 for 放 the profit。那这个是我觉得啊这个是挺挺好的一件事情，就是又开心又有收益，那还有什么事比得更好的？我想不出来还有什么比这更好。所以这个这个很多时候我们做一件事之前，
27:08你就问有没有放啊，有没有 profit，两者都有啊，就毫不犹豫的去做。第一个我们来看后况是什么？就是当我们去了解系统的底层，
27:18了解系统运行的这个复杂性。对它有这个认知之后啊，我们很多时候能够看的东西能够看的更深啊，而能够玩的更开心一点。比如说当我们对系统了解更多之后，我们能够找到它更多的这个 feature 或者是 bug，
27:35对吧？对吧？就就这不是一个 bug，就是一吧啊这是程序员最前那个时候的一个一个名言， not but the feature 是吧？然后我举个例子啊，
27:46比如说这是一段曾经真实存在的这个代码啊，这个代码呢叫做 getting pasatword 啊，它叫 check pasatforer。 check pasatworer 就是查就检查一个用户，你给我一个用户名，对吧？
28:01然后呢，给我一个这个 password，我来检查一下这个 password 对还是不对。大家看一下这代码有什么问题啊，看一下这代码有问问啊啊，就看过的同学就不要嘶剧透了啊。
28:13没看过同学可以可以看一下，不靠对吧？把这个 user 作为下标传进去，得到一个看法，然后呢做一个 for 循环，不循环什么呢？
28:26就是零到 length of 把烫点开锁。也就是我得到这 account 之后呢，这个 account 里面有一个有一个字段叫 PW，就是 paspasworword。然后呢，我就从零开始啊，
28:38到这个 password 的长度结束做一个后循环。然后呢我就一个字节呃一个字符一个字符的把传进来的这个 password，我把传进来的这个 password 和我找到的这个 password，同样的下标一个一个去做对比。如果不一样呢就 return false，如果都一样就 return 数。
28:58 ue 这样看代码有什么问题啊，一九年我一个是另外一个前缀的话，也是啊，这这这没错是还不够。是的，你要是能猜中前缀的话，
29:16其实也不容易。还有什么问题？去你的意思是我的密码，如果是一二三一二三四五六七八，对吧？然后啊一二三四五六七八，
29:32然后呢，另外一个人猜说我我输进来一个密码是一二三四五六七八九十啊，他也能过啊，你都猜中一二三四五六七八了，对吧？这个已经说明你已经猜猜中一些东西了啊，
29:43猜中一些东西还有什么问题吗？有吗？有什么问题？我也是潜岁，哪个前缀，就是它也是前缀是吧？
29:55还有吗？你看看第一个对吧？我们看这个负循环啊，看这个负循环。 PA 对了 a 啊对的 s 对的 s 对的 WA，我这是小写的哈，
30:08我这个我故意弄个小写，猜不中了吧。这个啊到这里就 return false，对不对？到 return force 看什么问题，还有问题，
30:30说空密码直接接去了空空空密码空密码，空密码的话，它是教育返回了嘛，对不对啊？你是说密码是空的，就实实际上没有密码，
30:41就那个 count 点 PW 它特别紧，然后它就不进那个过程环。那他密码是空的嘛，所以随便什么输不就那是说明他密码没设好是吧？确实你说的也对啊，就是他这个它就不进这个活循环就直接吞储了，
30:56对吧？那那空密码吧，反正随便说个啥都可以记，还有什么问题我有没有我攻击的？如果可以运行多次的话，有没有办法把这个地方拆出来，
31:13用办法猜出来？你说啊他可以一个个的试，他可以一个个的试，怎么试，我就这是我传进来的，我就从 a 开始试，
31:24对不对？如果 a 就返回了，对吧？ b 返回了， c 也返回了，一直试到 p 的时候，
31:31他这一关是过了，对不对？然后他他就可以试第二个对吧？是这意思吧，那他怎么知道这个过了没过呢？ return return 都是 false，
31:41对吧？他不管你，你第一个你试到第二个的时候， return 还是 false，一直在 return false。你怎么才能知道他猜？
31:49对，第一个第一个字符猜对了，运行执行时间，执行时间哎，执行时间。我如果第一个又错了，
31:56我可能第一轮就返回了，对吧？然后我第二个才才错的话，那我要第一个是过过第二个才返回啊，这个是一个很好的思路啊，但是这个还不够工程化。
32:06如果是用工程师的话，它不会停留在这个时间有问题上面，它会停留在差几差多长时间。问题在这个问题上面，你说我如果第一个就猜对和第一个没猜对，这个时间差多少，
32:23你给我算一下，单位可以是其他位置在搞，是多少赛道，一个参口十个赛扣一百个赛扣你选一个十个十个腮口，差不多为什么呢？因为如果第一个猜对了，
32:51那它就这个负循环多转一轮，对不对？那负循环多转一轮。大家想这段代码负循环，它无非就是检查一下 i 有没有过过，对不对？
33:01其次就是再检查一下仿一个存对吧？仿两次存在计算器里面做一个对比啊，这个就需要我们的底层知识啊。所以说整个负循环如果转一圈就返回和转两圈就返回，差不多就是差了几个塞口，十个塞口都不一定到啊，
33:19就几个塞口。好，接下来几个塞口你怎么查出来它的区别？就你怎么分辨这几个塞孔的这个差异，或者说你有没有能力分辨决赛的差异。你就运行一次，
33:35再运行一次，差了几个 cycle，就哪怕两次都是第一轮就返回它的塞扣数也不可能完全一样，对不对？它也可能差这个塞扣，所以这个塞扣数啊，
33:48你是分辨不出来的。你从工程化的角度来看，分辨不出来。我们看代码确实觉得第一个架构第二个架构有区别，但你工程上你做不出来这个区别 OK 好，怎么才能把这个差别给我做出来，
34:04把这个是把这个第一轮就返回和第二轮才返回的差别，做到一百万的参考，一百万一百万差不多我们就可以分出来啊，怎么才能让他们之间的差别可以到一百万的塞口呢？大会想了，哎呀，
34:31我记得第一轮第二轮 CPU 里面就这么运行了，怎么怎么才能有这样的 cycle 的差别。这个时候呢我们就不能只看这段代码了，我们脑子里面就要去想系统是怎么运行的。这个涉及到一些 OS 的知识，我给大家提醒一下，
34:50在 OS 里面有个东西叫做列表，大家记得吧？列表列表这个东西是什么？是内存物理内存到虚拟地址的这个映射，对不对？虚拟内地存虚拟地址到物理地址这个映射啊，
35:03这个我们是通过列表来实现。在 OS 里面的话，不是每一个虚拟地址都会对应一个物理地址，对不对？是不是不是每个逊地址都会对应一个物理地址，什么时候会不对应啊？
35:17当你内存不够的时候，你的虚拟地址啊嗯你的物地址可能被换液换走了，对不对？然后你的虚拟地址就会对应到一个空的，没有对应到实际的这个物理地址。好，
35:28访问到这个虚拟地址的时候呢，就会产生一个 foot，叫什么 foot。那这考研也要考的啊，这属于考研内容哈。这个这个 OS 基础知识啊，
35:44这个叫什么？破它叫什么过来？叫 page foot 啊，叫 page fault。对，叫 page foot。
35:57于是呢我们就可以构造这样的一个场景，就是我就开始猜第一个字符。第一个字符呢，我就让物理地址和虚拟地址呢这个映射已经建立好了。 ok 然后呢，我这个后面的这个这个这个密码就第二位开始的，
36:14后面的这个密码也是我传进去的，不对工具者传进去的，他就有意让这个密码所在的内存页被换走啊，被换走，你说怎么换走这个我们以后再说，我们先先假设他可以被换走。
36:29安卓有很多种方法，看这样的话就形成了一个场景，什么场景呢？就是这个密密密码，就是用户攻击者传进去的密码，就是 AAAAAAA 是连续的。
36:40但是呢它跨了一个四 k 的一个边界啊，它是两个页内存页，这个中间是个四 k 的那个边界，对不对？我把第一个字符放在边界的前面，后面之后放在后面。
36:53然后呢我把后面的那一页都换掉。换掉之后的话呢，就产生了这样一个效果。就是当我第一开第一个字符猜错的时候， GPU 并不会访问后面一个字符，对不对？
37:06因为就 return，于是呢很快，对不对？一旦第一个我猜对了，假设我密码就是 c 哈，密码就是 c 那么我就会访问这个字符，
37:17对不对？我开始看第二个字符，看这个字符的时候呢，就发生了一个 page force 发生 page falt 之后，处理器就会进入到 page for hhandling 就会跳到内核。从磁盘上把对应的内存加载到内存，
37:35把数据啊加载到内存，然后再去访问，这个过程就很慢，非常慢，差不多要到十毫秒。当然这个一毫秒十毫秒我觉得其实远远不止啊，
37:48就是就是这只是一个只是一个只是一个这个定性啊，不是完全的定量。十毫秒差差不多。为什么访问一次磁盘差不多就是在十毫秒，这个数量级有时候更慢一点二三十毫秒。然后呢，
37:59你发现就有十倍的差距，十毫秒也算是比较长的一个实验了啊，我们直接把它开好，一旦时间变长了，我们就可以知道猜对了。猜对之后我就开始猜第二个对不对？
38:13因为第一个我就猜对了嘛，我继续构造跟前面一样的啊，开猜。第二个这样的话呢，我就可以把一个八位的密码从原来的猜测的这个空间，从二的呃从这个八位密码应该是这个多少，
38:28二十六的八次方，对不对？因为我假设只有二十六个字母嘛，当然还有大小写啊，有五十五十二了。假设就是垂脚写吧，
38:37从二十六的八次方就变成了什么？我知道十多少次，最多就是二十六乘八对吧，二十六乘八啊，因为你二十六试一下，二十六试一下，
38:52运气最差于二十。这个呢就是我们说的叫 page foot，基于 page foot 的这个这个 timing channel attack，就叫 timing attack，就是利用时间的这个这个攻击。这个攻击之所以很有名，
39:05我们放在课上要花这么多时间去讲，是因为当年他是在虚拟内存提出来的时候，被人拿来攻击虚拟内存的一个案例啊，叫当时有一个机器叫 alex。然后呢他要用这个虚拟虚拟内存。大家学 OS 的时候都学过虚拟内存啊，
39:24说我这个不是每个内存都会映射的，有时候映射有时候会映射时间不一样。有人说哎，那出现这个问题怎么办？那当时就有一个很著名的一个讨论啊，有人写了篇文章专门攻击虚拟就是不安全哈。
39:37有这个问题在有这个问题。如果是你的话，怎么解决这个问题？我们简单简单问一下怎么解决这个问题啊，问题就在这儿了。三院 that 不能这么搞，
39:52是一个话题解决，你到底怎么去判断一个 password 对还是不对？如果你用 string compare， string compare 的实现，就是这个啊这个 string compare 的实现，大家用过 to compare 吧。
40:05对，所以你不能用寻可片，那怎么办？你用啥？我们不能只只提问题，不给这个这个方案，
40:14还是不能学会。你先你不能因味为你怎么办？我也把全都闭完全都比完，对对吧？就算就算中间啊有有全全都是错的，也比完，
40:27对吧？这是一个办法，还有吗？算一下哈希啊。对对对，算哈希啊，
40:34这个这个方法也是这个这个是目前的方法。 OK。现在大部分呢就是说你传进来个 password，我先算一下哈希，我保存了哈， password 我也不保存真实的 password，
40:47而是只是保存一个还希这样的话呢，就算我这个哈希被人偷了，问题也不大啊。当然了，你说那我猜一猜我还是可以猜出来，密码是多少？
40:56因为我可以反向通过哈希去去反推，对吧？这个时候我们就要怎么着，我们叫加盐，对不对？加一个 sort 值啊，
41:04加上随机数，这个我们就不展开了。 anyway 大家只要记住我把 password 加上哈，算一个哈希这个方法去比较啊，就可以解决这个问题。所以呢这个其实并不是一个有多么的很 mental 的这样一个问题。
41:18但这个问题很有意思，因为他告诉我们，如果我们对系统调节的多一点，我们就能够做的多一点，对不对啊，这是我们说的 for fun 啊，
41:28希望大家不要通过这个 case 去 for profit 了，这就不合法了。好，继续。这个这个也很有意思啊，我觉得国外都有很多好玩人，
41:38就是呢他这样他是说啊谷歌地图啊，就他这个这个人每次这个他家门口，他停车，包括开车啊，他觉得很堵，为什么呢？
41:50因为吃很多嘛。然后呢，他就发现他说啊，如果我在一个小拖车上面放二十九期啊，或者三十个手机，谷歌地图就会觉得我这很堵。
42:08是啊，都都在开着开着导航啊，开始导航。然后谷歌移动就会把这一段设置成红色区域，这样的话别人就不会开过来了。然后我的我家门口就可以变得非常的直接就安静，
42:20对吧？也没有人来来回回开了，这个他就他在做的事啊，这很有意思啊，很有意思。这个呢让我想到在这个美国有个亚马逊，
42:30有个仓不 eon，就是他们这个这个这个亚马逊，就是他们的那个这个这个购物网站，对吧？购物网站，然后呢在亚马逊的仓库的边上的树上啊挂了很多手机，
42:44按照树上那么挂就行，是因为你把手机放那儿。亚马逊觉得哎，你这个司机离我很近就会给这个司机派单啊，就是你在那儿挂个手机。亚马逊就会派单派单，
42:58完了之后呢，你再用另一个手机去接这个派单的这个信息，然后你就可以抢单啊， OK 这个抢单。所以呢在亚马逊的仓库边上的树上啊挂了很多手机啊，我还看过这照片啊，
43:11是密密麻麻手机啊，这他算不上人人人知知道。所以这是为什么？我们说要这个是 for profit 了啊，这是 for profit 了啊，所以你对这个这个世界它是如何运转的？
43:22底层知道的越多，你就可以啊。 for fn and profit 啊，就就讲这个再看一个 windows 十一， windows 不是十一啊， windows 啊，
43:34其实也是 windows 十一，在 windows 十一里面。如果你打开了一个文件管理器，就资源管理器啊，就这样一个窗口。打开这个窗口之后呢，
43:43你双击 f 十一，你就发现瞬间速度就变快了哈，有人在试了，对吧？你看到没有？它它真会变快一点。
43:58我还真试过。后来呢我就觉得这个有点为啥呢？为啥呢？刚刚刚刚按过 f 十一的同学都知道，就是如果你在用资源浏览器里面按一下 f 十一的话，它就变全屏了，
44:12对不对？是不是就变全屏了，再按一下就恢复了啊，其实就是就恢复到原来。那么当你变全屏之后呢， windows 就会觉得哎呀变全屏，
44:23说明你这是一个前台，而且你不会 care 周围的别的工作了。因为你看到的就是这一个屏幕了，对不对？台下就把这个自由管理器的折现的优先级给你拉到最比前台进程，而且是独占的前台进程。
44:37然后这个各种别的东西就这就优先级都往下了，就你这个优先级最高啊，它就快了。你在上面点击也好，预览也好，它就会变快啊。
44:46你发现你双击就是变快，什么都变快，就这 for fun，还是 profit 啊都可以，对吧？还有一个这个客 hanews 上面，
44:56当时报道在 linux 登录界面连按二十八下 backspace，就是就是退格键就能登录了。就就按十八二十八下退个这个 back back space 键，按一个回车就就登录了啊，你们用户名密码都不用输啊。哼为啥呢？
45:17你说这是一个 bug 还是一个 feature，感觉感觉是个对 KK 哥来说是一个挺好的 feature，对吧？但 anyway 这个 bug 已经被 fix 了啊，已经被被 fix 了啊，是因为它有一个叫 read line 的这样一个函数。
45:31他会去在读这个密码的时候啊，他会去读这个 read line，用一个 read line 函数。大家写过写过 bash 的时候，你就用过这个 read line 这个函数。然后这个 read line 函数呢，
45:40有个有一个缓冲区的一个 bug。就当你按 back face 的时候，理论上你这个缓冲区都给你删到头了，你就停住了，对不对？他删到头之后就继续，
45:48往往前闪啊，把缓冲区前面东西要把它给删了。然后呢，恰好上了第二十八个的时候，你按回它读到的东西，恰好它就能够就能够让这个代码执行错误错误到它返回一个返回一个返回一个零零，
46:02表示这个这个密码校验正确。你说这这上哪受理去，对不对？但是如果我们知道这样的 bug 的话，是不是心里还挺开心的，对不对？
46:13也掌握了一些没有什么用的东西，当然还是很有用的啊，还是很有用的。好，我们再来看 for profit 啊， for profit。
46:22我刚刚说了，其实这个也说了，其实这个就是那个亚马逊亚马逊那个什么边上的树上面的手机哈，这个就是一个比如说他们去抢抢单的一个一个一个点啊，这个还被 blonberger 还当时还报道了啊，就是说这个亚马逊啊，
46:36你们哎被人被人利用了，对不对？好，这是我们说的 for pass fun property。好，接下来呢我们就要去更系统的去讲一下这个十四个 property。
46:48什么叫十四个 property？就是我们前面说的当一个系统复杂到一定程度之后，我们怎么去测量它的数量。或者说像气体复杂之后，产生温度一样，一个代码，
46:59一个 CPU 数量，一个这个呃网络或之间互联的这个节点数量，它增加到一个非常大的数量级之后，它会涌现出哪些 property。我们总结了十四个啊，不是说他就是只有十四个，
47:12而是我们总结出来十四个啊，也许将来有一天他就会多一个啊，有可能。但是目前看下来的话，这个十四个是哎是比较比较比较有意思的，十四个，
47:22那也是被认可的十四个先来看，第一个就是我们说的 correctinss 啊， practice 很重要，对吧？这个就不用想了。但是呢 correctness ss 本身也很难定义啊，
47:33我们刚刚一直在调侃说 it's not a bug， it's a feature。这句话还真是啊，这个曾经出现在互联网上，最早的时候就是这个地方啊，就是就这个就我们说这个以前玩那个玩游戏是 yes 防控，
47:51你们都没玩过啊，你平常玩吃鸡对吧？反恐 CS 里面的话有一个叫甩枪啊，不知道大家有没有知道什么叫甩枪啊，所以啊甩过没有甩狙对吧？虚甩，
48:02然后呢他就可以打一条线，一条线啊，就是你甩了之后，这一条线上面站好几个人都被你都被你干掉了啊，所以那个时候呢就很多人就就是甩去变甩去。后来 CS 说，
48:16这是一个 bug，完了废死了，遭到了无数玩家日益苦练甩狙绝技的玩家的抗议，说你要把这个给我加回来，结果他们又真加回来了。那这是一个典型的 feature bug 之针对吧？
48:29啊 feature bug 之针。好，然后呢这个这个这个代码啊，这个代码大家看有没有问题啊，有没有问题？一首 bug 很有意思，
48:40这里有一个这里有一个八分儿，我们画一画啊，画一画有一个八分儿，然后呢，这个是 buff，这个是 bus end。
48:53对吧这两个指针啊，这两个指针它是这个叉尔星的这个指针。然后呢，有一个 lance 什么 length 呢？就是当我 buff 加 length，比如说从这开始加了一个 length，
49:10 buff 加上 length， buff 加加如如果大于这个 lengbuff and 加到这了，说明什么？说明什么？超过他了就是吧，说明你太大了，
49:26对不对？我 buff 才一百二十八，你要给我一个二百五十六，那我就那我就返回错误不行？还有呢就是 buff 加 length，小于 buff，
49:34就 buff 加上这个之后啊，它这个到这儿来了，小鱼呢，小鱼 buff 嘛对不对？小鱼 buff 为什么会这样啊？很好啊，
49:46这个溢出啊，就基本功还挺挺扎实的那当我们加两个数之后，你如果超过了这个这个这个数字的表达方式的话，它就溢出了，溢出就到头上就变小了。你把一个很大的一个数加了之后，
50:02再打不了再受不了，这样就是吧这要代表什么问题呢？这要代表什么问题？所以说你嗯志愿代码这个程序员写了之后，他为什么这么写，还不是因为就发生过这种问题嘛，
50:34对不对？八分一出来没判断，结果呢就导致了错误。然后呢，他又加了这段代码，说你看我现在这么写，
50:44你一定是落在 buffer 加 length。就是这个八和和八分量之间不可能超过小鱼就是对的。超过或者让我都我都考虑到。然后他把这个蛋白质提交提交完了之后，发现怎么问题还在呢？但是我骑着代码还是会发生这个 buffer 加死小于八，
51:05我就觉得溢出这个问题。那这程序就很苦恼就很苦恼。然后呢，他就怎么想才想不明白，就这么点代码，为什么就检测检测不了他的这个问题，
51:19他实在没办法。之后呢，他就把自己的是编译出来的二进制啊，反馈编了一下，反馈编一下，发现什么呢？
51:26发现压根就没有这个代码，对应汇宾 OK，那这很很就很奇怪，我写的代码怎么被吃了啊，被吃了。后来呢他就去专门写这段代码，
51:38我就只只写这段代码，我用 GC 编一下，发现编出来一个空的东西，什么都没有。他说有问题啊，有问题，
51:46于是呢他就写了一个写了一个邮件给 GCC。注意啊，这是二零零七年一月十五号的真实案例，写了一份，说你你你你你这是个 major security issue，赶紧给我改。
51:59然后呢，这个 GCC 的人呢亮出了 c 的 speack，说这个是 c 语言的 specistification。你去好好的学一下 the c program language 这本书。在这本书里面说到一个问题，就是当一个指针加上一个常数，
52:14发生了溢出之后，叫 point over overflow 叫 undefined behavior。 undefined behavior 说明什么？你压根就不该这么写代码，指针的溢出是 undefined behavior。 undefined behavior 意味着编译器可以采用任何方式去处理，
52:30包括什么都不干。 GCG 的程序员说，我们不处理，就可以让这个性能变得更快一些。生至代码少了吗？执行的少了哦，
52:42更快，所以我们选择不处理。哎呀，把那个程序员给气的直接，你看在这在在骂街。然后呢，
52:49 GCC 的程序员说 GCC 不会改变， is not going to change。这是一个 undefined 啊，你代码自己有问题，别怪要。所以呢我们就说啊程序员其实挺郁闷，
53:01为什么程序员挺郁闷？因为很多程序员都这么写代码，哈他就这么写代码。那其实呢你你把这个改一改，你把这个把这个 bus 啊强制类型转换成一个 on deline，这个这个 on line 的这个 int 哎，
53:15就可以了。因为 online int 的这个溢出，它不是一个 undefined behave OK。所以呢正确的一个写法就是把这个 ff 前面加一个括号啊，把它变成一个 online int。但他如果这么写就是有问题，
53:31 OK 大家看出来了，没有如果没有看出来啊。你要想很可能在我们的大量的代码里面都会产生这样的这个债务。他也许就偷偷的就被译器删掉了啊，你都你都不知道啊。所以呢我们说这门课会带给大家一些焦虑啊啊，
53:50就我们生活在一个什么样的事件不改啊。好，我们休息一下啊，休息一下，我们休息到五十分吧，好不好？
54:04五十分啊，五十分稍微早一点，不要那个嗯从来不你就是。如果生活的中要如果你不说，还把拿的手子，它是去年秋季的头产的的年趋势。
54:32不是你在想你有没有一边是查烧竹，你放的么？熟猪不是还还好吧，没什么意思，我一直所以我对不起了。我上回那别来，
54:48北京也好吃的，都是在你说可以啊，反正也没意思，一年一年给吃，我饭就不吃了，你们那不如我们家努力不服。