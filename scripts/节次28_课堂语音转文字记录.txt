00:01意思哎是喂哎，没事，是需要多久？如果是嗯对我我觉得还是要不能那啥不能拍太熟。对，还是要再再宣演下下，
02:51不行行好，我们要上课了。好定是嗯嗯嗯是是嗯怎么开始？好，我们学习中带来的这个已经感觉学习墨迹啊，让我们这个人数层有下降趋势，
05:57到最后一节课能会再上升一点。因为我相信大家很多都是在线上看过吧，也不是这个这个也不是别的别的别的原因。好，然后人少呢，我们也可以讲的更加的更加的轻松一点啊。
06:12然后大家有问题也可以随时随时打断我们研究生上课。很多时候更多的其实是希望一起有一些这个碰好，有一些这个焦虑性。好，我们今天讲 topic 是这个 system graattualization 啊， system gratradiation 是一个非常经典的 topic。
06:27在我们整个系统里面的话呢，应该说经历了一个很长时间的发展。早期的最早的这个系统的这个虚拟机，最早最早的时候是在一九大概六千到一九七几。当时呢为什么要做虚拟化这个东西呢？是因为硬件太贵了，
06:45硬件太贵了。然后这个这个有很多这个呃说这个系统早就是超系统开发人员，他们要去登录到一台非常大的大型机上面去。然后呢，一旦出了问题呢，还要重启啊，
07:00这个呢就直接导致了这个系统的这个呃整个的对把这个像你们一样的话，就克制把你录上。导致我们整个呃开发人员的话呢，他如果如果说他想要去呃有独占一台系统，独占一台机器对吧？然后去做这个整个的这个呃这个这个开发的话非常昂贵。
07:32那时候一台机器大家想要就几十万美金，而且当时的美金比现在的美金也不一样。好，那么为了避免这个问题的话呢，呃就开发了这个虚拟化。有了虚拟化之后呢，
07:43就可以开发人员就可以有一台独立的虚拟机啊，在里面去做开发这个 OS 方面的工作啊，重启啊什么的，也都不用过于担心。所以呢就这是我们这个一九七十年代、一九七零年代的这样一个这个虚拟化的这样一个工作啊，
08:00虚拟化的工作。然后在这样的一个这个形式之下的话呢，我们就我们说一个非常重要的一个呃这个虚拟化的需求。就是这个虚拟机和这个真机必须是完全一样，不能有一点不一对吧。另外如果有一点不一样的话，
08:18那到时候开发的时候的话，可能就会有很多这个这个这个你虚拟相跑的好好的，对吧？虚拟项你不能跑。那后来的话呢，随着这个计算机变得越来越便宜，
08:30我们微机技术发展之后的话， PC 成为了一个主流。我们的这个整个的计算机啊它变得很便宜了，所以呢这个事儿就不是事了了。大大说说我一台机器不够够，再给你单独造一台本人很便宜，
08:43对吧？开发有专门的开发机啊，卖出去和专门的售卖的机器啊，然后呢这个虚拟化技术就渐渐的就就不研究了哈，就不研究了。然后等到一九八零年代，
08:55包括一九九零年代，基本上没有人研究这个循环啊，就跟这个说是这个深度深度学习一样，对吧？曾经有二十年啊都没有人去 care，直到什么时候呢？
09:06直到这个 wem where 的总裁 stemer 的这个 mandia 罗瑟姆鲁文教授，他是副教授，但他是美国工程院院士。所以所以很多时候我们看到这个经常我们会说这个最近院试评选刚结束啊，这个副教授有没有可能当院士呢？里面也是有的，
09:26就是你只要开公司就行了，开个 VM where 这么成功的公司。对吧然后他可以上美国工程院院士，然后等到这个 manor ro**lum 在一九九九年的时候啊，写了一篇论文，把他们当时做的这个技术啊，
09:38把它给呃给公布出来啊，就是这个 meanware。 meanweare 呢它是一个基于 bunerary translation 的这样一个系统啊，这个 binary translation 的作用就是把整个呃要跑的这个镜像，包括 OS，包括上面的应用程序，
09:52全部都把它给做一个呃做一个二进制二进制动态的一个转写。从而啊能够把系统才能运行的一些指令，也能够运的运在用户态。这样的话呢我就可以在用户台跑多个呃这个操作系统啊，可以在用户台跑多个操作系统，这是我们说的编位。
10:09他当时做的这个工作，他当时的白领选择选应该是整个世界上最先进的啊，速度非常快。后来我们知道 q 啊等等这样一系列的工作就出来出来了。开源的工作啊，工作一般都是希望闭院，
10:22对吧？然后呢，这个开源呢就哎这个闭源可以做，开源也可以做，就就这样一条路径。好。
10:28然后呢到了九九年的时候呢，这个 VMV 之后大家发现虚拟化特别有用，为什么有用呢？这个开始呃原因很简单，就是我们很多时候这个希望能够有一个环境啊，它不受别的环境的干扰。
10:45我们很多时候在装一些系统，装一些包的时候，都会有这样的一些问题。你装了这样一个库，装了这样一个包别的应用程序可能就冲突了啊，我这个库呢我这个应用程序需要一点二点一，
10:58另一个库需要一点二点三，两个两边去打架，这个很麻烦。所以如果我们有虚拟化的话呢，就可以解决这个问题。当然今天大家会觉得啊，
11:06我们有 container，没有容器，我们不需要虚拟机了。但是在当时看来的话呢，这个虚拟化是解决这个问题最简单的一个方法。尤其是啊这个如果对 OS 的这个版本它有要求的话，
11:18那更是更是这个非常重要啊，对于这个虚拟化的需求来说的话更是非常重要。好，然后就虚拟化的第二波浪潮就起来了啊，第二波浪潮起来。第二波浪潮起来之后呢，
11:34我们说这个呃很多很多人开始写虚拟化方面的论文。为什么呢？因为这个互联网泡沫破裂，互联网泡沫在二零零零年左右破裂之后的话呢，呃有很多很多的这个这个这个这个这个云计算这个中心啊，他们有大量的服务器买了服务器，
11:52但后呢用不完啊用不完，然后呢公司又没钱租不起啊，怎么办呢？他们说能不能这样，我们把几台虚拟机合并在一起，对吧？
12:01比如说啊五台或者吧台合并在一起，合并在一起之后呢，我们就卖给大家。我卖的是虚拟机，我不是卖的物理机，这样的话五台机器可以卖好多个，
12:10这样我就可以把这个价格降下来了。这个这个闲置的服务器也可以得到利用，然后呢也不至于降价太降的太狠，对吧？就单个单台物理机来说的话，价格还是差不多。
12:21但是我拆成这个虚拟化卖出去的话就方便很多。然后呢，很多互联网企业那么倒闭了，或者说陷入了财务危机。没有钱。没有钱的话呢，
12:30他用以前的三分之一的价格去租服务器还是租得起的啊，你让他全价就租不起了。所以呢当时呃整个的这个业界的话就开始流行这个虚拟机啊，然后流行虚拟机的时候呢，呃这个虚拟化技术就开始产生了。为什么大家发现我一台服务器我只能够跑，
12:47比如说三台虚拟机，那显然就很慢又很亏，很浪费钱。所以呢大家想我能不能够多跑几台跑五台十台，甚至要跑。当时呢就有一个项目说我们要跑一百台一台服务器，
12:59要跑一百台虚拟机。当时这个项目呢，就是这个啊就是这个钱。当时是这个呃，在 cambridge 啊，也是大学首先提出来的。
13:10后来在英国的这个呃谷歌，包括一些服务器厂商，都对这个项目有所支持。所以他从一个纯学术的一个项目，就慢慢慢慢的就变成了一个工业界支撑的这样一个项目。这就是我们说的这个这个虚拟机的一个呃零三年二零零三年的这样一个这样一个工作。
13:30这个工作当时叫 then and the art of a virtualization，你再跟他说。对，然后一旦提出来之后的话，从工业界角度来看的话，它会变得非常的流行，
13:42为什么呢？因为它可以在一台服务器上面跑一百台虚拟机。当然了，这个实际上没有那么夸张，但是十几台或者几十台还是可以跑的。然后呢，
13:51它就显著的使得采用这个技术的云服务器厂商比不采用这个技术，云服务厂商的成本要降低，对不对？价格反而还降低了，就是它成本降低了，价格也降低了，
14:04就可以吸吸呃吸收更多的这个这个客户。所以大家开始竞相投入到虚拟化的这个研究中，产业界有大量的资金都铺在虚拟化性能提升，以及这个这个 o en head 的降低。这个实际上所以呢包括像英特尔芯片啊，就做芯片的这样一些厂商也开始讨论我怎么样才能够更好的通过芯片上的一些特性来支持这个这个虚拟化。
14:29因为需求实在是太旺盛了，当时呢就产生了一个会啊，叫这个专门为为了这个虚拟化诞生了一个 compress 叫叫 visualize execution environment 啊，叫 visualize exexcution environment。那这个会的话也是每年一次，然后每次都会收到啊，
14:47非常多的这个 paper 大家都要讨论，为什么？因为传统的会议它不是专门讨论虚拟化啊，也有一些比如说像 SCSSP，包括 s prss，都是有有一些这个讨论。
14:56但是呢没有太多了啊，研究生要讨论论文太多了啊。当然了这个多跟今天的 AI 比起来，都是小蔡啊，大概就几十篇文章啊。然后因为传统的系统方面的这个论文啊，
15:07本来就说的很少，然后呢，所以就加了一个新的一个会叫叫 BE。然后等到有了 BE 之后的话呢，我们说这个 s boss 从两年一次啊，我们的 s boss 从两年一次变成了一年一次啊，
15:20就是因为这个虚拟化太热门了。对，这也是我们说这个其中的一个这个体会，对吧？两年一次变一年次。然后当时当时同期同期的还有另外一个工作叫做 transactional highry 啊，
15:36呃 highway transaction、 memory ory 啊，叫硬件的事物。新内存当时也是一下子起来非常的火啊，这个火到大家都在做，然后呢讨论的人非常多。
15:45所以呢这个 h 斯呢他本来就做软件协同的方面的工作啊，然后呢他就从两年一次变成一年级，那我们还是比原来还多啊，所以我们可以看到研究界它其实是有一个周期的啊，然后呢等到 actumemory 这个浪潮结束，等到 organization ation 这一波研究结束，
16:03那这些会就会会慢的就会人数就会减少。当一个会的人数减少到很少的时候，就没人投了，对吧？那他就结束它就结束了啊，就就会关掉啊，
16:13就会关掉。所以所以我们现在看到 AI 现在有这么多的人在投，对吧？然后那这也是有一个周期的一个变化。然后 topic 来了之后发，他发现大家在这个方面的努力能够迅速获得成果。
16:26我们就会在这个 conference 上面有大量的投入啊，投论文的人也多，审论文的人也多，看中的人也多啊，企业很重视你们就可以。将来在这个找工作的时候发现啊，
16:36我有两天这个 paper，这个这个这工作工资就可以高得多，对吧？这个确实也是一个现实，所以呢大家就疯狂的往这个 converrence 上面去投。但是 conforrence 是有周期的。
16:47大家的研究生的生涯一共才三年，博士生五年最多六年，或者再多一点啊，希望不要那么多。但是在这个过程中，不一定能够经历起一个完整的周期。
16:56比如说这个虚拟化，虚拟化从开始就是这一波浪潮，从真正的开始做起来，从两千年左右的时候开始做起来，一直到它终结。什么叫终结呢？
17:06就是在二零二二年啊，这是最后一届啊，最后一届啊，这个这个开完就就关掉了。这个会对这个我我很不幸的，或者我很荣幸的成为了最后一届唯一的这个这个 PC chair。
17:21这个在我组织完这次会之后，这个会就没有了啊，让我非常的伤心。对啊， anyway，这是一个这是一个这个这个这个循环，
17:31或者说是一个周期啊。然后直到等到研究的差不多了，没有什么问题，或者说有别人更重要的问题要去研究了。那么相应的研究者的数量就变少，所以没有什么是持续的啊，
17:45没有什么选择。但它 b 已经五十多年了啊，已经半多世纪了啊，然后其实还是不断在做，也是用 OS 一直持续不断的有一些 topic，但也不是那么的多。
17:55 AI 的话呢就就就不一样，对吧？它一下子就可以起非常非常的量。因为它它它的义义相关，很多时候它的这个得到的产出的话，其实效果是更是是是是和和系统。
18:05这一层的话是呃很多时候不是在一个量级上。但是从深度上面来看的话，我们一般认为 OS 上面的呃这个所采取所取得的一些成果的话，相对来说的影响力会更大一些。比如说我们举个例子，今天我们所有的服务器都没有之一啊，
18:21比如说大部分吧，也不能说所啊都是在用这个虚拟化这个技术。当然我们有 biametal，那 bebionetal 也是一种这个这个这个这个也可以我为虚拟化技术的一个延伸。因为它有些 l 方面的虚拟化依然依然也是用好。那今天呢我们就来来在这个回顾一下这个虚拟化在从一九七零年代到二零二零年代，
18:45就五十年来这五十年它的这个发展，它的这个变化 OK 啊，它经历了两次这个兴和这个衰啊，到今天总的来说呢是已经变到一个非常稳定的这样一个状态。它中间发生了一些什么样的一些事啊，有什么样的一些技术，
19:02然后呢能带给我们什么样的一些启示。我们先看这个虚拟化，虚拟化呢其实呢跟 excstrution 有一个非常类似的一个这个这个很多时候会被人会被人串在一起。初夏和这个 vieralization 这两个词的话呢，其实是呃很多时候是很像的对吧？抽象我去一块，
19:36那么他们有什么什么样的共性呢？他们的共性就在于说都是在一层，下面上面又叠加了一层啊，一层上面呢还可以再叠加一层啊， exstruction 和虚拟化都是一样的。那么我们说计算机里面就是说但凡要解决任何问题，
19:51我们其实只要轻加一层 indirection 就可以了。那么 abstrtion 和 vtranslation 都是我们加 indirection 的方法，那么它们的区别是什么呢？它们区别就是 appstraction 是新接口，新接口，然后这个 appllaation 呢是旧接口，
20:13这是他们最大的这个区别啊，最大的区别。什么叫新接口？新接口就是以前没有这个接口，我用一个新的接口，比如说文件系统，
20:20文件系统我们以前讲过，对吧？还有 open rede， right 就 close 这样的一个一套接口。那么以前是没有这个接口，在文件使用以前啊是没有这个接口，
20:30我们拿了一个硬盘，它就是一个这个这个 put 和 get 啊，就是你拿某一块 bck 或者是写某一个 ppro，就这两个读写操作，那文件系统提供的新接口，而 virtualization 呢则是用旧接口。
20:45什么叫旧接口呢？就比如说我现在有一块磁盘，然后呢，我要在这个磁盘上面用一个文件去模拟一个，或者说去假装是一个磁磁磁盘，假装是个硬盘。
20:59那这就是我的 tradition，那为什么我要把一个文件假装成一个磁盘呢？那肯定是因为有一台虚拟机对吧？我一个虚拟机，它的硬盘就是有件啊，它看到的是一个硬盘。
21:10但其实从我们物理上去看的话，它其实就是一个就是一个这个这个这个文件。换句话说就是它在文件的接口上叠加了一层磁盘的接口。 OK。这样的话，对于虚拟机里面的人来说，
21:23就可以用这个磁盘的接口再去提供一个文件系统的抽象。这是我们说的这个 vieriation 和虚拟化啊，这两者的一个一个区别。好，那么既然提到这个区别提到这个接口，我们接下来就是说那虚拟化它是要虚拟化哪一层接口？
21:39就当我们谈论虚拟化的时候，我们的第一反应是我们要做哪个？这个在每一层在每个接口去做这个虚拟化。如果我们的应用程序是一个 hello world，也就是说我现在手里有 hello world，我要把它抛起来，
21:55那我要在虚拟界面跑起来，那我需要在哪一层去做呢？我们说来我们来看，如果我们是在 hello world 要去把它跑起来，我们应该在每一层去做这个做这个虚拟化啊，是 API 这一层还是 ABI？
22:20这个这个 hello world 是 c 写的，假设是 c 写的啊，是一个 c 选讨论。我他应该是在 API 这一层，还是在 ABI 这一层，还是在 ASC 这一层。
22:30 APIBISA 大家文科时候应该都已经学过了，对吧？ IC 肯定都学过啊， API 都学 ABI 是是什么？叫 application binary interpreace appapplication binary。它有包含编译器在里面，
22:44包括传单啊、 policy， policy 都在这一层序去约定的对。那我有一个 c 写的 hello word，它应该是在每一层都是做虚拟化的。大家觉得 API 还是 BI，
22:54还是 SC，还是 b 你说呃 ABI 在 ABI 这一层非常好啊。 ABI 这一层为什么在 ABI 这一层呢？因为它是它是个 banmarary 嘛，对不对？我现在手里有个有 c 文件，
23:09我有 c 文件的话，那我肯定是要在个 banary 这一层啊。当然我这里有其实有个前提啊，这个前提就是我是用静态编译的方法编译的对吧？我所有的库的放在一起，如果你给我一个 hello word，
23:21然后呢再然后然后说 ABI 这一层兼容，但是呢他最后库什么的都是动态链接的。那那个时候那就你你还要你还要去为他准备对应的库，对吧？为他准备对应的这个这个这个这个系统里的后续支撑呢，那就会复杂一些。
23:38近代边译的话就没有问题，所有东西所有的代码二进制都打包在一个文件里，就没有问题。好，那我再举个例子，比如 dota、
23:48 dota，我如果要跑的话，跑哪一层？这个也举个举个例子啊，就是我们以前这个这个这个就是在在 linux 上面去玩这个 CS 啊，然后呢也是可以玩的。
24:01但是我们要当时要用一个叫 YM 的这样一个虚拟机，对吧？ YM 这样一个虚拟化层啊，然后呢这个 y 你就可以帮我们在 linux 上面去运行所有的运行那个上面运行所有 windows 东西。所以它叫它其实叫 windows emumuator 啊，就 windows 一个位置来。
24:23然后呢，这个就就能够去跑各种各样，包括魔兽啊，什么都可以在上面跑玩，非常神奇。当时我们觉得哎呀，
24:29这个 linux 本来我们只是用来写代码是吧？用来用来写写写写写程序写作业的。然后呢发现这个哎还可以跑跑游戏哈，就一下子就打开了新天地了啊。但不过不是很稳定，有时候会崩掉，
24:42但现在越来越稳定。然后呢，如果我们要跑 office 也是一样的啊，我们可以在 linux 里跑 office office 吗？当然是可以的，前提是我们得在那边跑 UI，
24:50都是在 ABI 这一层去做这个呃做这个兼容，或者说做做这个虚拟化啊。那反过来来，如果要在 linux 里面跑一个 windows 八，跑一个 windows 八或者 windows 十啊，或者 windows XP 啊，
25:02一个很古老的软件。那我就不能在 ABI 这一层了，我要在 ISA 这一层，为什么？因为 ISA 这层包含了 system 的 ISA， system ISA，
25:11就比如说换页表这些套的话呢，都是在 syst YIC 去做的。所以呢在 windows 里面显然它是一个 OS，是有有有它自己的 current。所以呢它肯定要在 ISC 这一层去做这个虚拟化，那才能够好得起来。
25:26 OK，这就是我们说的这个当我们讨论讨讨论虚拟化的时候，我们的第一个问题就是我们到底在哪一层去做虚拟化。好，那么虚拟机在什么地方呢？当我们谈虚拟机的时候，
25:45我们的第一本就是哎我们就在这，刚才我说的在 ISA 这层，对吧？在 ISA 这层，把上面所有的整个这一块全部都虚拟化出来，包括 system SA user SA 两大类，
25:56 OS 也可以跑，应用程序也可以跑。这是我们说的这个虚拟机啊虚拟机，但只有这一种虚拟机吗？注意我们今天讲的主要是这种，主要是这种。
26:07但其实谈论虚拟机的时候呢，它其实有很多种不同的这个分类的这个方法。比如说一个经典的分类方法，就是这个 process VM 和这个 system VM。 process VM。就是我用一个进程啊，
26:21用一个进程去虚拟一个这个这个这个呃虚拟一个虚拟机，看哪去去实现一个虚拟机。还有一个呢就是我是去实现一个整体的一个虚拟机，而不仅仅就是用户态这一层。好，我们来举个例子，
26:37比如说这里有一个 process VM，对吧？然后呢，这有一个叫 CMSA 和 different SA。 CMIC 就是我用 windows 去虚拟 windows， different IC 值为 windows 去虚拟这个 r 啊，
26:50那就说为什么要用 windows 去虚拟 windows 呢？很多时候它是为了去做优化啊，就会做优化。就是说我们一段代码，然后呢是用 x 八六去编的啊，编出来的是 x 八六的代码。
27:03然后呢，我这个虚拟机呢能够把你这个 x 八六动态的翻译成 x 八六。你说 XY 六为什么要动态翻译成 XY 六呢？是因为它可以在翻译的过程中去判断哪些代码经常跑的。他把那个代码呢就可以动态做一个做一个这个这个优化啊，这个当时是这个呃用来在动态编译技术里面非常常见。
27:25什么叫动态编译？就是不是静态的编译，编译完之后去跑，而是一边跑一边编译，一边跑一边编译， OK 一桃。
27:33一件编译呢？它有一个我举最简单的例子，就是你在做 if else 的时候，对吧？你做 if else 的时候，大家知道 if 的代码在这儿，
27:42 else 代码在这儿后面呢有这个这个继续往下的代码。那如果你 if 的代码能经常跑 if 代码 else 代码是实不跑，那你就应该把这个 else 的代码呢放的远一点。把这个 if 代码运行完之后，下面的代码呢就直接连到这个 if。这样的话呢它们的代码的这个就连得更近啊，
28:01 lochanity 就会变得更好一些。这是我们说这个就是需要动态去调二进制。在内存中它的布局是什么？ laout 就是这个就需要通过动态编译的方式去做，为什么呢？是因为你只有动态运行了，
28:18才知道 f 和 l 是哪一个更长跑，对不对？更常更常被这个这个运行到啊，所以呢它只能够利用动态的这个信息。好，这个比较少见啊，
28:28就是几乎就你们应该都没怎么见过动态翻译去翻译。然后呢，不一样呢，就是我在 windows 上，我在这个这个 x 八上面要跑 arm 的这个应用程序，那我就需要去做一次翻译了，
28:39这是 different IS。同样对于 system 来说也是一样的，就是我要在 windows 上面跑 linux，大家都是 f 八六，对吧？ OK 了。
28:48或者呢我在一台这个 windows 呃 arm 上面，我要跑一个 f 八六的应用程序，那就是一个 different 孩子。我们今天讲的主要是这个叫 classic system 实验，也就是在同样的一个 ISC 上面去跑多个操作系统。那么对于这个来说，
29:09对于我们今天主要说的这个来说呢，它又分成两大类。这个这个这个 type wide 或者说它这个实现的方式啊，这个名字也非常朴素啊，叫 type one 和这个 type two 对吧？ type one type two type one 就是我的底层的把硬件做 molorglasxy，
29:26做多物复用的这样的一个这个这个这个系统叫 hiyvisor hipe vizor 它直接跑在硬件上，直接跑在硬件上。还有一类呢是我用 post OS 上面再叠加一个 OS 两个 OS。所以从性能上来看的话，显然是第一种要更加的快。为什么呢？
29:47因为第一种的话呢，它其实其实这个 highviare 呃这个这个 hiywider 就直接跑硬件上面，它是用这个层数啊，相对来说会轻一些。然后第二种呢，它又分两个 OS 两层 OS，
29:59所以它的危害相对说会高一些。那么对于这个第一类来说的话，大家应该都没没见过。第一类啊，现在第一类用的有点少了啊，我们现在基本上包括服务器厂商都只，
30:13主要还是用这个第二类啊，主要第二类，为什么呢？这个也非常有意思。这个 then 我们就可以认为它是第一类的，它是一个为了虚拟化单独定制的一个这个 hyflisy。
30:27然后呢，他就直接跑在硬件上面，然后呢，别的应用程序或者别的 OS 要跑在它之上。我们可以认为这个还有一点就是说是是那有点像是这个服务器卖出去的时候，就天然就放在上面的早期 VM wear 也有也有也有类似于这样的这个技术叫 ESX solo 啊，
30:48叫 VM where ESX 他跟 z 都是属于这个 type one，那他是怎么做的呢？他在服务器上面放了一个 SD 卡，就服务下面里面有一个地方可以给你插个 SD 卡，它把这个这个这个 VM 的 ESX 就放在这个 SD 卡上面。在你开机的时候，
31:13它先从你这个 SD 卡去启动 OK 你的硬盘上空的都没关系。然后呢，启动完了之后，它可以显示它，因为它这个上面本质上就跑了一个跑了一个 hidweather，跑了这个就虚拟化的一个管理器。
31:26然后呢，启动之后，他就你显示器连上去之后，他告诉你说，我现在 VM wear VSESX 这个 server 已经启动好了。你想装第一台虚拟机，
31:38请插入你的光盘啊，然后你就点一下就光盘哎，光区域，然后放一下光盘，然后推进去。他说哎你先创建一个虚拟机，
31:47要多大的内存，多大的多少， CPU 多少，这个硬盘对吧？然后硬盘从这个服务器里面的哪个硬盘去出啊，它就显示这样一个界面，
31:58这跟我们自己装 OS 装装 VN wear。那这个虚拟机的过程就很像大家注意啊，它的硬盘是空的。 OK 就是说 VN wear 当时 mate server 它的硬盘是空的。它的整个的这个虚拟化的这个监控器的话，是放在一块 SD 卡里面，
32:15然后腌了之后就直接可以看。那你说哎这个挺好的啊，这个相当于是否则我我们一般我不知道你们现在还有没有人装过服务器啊。你要是导师让你装台服务器的话，那一开始的时候可麻烦的都没有什么图形化界面的对吧？你得在一个比较就是纯命令行的字符下面去敲个什么西，
32:34你还你还得或者或者你插一个插一个 USB 的一个这个呃 stick，对吧？然后跑离个死后去安装，这也是一种办法。它这个呢就相当于是有点类似，它不是从 USB 启动，
32:45它是从 SD 卡上上去个 USB 卡，还可以有一个数解方法。这个启动整个过程就相当于预制了，那你要升级怎么办呢？升级，你就把这个 SD 卡放到别的地方去升个级就行，
32:57也很方便啊，也很方便。所以呢这个当时我觉得这种这种思路的话倒还挺有意思的。但它个缺点什么缺点呢？就是它的驱动特别少，大家想想就就能够想明白这个这个这个问题，
33:13对吧？就是说它的驱动的话，其实是要满足这个 ESX 的这个要求的驱动。所以我当时印象很深，因为我装过这个服务器啊，当时装这个服务器特别痛苦，
33:24为什么呢？因为网卡认不出来，网卡认不出来之后呢，他就说你的网卡是什么型号，我这儿有一个支持的列表，你要把这个网卡型号在我这个支识列表面找一找，
33:34有我就支持，没我都不支持。那一定要到 VM wear 呃，到到 VM wee SS 的网站上面去下载，下载一个这个驱动，然后呢再放到这个里面去再去找，
33:44很麻烦啊，很麻烦。所以这是我们说的这个第一类，第二类的话呢，就是一个 linux 对吧？然后上面直接跑一个虚拟机，
33:52哎就可以了。这个机动就很简单，因为 linux 大家都能装，对不对？那无非就是你平时你装一个应用程序，现在我装一个虚拟机可能就是这样。
34:01所以呢就从这个使用体验来说的话，我们的第二种它就比第一种要好很多，上手容易上手容易之后它的缺点是慢，对不对？它缺点是慢没关系，越有容易用的东西就越流行啊，
34:19越容易用东西越流行。为什么？本质上它是一个成本成本的考量。一旦你要在你的设备上装一个像这种 z 或者 BMVEESX 这样的这个虚拟化的这个这个系统的话，你的维护人员大概率是要比较贵的，对不对？
34:37维护人员大概率是要比较贵好。那你这个很贵的维护人员和我随便找一个懂 ldows 的人，他就能够 hold hohold 得住这样一个这样一个虚拟机。比起来的话。显然啊这个更多的厂商他愿意去使用上面呃下面这个便宜的这个版本 OK。所以呢这其实系统说到底还是一个成本的一个考量。
35:01只不过这个成本考量，很多时候它隐藏的很深，或者说它需要考虑很多维度，才能够把这个成本把它给算出来。很多时候我们看上去很便宜的东西啊，其实特别的贵啊，
35:11其实特别的贵。因为看上去很贵的东西呢，它其实整体的这个成本反而是会更便宜。所以呢这个成本这件事情在我们的系统里面的话呢，是会反倍提起，但是呢却依然是有很不是说那么容易就能够给人界定说成本到底是多少。
35:30好，接下来我们来开始讲三个虚拟化，分别是 CPU、虚拟化、内存虚拟化和这个 IO 虚拟化 OK。我们来讲，
35:39为什么我一台计算机的这个操作系统，对吧？一个 windows 能够跑在另一个 windows 上啊，这件事情本身其实还挺挺神奇，就所谓的 OSOOS 对吧？一个 host OS，
35:52比如说 linux 可以稍微跑多个 guest OS，比如说这个 windows 啊，或者是这个这个 windows 本身你还可以再跑一遍，那这里面还可以再跑哈，可以再跑啊。早期大家如果用 VM where worx station 就发现，
36:07我可以在里面虚拟机里面我可以再跑一个 windows，上面再跑一个 windows，对不对？但你有没有想过在这个 windows 里面再跑一个 windows 呢？你在这个 guess 里面再跑到 guess 可以吗？ where where 他就会不让你跑，
36:22他说哎我简单到你就跑，在 where where 里面，你不能再潜逃了。但是呢你可以在这个 VM where 构造出来的虚拟机里面， windows 里面再装一个，比如说 virtual box。
36:37那这个 watch box 就可以让你再装一个 windows。然后你在这个维度里面呢，你可以再装一个 AV mov 啊，这样的话就没事了啊。是因为无烟味可以检测出无烟味，但是它不能检测出恶出 boss 啊，
36:50我这个这个这还真有。那我们上本科的时候，当时这个这个虚拟器还是一个非常时髦的一个技术。当时大家想零零几年零二零三呃零三零四年的时候，正是这个虚拟化发展的一个一个高峰期。 VM 威尔当时如日中天，
37:08我我有我有个本科同学，他没事儿，就就在宿舍里面去做这个迭代。 VVVO 里里面跑一个 virtual。 PC 当时 virrtual PC virtual PC 里面再跑一 VVMY，他想试一下，
37:19我最多能够嵌到多少层啊，就给他牵扯牵扯了大概四层还是五层。然后呢里面每跑一步都非常的慢啊，就跟那个盗梦空间一样。大家知道盗梦空间一层梦境是慢七倍，对吧？
37:34七层梦境就是慢四十九倍啊，哎七倍是四十九块哦，不是啊，是七的四，多少七的七次方对吧？那就很大了啊，
37:46基本上这个已经到一个力去了啊，七的七次方不是四十九倍啊，哎这个也是一样的。你在这个 VAVMO 里面一层一层去嵌降下来，后面你运行一条指令，你就看到速度巨慢无比，
37:58它跟装也不容易。好，那么我们的一个 OS 是怎么能够跑在这个上面跑在这个后侧上？其实这个问题问的不是特别的好。我们应该问的是，为什么一个 OS 没有办法像一个应用程序一样，
38:16像一个 application 一样，跑在一个 OS 里面？我把一个 os 把它看成是一个应用程序，那就跑不就行了吗？而事实上还真有人有这样的想法啊，叫这个叫这个这个这个 UML 哈。
38:34 UML 有一个项目叫 UML，全称叫 user mode，要就 user mode。 linux 啊，很多人，那为什么要做这个东西呢？
38:50原为很简单，就是有些软件在 linux 上面跑的特别好，但 windows 上面没法用，对吧？但是说我能不能够在 windows 上面装一个 user mode 的这个呃 linux，这样的话我就可以用一些很好的软件，
39:04比如 AWKISED 啊，像那些运令行的一些工具。当然现在 windows 上也有很多这样工具啊，能够跨比盘。但当时没有，所以呢，
39:12他是希望跑一个这个，然后他把整把 linux 原封不动的搬到了玉富泰剧情。为什么把 linux 的 kero，我们说是科 rent 啊，跑到用户袋，它就不能运行了呢？
39:25我们来看它到底执行一个啥第一行代码，这是 linux 科目的第一行代码啊，第一行代码就出问题了，因为第一行代码是要关中断，叫 disable interrupt CR clean interrupt。那为什么第一行代码就出问题了呢？
39:43为什么呢？原因非常的简单，是因为这个这个这个这个第一行代码是一条特权指令，于中断是一条特权指令。大家想想一特特权指令，你怎么能够用户态态应应用去呢呢？
39:58那不就乱套了吗？对不对啊？你你你你这个应用说要观中断，我另一个应用说不要中断，那这个事儿就就就就乱套了啊，就乱套。
40:08所以他不能够在舆论过里去啊，怎么办呢？或者说还有什么类似的类似的问题呢？就在 windows contde 里面的话，除了像关中断这样的指令之外，还有别的很多像限制就改列表确认 c 加三对吧？
40:21设置中断向量的这个 table 啊，这样的这个 interrupt description view 等等。这些的话呢其实都是非常类似的这种。我们说啊它是这个在用户模式是不能运行的推荐值啊，因为它要改变整个系统的状态。好，
40:40怎么办呢？现在我们有个 host OS 上面希望能够去跑很多 get OS， get OS 呢，它们会有冲突。什么冲突呢？就是对于系统的这个状态会有会有冲突。
40:51比如说 c 加三寄存器，整个系统只有一个，然后呢每个 OS 都说要改，那改成谁就打架，打架对不对？好，
41:06那怎么解决这个问题呢？怎么解决问题呢？对，这个大家就想到有这样的办法叫 travel and emulate。就是当一个用户态的应用程序，他要去运行一条内核态的指令的时候，
41:21会产生一个串，对吧？产生一个串然，那一到串了之后呢，就被 OS 截获。到了 OS 截获到之后就说哦你要改这个这个这个这个 CS 三是因为你里面要改列表，
41:33但是呢你其实是个虚拟机，你这个假的你这个假你没有没有真正的业务，所以呢我来帮你去做这个和你想要改页表等价的这么一种操作。这个就叫做 imuelate 模拟啊，叫 ivilate 模模拟改页表。这个事儿呢相对来说是比较麻烦的一件事儿。
41:52这个模拟的函数也没有办法在很短的两三分钟，也没有办法把这个完全讲完，对吧？但是我们可以换一个，比如说就 CRI 刚刚我们提的 CRI 这条指令这条指令，如果我们要用 trap and evening 去做，
42:06怎么做呢？当一个 guest OS 去跑这个 CRI 的时候，他就会吃儿 CPU 就会 try trap。完了之后呢，它就跑到了这个 OS 去执行。 OS 呢就会去改变一个叫 IF 的一个注意。
42:21这个 bei f 就是 interrupt flag，但这个 beat 不是一个真的 beat，而是一个假的 beat。它 beat 在哪呢呢？旧的内存里面啊，在内存里面有一个假的一个 beat。
42:31这个 IF beat 是专门为了这个虚拟机放在放在那块内存里面的这样的一个存在啊，放内存里面的一个存在。然后呢，这就是我们说的一个点。那你说哎那这个 if beit 有什么用？那为什么说它放在内存里面是个假的？
42:45那既然是假的，它有什么用呢？它虽然是假的，但它还是有用的，为什么呢？因为当真的，
42:52我们要向一个虚拟机注入一个中断的时候，就会去看一下这个假的这个 if 壁纸有没有被设什么。如果这个 if beat 没有被设什么表示终端是关着的，那么我就不往一个虚拟机里面去注意。那我是谁呢？我就是虚拟机监控器。
43:10所以呢每一个虚拟机都有自己的一个 IF 的这个 bat，它的作用就是去控制 hype wide 是否向这个虚拟机去注入一个 interact。当然这个 internet 也是假的， internet 本质上是要通过这个去调对应的这个 interact t handle。 er 好，那通过这个 if beat 这个作用，
43:32我们就可以去控制一个虚拟机到底能不能去注入假的这个中断啊，或者是叫哥出来的这个中断。所以它还是有用的。所谓的假的更多的是说模拟出来，而不是在物理硬件上的一个真的这个页幅背景啊，不是一个物理存在，
43:47而是一个虚拟的一个模拟出来的存在，是由软件来实现的这样一个存在。好，那么当我们一个应用程序或者一个这个这个 OS 在用户态去运行这个 CRI 的时候，就会去触发 trap。触发 trap 之后，
44:03 OS 就会把这个这个虚拟机对应的 IFBF 把它给设为零，从而把这个内把它的这个暂时把它的这个虚拟的这个这个中断，把它给关掉。好，那么整个的这个比率它是 OS。如果我们打开双方再问一下这个 OS，
44:21 post OS 是如何去 deliver 一个 instruct 到一个 guest 里面去。如果不问这个问题的话呢，那这个这个答案就是和 signal 机制很像啊。如果大家能够想起 OS 里面应用程序的 signal 信号机制是如何实现，那你就很快就能理解，你要想不起来，
44:41那再去复习一下信号是如何实现好，那么问题解决了吗？如果都能这样的话，那我们就相当于提出了一个找到了这个这个内核，没有办法运行在用户态的一个根本性的原因。就是因为里面有一些 privilge instruction 特权指令。
45:02但是如果我们通过 trina 来 emulate 的话，就意味着我们可以把所有的我们可以把所有的这个特殊指令全部都 trap 你的音乐类型，那这个问题就解决掉了。是是这样吗？不是，为什么呢？
45:17因为有一些指令，它并不是严格意义上来说的，这个可以被虚拟化的。 ok 那什么子呢？就是有一些特权指令，当它运行在内核态呃用户态的时候，
45:32它会发生串，有些则不会子。比如 dripop f 取消指令这条指令的话呢，它是是一条 s 八六的处据。它的行为在 system level 和在 user level 啊，就是用户带数序和这个和这个内核态，
45:48它的行为是不一样的。他有这种不一样的行为本身是写在手册里的，不是一个 bug，它就是这样。 ok 所以如果我们在 OS 里面，我这个 UF current，
46:03我现在跑到用户态，对吧？他他被他被他他已经被降权了，跑到用户态去了。在这个情况下，他去跑这个 pop f 只会出现一个 silent drop，
46:13就是他不会有一个 trap 的这样的过程。既然你没有 trap，我们就没办法去实现 trap and inmulate。所以呢就有十七条这样的指令，我都列在这了。有十七条指令是不满足这个 track and evenge 这这个征征。
46:29于是呢我们就要想办法怎么去处理掉这十七条指令，我把这十七条指令处理好，我就可以去你它了。怎么处理呢？第一就是我干脆就用另外一个软件啊去读这个 OS，就是客客户的这个虚拟机 guess OS 对吧？
46:49去读这个客这个虚拟机里面的 linux，然后呢一行代码，一行代码去解释之前。那这个呢就是我们说的叫 instruction interpreter，指令解释器。指令解释器呢，
47:02它是一种一定能够去运行一个虚拟机的方法，前提是你把这个指令解释器，把它实现的完整。你是这个 x 八六的指令解释器。那你就可以跑 x 八六的所有的这个 banner，包括内核的 system instruction。
47:17但是听上去很慢，确实也很慢。 OK，这是第一第二，就是 bindary translation，它不是一行代码，
47:24一行代码去解释执行，而是一次性的把一段代码，一段二进制啊，把它给翻译成另一段二进制。那为什么做这个翻译呢？我们前面说了，
47:35有十七条指令是有问题的，我们没有办法 hold 住。所以呢在翻译的时候，就看你在翻译的这一段代码里面有没有那十七条指令中的代码。如果有的话，就把它变处理一下。
47:48比如说变成一个方程库，你既然没有办法 trap，我就主动的啊产生一个事儿。 OK 这第二第三呢就是叫 paraovirtualization，就是准虚拟化或者叫半虚拟化啊。还有就是说我能不能够就手动把这十七条指令把它给删掉，
48:08那不就行了嘛，对不对？你不就害怕这十七条挂事儿，这个呢也算虚拟化，确实也是一个办法，也很简单。
48:16但是呢它违反了虚拟化的一个要求，就是虚拟机要求没有办法去区分。我是跑在虚拟机里面，还是跑在虚拟外面，你这个显然就可以区分了，对不对？
48:27我已经把动作删掉，我改东西了改东西就表示你区分了，你不改，就说明你不用区分你改，那说明你要去。所以这十七条指令的修改本身，
48:40这是一个半虚拟化的一个过程。所以呢我们也叫做败循环，因为它不是一个真正意向的循环。第四就是新硬件新硬件。那什么是新硬件呢？就是我们要去改这个 CPU，
48:55然后呢去这个修修正这个这个错误啊，修正错误。比如说之所以这十七条指令，没有办法去这个 trap，原因是因为我的英特尔的手册，我的指令啊不是为了虚拟化设计，
49:10它它就是可以这样。那我把这个改一改不就行了吗？我把英特尔 CPU 改了不就行了。所以呢英特尔的人主要在想这个第四种办法， OK 英特尔的人想第四种办法。然后呢，
49:20这个剑桥的人呢啊我们说这个剑桥大学的这个研究者，他们在这个开发这个嘴，他们在想第三种办法，为什么？因为第三种办法听着就很快，对不对？
49:32听着就很快，你前面两个你看要翻译来翻译去的就很慢。第三种方法简单粗暴，但是有效可以在一台机上跑一百个虚拟机有效。所以呢第三种办法哎，是这个健康的人在想。
49:46那第二个办法是谁在想呢？第二个办法是 VMY 在想， VMY 呢就认为说我重点是要商业化，商业化我不能改东西啊，我要让这个我的用户拿到我的软件立刻可以用。所以呢他就想这个第二种方法，
50:03第一种方法是在想呢地中化，就就就主要是这个学校在行啊，或者是一般的学校。比如说我们写一个这个指令的这个解释器，反正也不用花太多的这个时间给大家做一个课堂练习。这个这这就是我们说的这个啊，
50:20我知道南大现在还有这样一个这样一个课程作业，对吧？大概一个班一百多个人，每年大概有五个人可以做完啊。就是你要写一个 x 八六的解释器啊，你要把熟读 s 八六的手册，
50:34把每条指令怎么做，全部由软件做一遍。最后你写出来一个假的这个 CPU，就是软件写一个 CPU 出来，最后能够跑他们喜欢跑的这个仙剑奇侠传，对吧？
50:47那把那个游戏跑起来，就算你做完了，就就算你做完了。所以呢这个就是说我们大家性能是非常差的。好在我们今天的硬件很快了，所以它还能够跑得起来，
50:57否则的话确实很难跑起来。因为他每次要去做这个翻译就很慢。所以呢当时整个的大家看这个两千年到二零一零年非常热闹，对不对？四种方法都有人在搞，而且每种方法听上去都是 make sense 的啊，
51:13都是 make sense。好，我们再讲一点啊，我们讲到看看啊，讲到五十分，大家在休息时分，
51:20我们的第一同学前面提了啊一个标志性的一个系统，开源的叫 box 啊， BUC 选择 box。大家有兴趣可以去，看今天还很活跃啊， x 八六最完善的一个这个 interpreter 解释器啊，
51:36就是这个 boss 它是开门。第二个就是 bindary， translator 就是 viar wear，那叫 q be，它是闭园的，它是开源的，
51:44它是闭源开源。然后呢，这个 VM where 和 cuuor 他们他们要做的事情是，我们学在说 dynamdynamic translation，就是要在动态的时候，把这个十七条指令，
51:56把它给换成这个相应的方程框。它怎么换的呢？它有一个叫 basic block 为力度去做这个翻译。 basic block，每个 basase block 差不多五行五行这个 inflution 左右，它是由呃，
52:09跳转指令来界定的。比如说你有条 jump 指令，那就是结尾了。你有条 core 指令，一条 return 指令，但凡有一个跳转指令，
52:17这个 basic block 就结束了。那么跳转指令占多少呢？占大概百分之二十左右，所以说每五行代码差不多就是有一条跳转指令。所以呢我的整个 VC pro 差不多就那么大，但也有很大的。
52:31好，那么当我的 guest code 进来的时候呢，先先判判断一下，到我 transanstion 里面，我看一下你你有没有翻译过。如果已经翻译过了，
52:40我就直接找到对应的 cash 就去跑了。 TC 叫 translated translation cash，对吧？就 translation cash 如果我没有翻译过，就意味着 cash miss cash。 miss 呢我就跑到这个这个这个翻译的这个地方，
52:56就在翻译的过程中再去翻译一下，并且把这个写到上 c 这里面去。好，然后呢我就找到这个。找到这个之后呢，他把十七条指令就换成了 CPU 对应的 emulation 的这个 proteins 啊。
53:09然后我们举个例子，比如说左边是一个 guess code，左边这 gesscode，然后呢， VTC 就是当前的虚拟的这个 PC 啊，我软件的这这个逻辑上的 PC 应该指向上面这一行，
53:26然后呢，他要去 move 一个东西，对吧？ mov 一集成器 CRI 就是清这个开呃，清这个这个中断的这个中断这个 beat，对吧？
53:35然后呢，再做个 m 那做个 mov，然后呢再恢复中断，最后 return 就是 control LL，这是一个这整整个合在一起。因为 return 在最后，
53:46所以说它是一个 basic block。好，它怎么转成一个 transsition 的这个 cash 呢？第一行代码不变，为什么？因为第一行代码并不涉及到特权指令，
53:59无非就是一条硬盘也可以跑出去第二条 CRI 就被翻译成了 core handle CRI 这样一个函数。为什么？因为我们说 CRI 本身是一条特权指令，对吧？特权指接下来 and 不用改接下来 mov CR 三，这个也要改为啥 CR。
54:20三是页表 g 励值寄存器。所以写 CR 三本质上需要用特旋级的，所以把它改掉改成什么呢？改成 core handle r 三。但是因为它需要一个参数啊，需要两个参数对吧？
54:36所以把这两个参数都哎需要一个参数， EBS 已经在。然后呢就把这个相关的这个参数呃呃 EBX 作为这个参数啊，放在放在这个放在这里面。然后呢，再再去调调这个 handle 二 CR 三。
54:49注意啊这个 handle CRI 和这个 handle CR 三，它们都是可以认为都是这个一个函数。一一组函数叫，