00:01一个是肯定是也是，为什么事情不就是二十四个，是的，那个慢自问题，你多想拜拜。嗯嗯，
05:32嗯好，行，我们继续。好，行。那上节课我们讲到的一个事情是说，
05:38我们如果啊对于这样一个新型的这种网络的话， OK 我们其实是需要做一些针对性的设计，对吧？可以让它的这个 read 非常快啊，它的这个 read 啊都用这个这个 RDA 啊来做。就是说我用这个 RDMA 网卡直接就读啊，
05:51过过 server 这样 CPU。那对于写这样的这个相对来说比较复杂的这样的操作的话，我们需要把它扔到 CPU 上做。比如说 put 这样的一个操作 OK。那么这样的话它这样的一个 exset up 回答一个问题，就是如果我有个 time，
06:05对对吧？他在用这个这个 RDV 正好在读这个数据啊，这个时候我的 server 正好它做了一个这个修改的这样的一个操作，对吧？我们说这个时候就会遇到这个分布式，或者说并行里面经典的一个问题，
06:16叫做这个 rease condition。那它就会造成你的这个数据的错误。比如说我们来举一个这样一个例子。好，假设一开始啊我需要把我的这个数据对吧？新大位对吧？
06:26读到读一个读，它对应的这个值是一二三四五六，我会读出来。好，但是在我读完这个这个一五三这个这个这个这个读完一五三这个八 k 的这个 p 然后我说唉我们发现这个数据在一五三这个八 k ket 之后，这个时候呢 server 它在做一个 concurrent 这个 insert 后，
06:44这个 insert 呢它它正好把读了一个新的这个值啊，把我名字反一反，然后正好又读到又呃发现有个个是 conletion，然后再把我原来的这样一个值啊给踢到这个零零一的这样的一个另一个这个八 k 的这样的一个时候。好，这个时候我们大家想想，
06:59如果我在用 RDA 去读一下这个这个新的这个值的话，就有可能会读到你这个新插入的这个值，对吧？而不是我原来数据对应的这个一二三四五六啊，是这样的一个 XX 啊叉叉。那这样的话，
07:11它其实本质上来说什么呢？本质上就是这个这个这个 race condition 造成的一个问题啊， race connection 问题。所以我们啊是需要一些这个系统的 system 这样的一个 sytion tion 把它给解决了。那么我们怎么去去去去解决这样一个事情呢？那么第一种方 tion 来讲，
07:27我们我们在讲这个 transaction 的时候，或者讲 race condition 的时候，提到过一个事情，对吧？这个东西我们其实我们说我们可以上锁，对吧？
07:35上锁是一个这个避免这个 race condition 的一个经典的方法。就是说我再去拿一个这个数据，我在访问一个数据之前，对吧？我先去去拿一下这个数据对应的锁，比如说我们啊要读这个八 cket 之前，
07:49对吧？我们先去把这个八 cket 对应的这个锁给拿了，然后再去读这个数据。那这样不就能保证这个这个正确性吧。那大家想想到我们这个东西会会两个问两个挑战。第一个挑战是说我这个锁对吧？
08:00 CPU 侧啊我们很容易实现。但是我说你的 cite 原本它是在用 RDMA 访问，对吧？它不是在用这个 CPU 访问，那么这个 cet 能不能它也要也也也也也不用这个 CPU 去拿锁呢？不用 CPU 去拿锁呢。
08:14大家因为你一旦又搜索了 CPU 拿锁呢，你就 fall back 到我们原来的这个 memory cash d 的这个实现了，对吧？几乎没有任何的这样一个优势啊，我们只实说这个事情是是可以的啊，是可以的。
08:24为什么呢？因为大家想想上锁，我们也提到过，上锁的本质是什么？上锁本质其实就是一啊，当然呃不能说上锁，
08:31我说上锁本质可能有点 OK 嘛，就是说就是上锁或者说系统里面百分之九十的锁啊，它的核心操作就是一个什么呢？ content swam 啊，就是说我有一个 flag 表示这个锁有没被 OK。然后我在 CPU 上呢，
08:44我在这个 compair sofoft 上索过程本质上就是我去用 compare、 soft 把这个这个 flag 给改掉，对不对？那我们说 RDMA 对吧？它其实也提供了一个跟 CPU 对应的一个 compax， sofg 就叫 RDMA 的 automatic 啊，
08:56我们也提到过。那么其实本质上来说，我们是不是也可以用 RDMA 去 comcompare sofp 去实现个锁呢？其实是可以的啊，可以的。比如说我要去访问这个 bucket 和 value 之前，
09:05对吧？我先用 RDMA 的一个这个 CS，先把这个锁拿到啊弄完。弄完之后呢，我再用一个 RDM right right 把这个锁给放掉，把这个自然指定好。
09:13这样一套方法啊，它其实当然我们说这套方法看上去很直接对吧，它其实其实也有很多问题。第一个问题就是说它的这个 wrn trip 其实非常多的对吧？我们前面说你 RDMS 这个数据结构啊，你设计来半天设计序，
09:26我我么核核心目是什么？就是减少我每一操作所需需要的网络语延值。那 OK anyway，你这边需要呃去提升这样的一个这个这个这个你需要去去保持数正确性。那我去在前和后多加了一个 RDMA 的操作，那不就这个有点本末倒置嘛。
09:43所以说这个方法其实啊不是一个特别好的方法。那第二个问题呢，其实是说这个这个问题其实也也是一个非常有意思的问题啊，有时间我们可以啊，我不知道后后面有时间我们去看，就是就是 RDMA 的这个 CS 啊，
09:56它和 CPU 的 CS 之间是冲突的。这个问题其实非常非常有意思。我我们当时啊再去实现这个 RDV 锁的时候，我们一了大概两个礼拜啊，最后发现发现是这样的一个问题，就是阿里 mate CS 它其实其实其实看不见这个这个 CPU 的 CS，
10:11为什么呢？大家想想 CPU 它怎么去实现一个 compare and swap 之间的这个原子线。大家想想 CPU 我们怎么实现这个 compare swap 这个操作是原子弹。我们我们在讲 transaction 的时候讲过，就是 CPU 它本质上它会先先发一条指令，先让你把这个内存的总线，
10:28 catch 的这个这个这个总线啊，把它给 lock 住，然后去访问这个操作 OK。那大家想这边会有这个问题，就是 CPU 的这个 lock 它触发是放在 CPU 这一侧的对吧？但是大大家其实 RDMA 的这个这个 CS 它的锁是怎么实现的？
10:43它的这个锁其实是在网卡，这次实现就是网卡内部有一个类似于这个这个这个八字锁的这样的一个机制。因为所以说，这就导致的结果就是 RDMA 的 CS 和 CPU 的这个 CS，本质上它是一个两套这个机制。当然如果你用两套锁的话，
10:57我们其实很明显的会发现它其实是不兼容的。所以说啊我们用这个 RDMA 的锁和一个 CPU 锁，其实是没有办法保证这个原子性的那怎么办呢？一样就是把 RDV 锁换成 CPU 的锁啊 CS 对吧？要么你就把 CPU 的 CS 换成 RDVCS。但其实大家可以看到两种，
11:12其实都都是一个不完美的这样的鞋 OK。当然这个问题的话，这个这个这个这个现在可能会有一些新的解法。因为本质上来说， RDV 是用这个 PCIE 去访问这个 CPU 的数据。对吧那其实只要 PCI 去提供一个原子的这个 CS 的这个访问。
11:27那其实 RDV 的这个 CS 还是能跟啊 CPU 的这样的一个 CS 去去去去这个这个协同的那这具体协不协同得 depends 啊，你的厂商它是支持持和实现。对，然后后 DMA 的这个实现里面，它会啊有一些 capability 的这样的一个这个这个 flag。大家可以，
11:42如果你自己用 RDM 卡，可以去可以去查一下啊。他就会告诉你这个 CS 到底是只能局限于网卡操作 CS，还是说适合那个 CPUCS 兼容的 OK。好，那这是这是这个方法，
11:56它是不大行的那我们有没有一个这个这个更好一点的方法呢？那其实我们在介绍这个 rease completion 的时候，正好大家回顾一下，对吧？我们其实除了讲这个 locking 的这个方法以外，我们还讲过一个方法叫做这个这个 lock free 啊，
12:09 look free。那它的本质思想其实就是这个这个 OCC，对吧？ OCC 干法什么？就是说哎我先去读一下，我先去不打锁的去读一下这个数据。
12:18好，然后呢我在读完这个数据的时候呢，我再 rerecheck 一下啊，检查一下如过啊我的这个这个检查，发现这个我读的这个数据和和它他版本号没有修改，对吧？
12:30我就可以认为你这个数据它没有受到 rease condision 的这样的一个影响。那我就道这个数据是对，那这样的话它就不用不用拿锁，对吧？那它的这个这个核心的这个想法就是说第一啊，我每一个这个这个这个数据啊，
12:41它前面得有一个版本号啊，版本号。然后呢，我再去写这个数据，说啊我先把这个数据上锁，然后呢去修改。
12:48修改完之后呢，我把这个版本号加一，然后再放锁。然后呢我读也是一样的，读的时候呢，我先把整个这个东西都读过来啊，
12:55读过来之后呢，我再去读完之后，我再去 check 一下，去看看这个版本号和这个锁有没有被拿，对吧？如果他没有拿锁，
13:02同时他版本号也是一样。那我们其实就可以去保持认为什么这个这个读这个这个和这个 key 是一个原子的这样的一个操作节子的这样的一个操作 OK。但是这样一套方法的话，它其实会有一个啊很大的一个问题，是什么呢？就是说啊我如果第一啊，
13:19就是说我我我因为我其实本质上还是什么，我有一个额外的这个 wrong，什么意思呢？就是我我我光做完这个这个读完这个数据不够，我还要去做一个额外的这个 remind 啊去 check 说这个文型啊和这个 lock 是否会有变化。那它这个这个这个本身啊，
13:36它其实还是这个这个我们说你对 RDV 对吧？你要尽可能最小化的这个额外的这个网求。那这套方法啊其实也不是特别的这样的一个啊最优啊。所以呢这个这个东西的话就是说人们就会提提出一些更有意思的这个方法。比如说在这个 p lof 的工作流，对吧？
13:53它提出来的一个东西是说，我们对于 PPS 而言啊，我不需要一个非常通用的这个传子 i 智能这个机制。它只要保证什么呢？它只要保证说我读的这个 p 和它对应这个 value，对吧？
14:04是绑定的啊这两个值或者不过过程中我读到了一个 key，它的 value 跟它是不对应。那这个时候我们有没有方法，我不用去读两遍，就能把这个值给给确保这个对不对呢？那这个方法在这个我们做这个这个数据校验里面非常常见。
14:19对吧叫 check check on 对吧？其实就是说我在这个数据的 value 里面加一个 con，这这个 check kson 它 encode 了这个 key 和这样一个 value。然后我读读的时候呢，我我就要把这个 chason 给读回来。然后我就写的时候呢，
14:32我先得把这个 check，我也得先我得等写完，我再能把这个 checheck son 改掉。 OK。那大家想想，这个时候如果我读了一个 key 和 value，
14:39然后他们和他对应的这个 checson 一样，那不就能证明我这个读一定是个原子嘛。如果它不一样，那不就他就认为这个是副原则，我是不是 try 就行啊？之之前这个 lock lock three 是一样的这样的这样的一个操作 OK。
14:52所以说有人知 check check check son 方法的话，我们在 common case 就是没有 reace condition 的 case。实其实这是比较 common 的对吧？我们其实就不需要去做一次额外的这个读啊，我们就能够去保证这个这样的一个就性啊，但是它代价什么代？
15:05就是我看一 t 我读回来的时候，我要去重新算一个这个拆分 m 啊，它其实是有一些代价。那么在 PP top 里面，他认为这个呃， trade off 是一个 reaserable 的。
15:14为什么？因为他他认为网络的这个开销对吧？实际实际上是啊远比这个 CTCPU 大的啊，那这样的话我去用一些额外的计算开销，对吧？去省一次这个网络的开销，
15:23实际上是是划算。当然如果你不能省怎么办呢？我们一可以用前面这样一个 version。当然另外的话其实也有一些呃系系统里面，比如像 fum，对吧？
15:32它里面会有一些更精巧的这样的一个呃呃这样的一个机制啊，大家有感兴趣可以听看。 ok 行，那到这边的话，我们其实就讲讲完了一个就是在 RDA 里面一个比较复杂的一个 case，就是说怎么用 RDMA 这个这个去加速这样的一个典型的这样的分布式的这个数据结构的这样访问。
15:52当然我们说这个数数这个这个这个这个这个这个问这个问题本身，在现今还是会有比较多的这样一个研究啊，虽然它的这个光芒可能是被这个这个这个 AI，对吧？这这这个还是挺多，因为它里面其实还有很多这样一个 open 的这样的一个问题。
16:06比如说我们面面讲的这个数据结构都是还的吧，这吧比较简单的。如果对一些啊复杂的数据数据结构，比如说这个别墅怎么做对吧？这个这个事情其实还是一个比较啊比较有意思的点。然后包括前面我们说这个 RDB 的这个 concurrency control，
16:20对吧？我们说你用锁的话，开销会比较大，然后它要跟 CPU 去兼容，对吧？那我们有没有一些更好的这样的一个 concount control 的方法，
16:28比如说我或者说我能不能支持些更高级的锁，对吧？其实这这个还是有一些这个研究的，包括我在这个 reace 性这个冲突比较大的情况下，怎么保证性能，对吧？
16:37我对这个在审这这个 table 对吧？我发现这些还是有一些这个这个这个这个相关的这个研究，在在在在做这方面设计。所以说这个事情还是挺有意思的。 OK，那么但是我们因为时间有限，
16:48对吧？我们这个 CPP 本来就是给大家大概介绍一下，对吧？这个领域的这个到底有些有哪些新的这个东西。所以说啊我们就可能 RDVV 这块，我们呃在在 RDV 数结构的话，
16:58我们可能先跳跳啊就跳过了。我们接下来啊需要需要下一步，因为 RDV 我们其实可以看到它有很多很多的这样的问题。那么这这些问题一方面我们其实是可以从系统层面去解决，对吧？这是我们刚刚讲的内容。
17:11但另一方面来说，我们能不能对这个网络进行革新，对吧？我们能不能提供一些比 RDV 更好的这样一个能力，使得说我这个系统侧不需要去解决。那么复杂的这个这个这个问题的啊，
17:20这个其实也是一个比较火的这样的话题，对吧？这个呃目前其实我认为还都是没有一个定论的 OK。好，那么我们就接下来就看这个智能网卡啊，它本质上是用来去解决这个这个 RDV 网卡的一系列的这样的一个局限性啊啊这样的一个衍生出来这个硬件的这样分支。
17:39但是这个这个 RDV 解决这个局限性，它并不是那么容易。所以说现在的智能网卡，其实我认为是一个啊非常百花齐放的这样的一个这个形态。就是你各种啊各样的这个智能网卡，其实都能解答 OK。
17:51好，那么我们说你智能网卡的提出对吧？其实如果解决这个个 DDV 网卡的问题，就跟我们做所有做系统工作一样，对吧？我们肯定都是为了解决一个问题，
17:59这个问题或大或小，对吧？那那都没有问题，我们不能我们不是，我们肯定不是不能凭空造造系统，或者凭空造硬件，
18:06这个没有任何意义啊，虽然很多硬件工作是在凭凭空打，那就好了啊。行，那么我们可以看到 RDAV 的个个核心的问题是什么呢？大家实看到我们前面所有的这些 RDVV 的设计，
18:17它都在解决一个事。就是说我这个 RDV 啊这个网卡太弱了啊，它只能提供一个简单的这个 read right 和这个 automatic 的这样的一个操作 OK。那导致的一个结果就是我如果要但凡我要用不简单的操作对吧？去实现一些复杂的功能。比如说我要实现一个都不算算复杂的功能，
18:35我都我就实现一个简单的还是结构查找啊，我都得费一个老大的劲。然后我们传统的这个 TCPIP 或者说 RDMA 的 two 三 d 对吧？它其实很简单，我就搞一个 RPC，一下子就就就搞定了 OK。
18:47那么大家想想看，那我们下一步的演究方案什么？就是说我 RDV 能不能啊不去提供啊这样一个简单的这样的一个和能力，我能够提供一些更强的这样的一个能力。那那么在这个核心的思想其实就叫做这个 smart 啊， smart me 啊，
19:05其实我们可以来看一个简单的这个示意图，对吧？就是说我们现在要干的这个事情，就是我看对吧？我要我。而啊你们原本是说我希望能够这个我我只能用这个内存的读写操作去读这样的一个 ver。
19:18 ver 是这样的话，我会有很多的这个网网络额外请求。但那么我能不能让这个 server 测去提供一些这算能力，对吧？计算能力去帮助这个这个这个这个减少这个网络 trip 单 OK，这就是这个 smart。
19:31好，但是这个事情时候，事情又变得复杂，复复复杂杂，它复杂点在哪呢？就大家想想，
19:36如如我我是一个 RDA，对吧？我的这个网卡硬件只需要干一件事，就是我把这个 RDV 的这个 specification 里面定义的这个七层协议，或者说最就没有七层啊。 RDV 定义个它自己这个协议硬化实现快结束了。
19:48但是在 smart IK 的话，它其实会有问题，我需要提给用户提供一个编程性，对吧？我需要给用让用户去去在上面去实现这样的 logic。那么我怎么去提供这样一个可编程性能这个东西其实在这个甚至这这个甚至是现在的这个这个系统也一个非常非常核心的话题。
20:05因为我们能够提供可编程性的方式非常非常多，但是不同的方式它又有自己的 trade off，对吧？比如说我们可以用 FPGA 去提供可编程性，我们可以用 RMSOC 去提供可编程，我们可以制造的 lips 去提供可编程。
20:18我我甚至可以自自去做一个硬化，对吧？那么当然这些方法都是可以去提供一些这样的一个这个这个这个这个这个这个可编程的这样的一个能力的。但是他们你能明确的拍板说我一个比另一个更好吗？它其实并不能拍板，它本质上核心什嘛？
20:34它有一个这个 performance 和这个呃 programmability 的这样一个 trade off，对吧？大家想想我如果 IPJ 它或者是硬化，它的性能是最好的，但是它其实基本上很难编程。那如果我去放一个 RMSOC 啊，
20:46就是其实就是个 CPU，放到网卡上的话，那它跟你用续的 hoc PU 去做有什么区别呢？对吧？它其实性能其实没有办法做的很好。所以说这实际上是一个非常非常大的这个问题啊，
20:58这个所以说我们这个 DPK 也不给大家下一个非常大的结论。因为这个本身也是在演化过中，我们就给大来看介绍一下这个几种方法啊，几种方法 OK。那这第一部分需要考虑的就是说我们到底有哪些 SIV 的。第二个问题就是说我的这个 accel 放在哪里啊？
21:14这个这个大家想原本一个网卡，我只需要做做队列的处理，对吧？我收到这个这个 CCU 包就可以了。但是我我在要做一一个额外的这个协助理理器啊，去做这个用户卸载这个操作。
21:24而这个协助处理器它也要去访问这个数据。那我这个放的这个不同方式啊，我们后面会看到一些具体的例子，就会发现它其实会影响到你这个网速啊，其实会会影响到这个网速。如果一旦考虑的不好啊，
21:37你这这个这这个这个会会有很大的这样的一个性能啊。所以在这个智能网它的演习里面呢，也有一个也有流派的区分，叫 on pass 和 of pass。它去取决于就是说你这个啊写属你放哪里好不好？行，
21:49然后我们具体展开讲一下的话，我们其实就会发现啊，第一就是说我们现在的这个市面上的这些网卡啊，我们前面提到的各种加入控式都有。比如说有这个 RDMA 的这样的一个 ACC 的这样的一个网卡，就是硬化的啊，
22:04它基本不可编程。当然现在的 RDA 网卡会允许你编程一些这个拥塞拥塞控制算法啊，但是它除了拥塞控制算法，基本上干不了其他事啊，这种我们认为是用 ACCC 提供可能权理，当然也有 FPGA 的这个板子啊也都买不到。
22:18当然还有现在很多用的实际上是一个 SOC 的板子，就是在网卡上插一个小的 CPU 啊，小的 CPU 啊。这套方式其实很常见的原因，是因为它这对于编程非常非常友好。那这个这这套板子目前我看下来是非常非常难用的。
22:32因为大家其实可以想象一下，我如果在网卡上插一个 SOC，你跟你在放后 st 插一个 CPU 有什么本质区别的啊，它的本质区别其实不会特别大啊。所以说这个也是啊现在的这个很多人在 struggle 的去去让这个东西用起来的一个点一个点。然后这是我们说的第一个就是在这个可编程的这个算力的选择，
22:53对吧？其实有很多选择了。当然在这个可编程的这个东西啊，就是我们叫做这个这个这个这个这个呃我们叫做这个 nick call 啊，就是网卡上的这样的一个可编程能力啊，去提供算力。
23:05它放在哪里其实也有一定的缺。比如说一种怕一种结构叫做 on pass，就什么意思呢？就是我所有的这个网络包啊过来 OK，那我先去经过一下我这个网络盒，然后再去把它去去对发送送去去啊。
23:18所就意味着是说我的这个网卡的这个处理单元是在所有的这个包的路径上的那还有种方法呢叫 off pass。就是说我原本啊就搜搜网络络包的这计算，单单元跟这个网网络这个这个网卡的计算能力，它是分区分开的。而如果你这个一个包啊，你不涉及到这个卸载这个算力 OK，
23:36那我就不经过这个网卡的。好，那大家想这两种方式的好，这两种方法在哪种好，哪种坏的。其实我们发现很难区分啊，
23:44比如说对于这种 on pass 的这种形式，对吧？它的好处就是它的延迟是非常非常低的。因为它每一个处理单元都是在这个包的这个处理逻辑上。那你不知道 off pass 对吧？我如如果这个网卡要去这个这个这个处理这个包的话，
23:57我得什么我得先把这个包从这个 switch 读回来，然后再再发再再发出去。我到时要看到这个其实是是我很难忘的，但是 on pass 它虽然这个性能看上去比较好的吧，但它有一个很大的问题，就是它的这个 performance isolation 是很差。
24:10就是说你如果这个 nick all all 你像大象，你如果这个 licall 你放了一个比如实现的不是很好的一个处理单元，你会发现是发生什么事啊，就会发现你这所有的这个网络包，它都会加一个额外的这样的一个 delay，对吧？
24:23那这样的话其实是会影响到你这个正常，你如果不走卸载的这样一个网络性，所以说这两种方式目前来说都有很多的这个厂商去实现。你说具体哪都好啊，其实大家我们会发现有这种 trick off 的这个场景，对吧？
24:37你其实就有时候很难选择，你只能根据自己的这样的一个场景定制。那我们说 RGV 本身它也有一些这个啊可编程的这样的一个能力 OK 行。那么我们当然我们在在讲这个，因为我们是以将来科普性的去介绍一下这个 smart 的发展嘛。我们就会发现就是 smart 这个东西，
24:57它其实并不是指近几年才独有啊，它其实在这个二零一零年、一九九零年的时候，其实都有啊。它当时一九九零年的时候，它的它那个时候它的它的特征什么特别是啊这个网络的这个协议啊，
25:10其实不是特别的这样的一个这个稳定。所以说啊这个这个这个这个这个比如说我要我要去生产 RDV，对吧？我到底用哪种 RDV 这个协议啊，其实会有很多在这个 APP 上去做这个不同的进步。但在他们的这个目的，
25:23其实并不是为了像我们今天这样去卸载更多的 aptitition logic。但是最近几几年几十年的话，其实我们会看到有非常多的非常多的这个这个这个这个这个这个人啊，就会开始探索一个事情。就是说哎我到底比如说 PY store 对吧？我能不能去高效的放到这个 smart s 上啊，
25:42我的一些包括其他的这种网络虚拟化，对吧？网络虚拟化其实在云上是非常非常重要的。我的 TY aliaction 到底能不能放在 smart 上？包括还有一些重要的这个网呃网络之外的能力啊，就跟网络相关的很很很相关的是，
25:55但是又又又又不是呃不是百分之百一定要 enable。比如说我加解密对吧？到底怎么去高效的这个放大这个好 ok 行，然后我们对然后这个这个的话行，我们行。那我们简单的去做一个总结的话啊，
26:10我们就会发现啊 RDV 的问题。核心问题在于什么呢？它的网卡的计算能太弱，码能能力太弱。为了解决这个问题呢，能不能提出 smart 马德 smart 这个东西，
26:19它其实比 RDV 会复杂了很多。目前来说没有一个非常非常好的这样的一个定论。所以其实现在呢有一的研究是后面就会分，主要是分成两个流派啊两个流派。第一个流派呢就是说哦 OK 我先我什么都不管啊，我就自我为了一个定制化的这个场景啊，
26:36我去造一个这个定制化的这个 smart，能在这个定制化的场景里面做的最好啊，但是它一般用到是 FPJ，我们待会会介绍第一个 case 叫做 keep joack。第二个场景呢就是说 OK 我我也不知道你的这个 smart k 有啥用，对吧？
26:50那我先做一些系统的这个建模，我先把这个 smarsmart k 的能力给分析清楚。然后呢再提出对于这一类 smart 的这个优化工法啊，就是系统分析工作啊，然后至于你你你不同的应用，怎么用这些分析的结果去优化，
27:04那是你们的事儿啊，我们只告诉你，我们把这个网法给给分析清楚 OK 行。那那我们接下来就对于这两个流派做一些简单的这个介绍了。好吧？第一个流派啊是就是这个 SSP 一七年的一天很经典的这个工作，
27:18对吧？就是说啊就是说我怎么把 QS so 啊我们前面一起讲到的 QS， so 这个东西啊全部放到这个网卡上实现啊，只是说我一个 long 确就能做完，对吧？然后又又又能够支持这个全功能啊，
27:29其实我们会发现你们用到的很多的的这个技巧，其实跟我们用 RDA 优化的这个呃 QS 锁其实是很像的 OK。好，行，那么我们背景简单介绍 PSO 对吧？大家是应该已经不陌陌生了，
27:42对吧？我们已经啊讲了很多了。然后 PRS ore 的这个系统的这个实验方法，其实我们也介绍绍很多多对对吧？传传统的就是我们 DR 的这个，它们叫做啊这个这个骚，
27:51就基于基于基于这个这个 linux 对吧？它这些基于基诺是个 border map，它里面分析出来它大概只能做三百 k 的这样一个性能啊。比如说你用白 plus 的，比如说 DBDK 或者是 QCDRDV 啊，这个它的瓶颈是在于 CPU 的核对吧，
28:05它最高只能做到几个 main 类的。这个每个括这样的一个开销啊，这个其实我们也也也也已经都讲过了。那么还有一种流派，就是我们今今天介绍的吧，它叫做这个文塞列的这个 RDA，
28:16对吧？它的问题是什么呢？就是有外的这个 wrn NP 加上你的的个个 nnalization，我看的是比较大的。所以呢这个工作就干了一件事儿，就是说我能不能把这个 TSO 这个全部硬 worp j 上这个 ver 的这样的一个 nick 旁边的这样的一个 FPJ 上，
28:31 FPJ 上。然后呢，使得说我的这个这个这个第一站在 clict 角度来候，只就发一个这个 RDVI 呃， rantrip 就行了。那么站三个角度来时候，
28:40它的 super 要要远高于你这个 host 这个 CPU 这个事情能不能干呢？ OK 他们先看一下怎么干这样一件事，对不对？好，那么他们整体的这个架构啊大概是这样，那个架构比较复杂。
28:51我们待会儿再一一点讲，就是说我说大家想想我们还想一下，就是你要做这样一件事之前，对吧？我们得得看一下你这个硬件到底能提供什么样一个能力，对吧？
29:00比如说你这个 APJ 软件， APJ 到底是跟之前的这个 RD mini k 有啥不同？那么这个 IPA 它和 RDB 地址它最大的不同有两点。第一点就是它的这个 device 上有一个 derom 啊，它有一个有块 derom 的这个缓存，使得说我可以去缓存一些 KYILKYL 的这个数据啊，
29:18这个这个其实我们的这个这个这个 RDB 网卡啊，目前 RDB 网卡是不具备。第二个就是我有个 MFPA 啊，它能够实现一些有限的这个计算啊，它在那些高吞吐的这个计算上是会比你的一个 CPU 快很多的。但是它在做一些复杂的那种啊计算的话，
29:33它就比 CPU 差。主要到我前面这高的参数是指并发啊，就比较简单啊那种高并发的。比如说你做一个向量的加，对吧？这种操作 FPJ 是那正好，
29:42但你要做一些复杂的，比如说这个别墅 chross 对吧？这种东西 f 一就就就干干不了， CPU 还是干不了好。除此之外，它跟这个 CPU 其实非常像，
29:51就是我的这个 FPJ 和这个 host 这个 drom 就存这个个 QRS 的这个地方。它是用一个相对较慢的这个 PCI 去连接的 OK。然后然后它有一个这个这个四十 BGB 的这样的一个交换机 OK 好这样这样一个架构。所以呢这边就会有第一个问题。第一个问题就是如果我们要用这个 IPJ 去访问这个 host 的这个 q are store，对吧？
30:14那么它的其实遇到第一个点，跟我们做 RDA 的很像，就是我们也要去减少这个 DMA 的这种 round trip。什么意思呢？就是在它这个架构下，对吧？
30:24我说 RDMA 最大的问题是我从这个交换机过来，到这个 host develop 这个 run trip p 时间比较长，么么其在在 q 第二个差差不多的。等我它稍微稍微短一点，但是并没有差图的。就是它这个 ded MA 啊，
30:34其实也的延迟，其实是跟这个 RDAV 的这个延迟差不多，差不了多。所以如果我一个 IPJ 要去用频繁的去 travelse 这个 d 用 DMH travvose 这个开始 p 的话，它的性能其实也是很差 o 所以这就导致它里面需要去这个用的两个技术点。第一个就是我要减少 DMA，
30:51第二是我要去隐藏掉这个 PCI 的雷点 ZOK。然后它第三个的这样的一个设计，实际上是说啊我的这个我被很很奇怪了，就是如果这个叠面很慢，那么我们最最理想什么？就是我们要避免 DM DMA，
31:05对吧？那我怎么去避免 DMA 呢？那其实最理想什么？就我就把这数据给 catch 到这个这个 on board，只要长得这样的话，我们就能够做到非常快嘛。
31:13其实我认为这也是它很大程度上能够啊提升的这样的一个性能的这样的一个一个一个非大的原因。就是它有一部分数据其实来自于这个缓缓有点类似于 cash 是吧？ OK。好，那么它这里面就做了哪些针对性设计呢？其实我们之前的课讲过的话，
31:29大家相信应该都会比较的熟悉啊。比如说第一个点，我们说我们要减少这个 hattboall 的访问。好，那么这个这个这个这个它怎么减少呢？我们讲过一种方法是这个 cool 的吧。
31:41那 hatchcool hadge 的问题是什么？他这边讲的是说我 get 很好，但是这个呃这个 put 的性能很差， inserort t 性能很差，那怎么办？他用的一个方法其实就是这个 chaining，
31:51就是就是我们说 change 还泄漏。但唯一的区别就是他把那个 chain 的这个 buket 开很大，就是我一个 change 的一个点能存很多个出来。那这样的话我的次数不能减少了。那这个设计其实非常非常垂牛。而且之前这个 RDMA 的这个 QS go 然然底下 TM 对吧？
32:04里面其实也是有那个类似的这样的一个设计。所以我们看到它这一块啊，这一块基本上都是用什么？都是就是用这这个这这个这个 RDMA 这样设计。那解决的问题什么呢？就是第一点，
32:15就是我要把这个 DMA 的刷机上和这个 DMA 刷机上。对我们。所以我们看到一个点，就是说你虽然我的这个网卡变成 smarank，对吧？你在 RDMA 下用到的一些这个 designed，
32:25这个 principle 啊，其实也是可以用到的。当然了，它这边其实做了一些更复杂的设计啊，我认为有些有必要，有些可能不一定有必要。
32:33什么意思呢？它在这个 q 九二卡本来讲它是学术界的工作，学术界工作我们要做全全一点，对吧？那怎么不做全呢？就是我这个 QSS 呃呃做很多功能，
32:41对吧？我不仅仅能做一个查找，我还是要做什么，做一个查入删除。所以呢它在这个网卡上啊做了一个这个做了一个这个这个这个这个这个这个这个这个这个 slam located 啊，其实基本上就是这个我跟我们这个八 dilocaate 非常像，
32:55对吧？其实就是说啊我需要在网卡内啊去做这样的一个做做这样的一个内存分配啊，那这个时候他发现一个问题，就是我的这个 FBJ 啊，做这个网卡内存分配的这样一个操作啊，非常非常慢。
33:07那这个时候怎么办呢？它其实做了一个这个 hybrid 的这个 design 嘛，其实就是说我的这个内存这个分配哎，放到这个这个 host CPU 去做啊。然后我这个网卡呢，他只是去 cash ch 这个 server 的这样一个缓存的这样的一个结果。
33:20那这样的话我这个网卡分配其实就非常非常快。那它唯一区别什么呢？就是我可能啊当我的这个 host 的这个没有 think 过来，对吧？它可能这个这个分配器稍微有点旧，但这种情况下我们知道应该是比较少见，
33:31对吧？你分配器大部分情况下啊的这个这个这个容量应该都是够的。所以说啊这种这种设计的话，它其实它算下来，基本上我的这个只有什么只有我的这个本地的这个 cash 的这个啊这个这个这个 slag 都不够了。然后我才要去放 RDB 访问，
33:45那这其实是非常非常罕见的。所以说它平均下来啊只需要零点零七次这个 DIV 访问，就能够做一次内存的这样的一个准备 OK。然后呢，那还有一些问题就是说他去做一这个这个做做做，这隐隐藏 PIINTS 什么意思啊？
34:00就是我们就时说你 cite 发一个请求，对吧？然后你你往得去触发一个这个这个 PCIE 的这样一个 transaction。然后如果你等这个 PCIE 的这个 transaction 做完了，对吧？然后我再去这个这个去做 kind ite 发下一个请求。
34:14那它其实有一个严格 dependency，那你的这个 FPG 的这个流水线啊，它不就是这个这个被 broloction 嘛。那所以呢这个它做了一些这个 cash，做了一些 catch，使得说我的这个这个说哎我来了一些请求之后，
34:27我能不能就是说不用去这个这个这个我把这个 value 给。比如说我访问去同一个这个 value，用同一个 value 的话，我就把它给 catch 到这个这个网卡上。因为我们看到网卡其实有大概四 GB 的这样情况。那有这样的话，
34:39我这个 catch 我能够啊消除了这个 latency 部分，也是一个啊比较直观的这样的一个设置 OK 请。然后他有介绍失业对吧？然后最后的话他其实就是跟我们说的，就是你既然网卡有这个 cash 减少 PCI ennez，那我甚至可以 catch QRS ore d 吧。
34:55我使得说我得不得把这个大量的这个请求这个这个一部分请求给缓存。在这个 on board 就是这样的一个这个 developy。那其实这个思想也很简单，对吧？那有了这样一个设置，我们其实可以看到就是啊它这个 KP cash 的思入库是非常非常高。
35:08为什么？因为它的数据库的不仅原本的这个 RDM 的思入库，如果你网卡杀了一个没有，它就 boulneck 在什么 boulneck 在你的这个 host 这个读取的思路库的。但如果果你是这个这个玩法上有一部分额外的这样的一个算力，对吧？
35:21这个问题开始闭掉了。那我其实是可以这一部分下面会提供一部分 free 的这样的一个这个这个吞吐。因为这部分的右边的这样的一个吞吐，它是其实是啊 btt neck 在这个这个这个这个这个这个这个 PCI 的这个带宽啊，吞吐的其实很难干掉。但是你左边那个吞吐其实 free。
35:37那么这样的话，它其实最后你把这个两个这个啊吞吐加起来的话，其实就能够那个获得一个一个相对高的这样一个吞吐 OK。那么所以在这边工布展示的展展示的实际上什么就说 OK。好，我既然如果有一个这个这个啊这个这个这个我们说硬化嘛硬化它带来的性能是最高的性能。
35:58它这边我们说衡量这个硬化的这个性能是怎么衡量呢？我们是会衡量它的这个 per water 的这个性能什么意思？它实际上是要在比较相同能耗的情况下去。因为你如果能耗啊这个这个这个这个这个不一样的话，你就比较没有什么意思了。什么意思啊？
36:12比如说我有一个 server，对吧？它有一定的能耗，我你觉得它寸的不够，那我怎么怎么办？我其实可以把这个 server 给的计算，
36:19对吧？我把它的这个 super 的，其实类似于 data parwer 的方式把它给扩展上去。那么这样的话它的 suput 其实可以达到非常高。但这样的话，你去比较啊它的这个这个绝对的性能其实没有意义。
36:29因为什么？因为你会用更多的这个能源。所以说啊这边的话这个 KB 第二呢，它比较的这个啊性能，一般是说它比较的是这个你在这个 prowatwater 啊 per 就是说你每耗每用电一瓦啊，这个这个能达到多少性能。
36:44其实我们可以看到它的这个每瓦的这个性性能，其实会远高于现有的这些啊面这个简的 erpurpose 的这样的一个系统。所所设计的原因很简单，就是说他把这个更多的操作都放到这个这个硬硬件上，硬件上处理。当然这种方法它虽然能够达到非常高的这个能效比，
37:00对吧？但是它其实有一些啊很明显的问题，大家想看你要明显问题什么？就是说你你要如果给你一个 QS 的应用啊。好，我现在可以吭哧吭哧开发一块板子啊，
37:11比如说第二天你这个这个 QSS 的应应变了了，比如说我现在不能用还西我我用别墅，那你得吭哧吭哧得再再搞一套，对吧？这个开发成本非常高的，而且这个这个 cash table 可能是相对来说比较好做的，
37:22它是比较啊容易 palace 的这样一个系统。那如果你是别墅对吧？来想你就依靠别墅怎么去放到这个 KV 看啊。不不不不不不， p 然上上去去搞这个事儿，其实是是小要来说非常难的 OK。
37:34好，所以啊为了啊为了这个这个规避掉，对吧？规避掉这样的一个这个啊我们之前说的这样的一个这个这个这个这个你一个非常的这个 specialization 的这样的一个网卡所带来的这样的一个这个编程开发上的这样一个问题呢。其实现在的主流的这样的一个斯巴利卡，它基本上是属于一个可编程高可编程的这样的一个一个一个状态。
37:58但是我们会发现一个很重要的点，就是当你的这些呃网卡它一旦变成了非常高可编程的话，那它的这个使用的复杂性会会很多。就是它它它实是是超变编。什意思就是我们我们六维的编程是说我们把一段逻辑放上去，能跑我们就算算，
38:16对吧？但这个其实不是我们说做系统工程的一个一个全部。因为你放上去跑它跑的非常慢，那这个事情本身也是不对，对吧？我们理论上说是是希望它跑的跑的非常非常快。
38:26那你跑跑跑非常快，非常非常快的话，它它你光把一个简单的应用实现一下，其实是其实是不行的。你还是得对这个硬件和它的背后的这些些理做一些非常深入的呃理解解，能够做的哈。
38:39那么那么其实就会有一系列的工作，包括我们自己工作，对吧？其实就是在对啊这个上面的这个一系列的这样的一个机理啊，去去做了一些比较深入的研究。然后我们会发现就是现有的一些学术的工作，
38:52包括 best paper，对吧？有一些 toursper 的 best paper。那我们会发现他这个对硬件根本就没有理解啊，导致结果就是它它的这个设计上啊，注意是从设计上只能够用满这个网卡一半的这个带宽啊，
39:05这个其实是非常非常糟糕，我认为是非常糟糕的这样设计。所以所以说我们认为这个理解硬件的蒸汽性是是非常的的。好，行，那我们现在来理解的一下的话，
39:13就我们来看。最后我们大家会看一下这个这个这个一个这个这个英伟达的这样的一个 DPU 啊， DPU 的它的这个这个这个性能分析，好吧。英伟达就是啊对，但但他但那个网卡公司本来不是属于英伟达，
39:25它是叫 melux，但是被英伟达收购了。所以我们也认为算是英伟达卡 OK 行。我们说左边是一个这个是这一个传统的 RDV 网卡。我们再回顾一下，就是所有的智能网卡呢，
39:39就尤其是像英伟达这种厂商的智能网卡，它都不是一蹴两就的。它是通过这个几代眼镜的一个核心的原因。就是因为你如果提出了一个啊跟以前网卡完全不兼容的卡的话，基本上是没有人会用你啊，很少有人会用你。
39:52虽然它是从这个它的智能网卡是从一个 RDV 网卡演进过来的那什么叫 RDV 网卡呢？我们可以在 RDV 网卡，其实看起非常非常简单。就是它其实就是本质上就是我一个网络包发过来 OK。我这个网卡上有一些这个硬件单元，它实现了什么？
40:07实现了你这个网络协议，我们称之为 decall。这个 decall 呢它会把你的这个协议翻译成这个文塞列的求三列的请求画上客户端 OK 这样就行。但这一套方法它的核心问题就是这个没有办法编程，对吧？就没有具备任何的这个可编证性啊，
40:21除了一点点的这个可求的请求，基本上不会编程。所以为为了增加可编程性，我们说计算本质的什么，你就是得有得有能可变能算的这个这个资源，以及你还要要存数据。
40:33对吧？要内存。所以说智能网卡它其实比起这个阿 DV 网卡呢，它它其实就在旁边加了一个这个东西，加一套 SOC。然后这个板子上有什么呢？
40:43有第一，它会有一些这个 rum 的这样的一个 SOC 啊，能够使得说你可以做任意的这样可编编程的这样的操作。然后呢以及它有一块 on board diim。就是我们前面其实在看 KV direct 的时候，我们也看到过什么这个 diim 其 on on board。
40:59这个 gim 其实非常重要。因为你没有这个东西的话，你不都开始说做不了 OK。当然它还有一些这个这个加速器啊加速器能够做这样 h 好使，使说什么么思啊？就是你大大家觉得这个玩卡其实就非常有意思啊，
41:11使其实它是有两条路径，什么意思？就如果你要走 RDV，就你不要用它的可编程性啊，它是可以正常的走原本的这个 liink store 去访问的那一旦如果你要你要走可编的事，那那它其实 RDV 啊，
41:22它就会把这个呃包给服务的到这个可编能可编成这样一个设备上。这个可编的设备，你就可以去用来去操作这个做做这样一个计构。好，就这样的一个架构。然后当时有了这样的一个架构呢，
41:34我们去做了一个分析，就是说我们哎我们是不是想说我们对 TI store 比较熟悉吧，那我们就去看看，对吧？我们能不能用它去加速 TIS store。好，
41:43我们说原本左边是一个用 RDV 的这个 TI store，这个这个大家相信都很熟悉，对吧？我要我要用房子 QS 做的话，我就先用一个 RDV 去读一下这个 index，然后读它这个 value 需要两个 raw trip。
41:54这是这是基于 hasshape 的这个 RDVQS 做的一个非常大的痛点。那我们当时说怎么解决呢？那我们就是说既然这个我有个可编程网卡，我就不需要走那么多个 wrw trip，对吧？我直接发一个网络包到这个网卡的这个 SO 可编程的 SOC 上。
42:11然后这个 SOC 去帮我们去做这个 QR store 的这样的一个操作。好，这个问题能不能能不能就解决这个 RDV 的这个问题呢？我们做了下发现不行啊，不行，左边是说这个红色的啊，
42:23这个是我们之前自己实现的这样一个 RDBQSO。我们发现这些它它性能还挺好的，对吧吧到这个版呃 nose 五十二左右。但是啊我们发现一旦我们就简单的把一个功能给卸载到卸载到这个这个这个这个智能网卡上卡，发现啊它的性能非常非常差啊，非常非常差。
42:39而且这个基本上我们会发现那个硬件已经跑满了啊，跑满是指它算力跑完了它的这个网网网速肯定没有跑完好。我们发现它的性能其实只有一个这个这个百分之十四的这个阿里 max s 了。这就是导促使的就是这个说我们去去做一个这个做个研究，去看看为什么，对吧？
42:57我一个非常简单的功能，我确实能把它放在这个 smart 的上。那为什么我把它放在上面去，性能性能确实很差呢？我们发现这里面的一个啊核心的一个痛点。其实是啊现有的这个这个网卡，
43:12尤其是 off pass 的智能卡，它的这个架架构，我我们想象中的要要要要复杂很多。什么思思在想，左边是我们的这个啊这个这个这个这个画的这样的一个这个啊这个这个这个我们之前以为就是就什么意思，就就我在 RDV 的这个网卡的那个 call 旁边。
43:28好，我去给大家加一个 SOC call 就行了。但实际上我们我们我们去做了一下各种分析之后，我会发现它的这个整体架构长得会非常非常复杂啊。大家注意啊，这个架构实际上是我们通过这个各种实验去逆向出来的。
43:42并不是啊，并不是它的这个官方这个这个文档有，如果官方手册有，其实这个东西就会变得很容易，对吧？我们会发现它的这个呃 new call 和这个 SOC call 之间的这种各种互联的这种方式啊，
43:55其实有非常多的这种奇怪的啊，也不是说奇怪吧。就是说复杂的联系连接方式，然后不同连接方式，对于不同的网络包，或者说数据流的这个性能实际上是不同的 OK。
44:06然后如果你不不了解啊，他们之间的这个性能的话啊，其实其实你直接把一个东西很傻傻的扔上去，其实你的性能其实就就会就会非常傻 OK。那我们就带大家看看，对吧？
44:18这个后面到底有什么样的一个性能上这样一个问题。当然我们需要说的是，就是说其实你关这样一套智能网卡对吧？到底该怎么做啊，怎么做这个事情其实是是是之前有很多人研究过的啊，当然这个这个之前的研究啊，
44:34他们主要关注的点什么呢？关注点是右边这一块，就是说我的这个网卡对吧？它这个其实也有一个小的 hierarchy，有这 catch 有这个这个方啊，他们关注的点就是说哎我这个网卡虽然它的这个对不自己的这个防存的如何，
44:48以及啊它自身的啊这个算力如何啊，然后这里面有一些结论，其实我觉得都比较直观啊啊然后这的这这个网卡的这个这个这个这个 CPU 的这个算力啊，它虽然是 CPU，但是它其实会比这个 host 的这样的一个这个这个这个这个这个这个算力要要一个数量级。这原理其实大家也很很直观，
45:09就是我的网卡。大家想想就我们造一个硬件对吧？我我不是随意的造就每一个硬件的这个 server，它它会有一个个务功的这个个制制。那后但是现在如果你不考虑 GPU 的话，你的一个服务器它的功耗的大图是吧？
45:24其实是 CPU，对不对？那我如果要造一个网卡的话，我其实作为一个协处理的这种设备的话，我的这个功耗是不能够比这个主设备去高很多的。所以导致这个结果是现有的虽然是智能网卡，
45:36对吧？这个智能网卡它的这个功耗其实也一般，也只有这个 CPU 的这个啊几分之一几分之一。那么大家想想我大家都是 CPU，对吧？我功耗只有你的几分之一，
45:44我凭啥这个这个我的算力会跟你差不多的。所以说这个这个本身第一，它的这个 SOC 的这个算力啊是相对弱啊，这个事情实际上是更加更加更是比较直观的。但是呢我们会发现这个除了这个算力之外啊，他们之间的这个这个网卡，
46:02它你导导呃它引发的这样一个数据流变得这个的复杂性啊，是之前人没有意识到，我们可以来举个最简单例子。比如说我们说 RDA 对吧？ RDMA 的话，它如果你没有智能网卡，
46:16我们就考虑 RDMA。那它的这个数据流实际上是非常简单的。就我一个数据包，我通过网络和直接就直接就什么九六 DMA 到这个 host 的这个 post memory。当然要注意的一点是，现在的这个这个这个 PCI 实际上比较复杂，
46:31它是 cache coherent。什么意思呢？就是我的这个 CPU 的这个呃我的网络的数据啊，它是先会进入进入 cash，然后再进入这个 c 呃这个这个内存了不不是不是直接进内存啊，但是呢好像这是第一条路径，
46:45大家想想如果有有个 smart 意味什么？因为是说你的我们前面可以看到，我们说这个四拉列它多增加了什么？它多增加了一个两个 PCI 的这个 connect 和一个这个 PCI 的 switch。也就意味着说，当我原来原本有一个这种阿里背的包 OK，
47:02我直接很简单的，我直接一过啊，直接一个 PCIE 啊，到到后损结束了。但是到这个这个这个这个这个啊啊这个这个这个这个这个这个这个呃 smart 的时候，它其实会额额的经经过一个 nap IIE 的这个一个 connect 和一个这样的 PCI switwitch。
47:20那这种额外的这个路径，其实就会啊引入一些这个信任的这样的异常 OK。好，那么除了这样的一个这个这个这个这个这个这个这个这个啊原本的安全路径，对吧？我们说要为了了支持各的的 load，
47:33我们这个 split 它支持这个通信路径，其实会比你的这个呃那个复杂很多。比如说我的这个这个这个原本一个原本一个数据，对吧？它是要访问后 st dedeg，我作为网络。
47:45但是我们说你既然要卸载我们说很大的一个能力什么？就是说你你得让这个网卡去提供一个这样的一个这个这个这个这个 catch OK。那既然提供 catch 之后，那么其实它就会有一个新的这样的一个数据通路。就是我要这个网络包啊、 nequo 啊，
47:59直直接走到上上的这样的一内内存，上上这内存，那本身这也是会有一一些这个额外的这样的事情。 OK 啊，最后的话，就是说我的这个我的既然要卸载，
48:11对吧？那我的 SOC 其实就需要和这个这个这个宿主机的这样一个内存的这个数据进行交互。那怎么怎么在 SOC 和这个 hos 接去传数据本身也是有一个非常非常啊也是有非常多需要考虑的这样的一个点啊，考验一点。所以呢我们之前做了一个工作，就是说我们把这个呃 smarlic，
48:32然后后 SOC，然后 swt 上上 SOC，还有宿主，还有这个这个看这这边三的所有的这个路径啊，我们都做了一个非常非常啊深入的，相当于有点类似于这个逆向的这样的一个分析。
48:45然后我们的这个分析结果啊发现了一些就是现人他其实不知道的这样的一个 smart 这个使使 patten。然后有了这样的一个使用之后啊，我们提提出了一些相应的这个概念啊，可以去啊去优化这样一个 pattersmart 的访问。那最后的一点时间的话，我们就简单的一个一个过一下这结论。
49:04这结论其实啊他其实并呃从直观上来，他并不难想到啊，但是怎么去发现这些这些这些现象，其实我们是做了很多的这个实验啊，我们去分析这个硬件，它是它这个能暴露的一些这个和克斯 counter 这些数据去做了做了一些啊分析才能得到。
49:21也其实看其其实结论看上去很区别啊，有些结论看上去很区别，但是但它其实有得到的过程并不是很区别啊。其实首好，首先我们现在看第一个啊有有比较有意思的发现啊，这个这个发现比较吹别，
49:34但是我觉得也是值得一提的，什么意思啊？就是我们会发现你如果用了一个 smart c 然后你只是用它的 RDMA 去做通信的话啊，其实你还不如买一个买一个这个这个你不不如不用 smart。也就是说我的 RMAI 它对于这个 RDMA 的这条通路啊，就是握底把它做 RDA，
49:53它的性能是比一块同规格的这个网卡啊去去去去作的。在这里我们怎么去做这样一个时间时，现了我们啊我们先休息好吧啊，待会儿休息，我喜爱。对，
50:39你是嘘是嗯去是因为嗯哎呦对呀。