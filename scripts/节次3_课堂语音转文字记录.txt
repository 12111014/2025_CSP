00:00方向盘的轮子，四个方向盘的车子，它的通用性是最好的。因为你可以控制每个方向盘，你一定能够让那个车适应各种各样的场，它肯定比一个方向盘的适应性通用性要更强。
00:14但是我们不会这么去做 OK。当你看到一个软件密密麻麻的调控制参数的时候，你就知道哎这个事情就这个绝对不是用户最终想要的，对吧？包括我们今天用这个大模型，大家真的去调过 tem 这样的参数吗？
00:30对吧？理论上你要调真有啊，你可以调好多参数。但是太 general 去后发用户也不会 avoid the really use component。如果有个组件很少用，大概率它会出一题啊，
00:46大概率就会出问题。所以要避免你你在 OS 里面的话，有一个说法叫做热闹的马路，就不长 bug。就如果有一个系统调用，它频繁被人调用在 OS 里面，
01:01最常被人调用的系统调用是什么？是 open rear， right close。这些信用调用这些信用调用已经被调了无数次了，它如果有 bug 早被人发现了。但是呢有一些犄角旮旯的地方出现了一些几百年没人调的这个信用调用。
01:17这条路径上可能就有问题。然后呢，还有叫 be explicit，不要藏着所有东西要公开，要公开啊不要藏着掖着啊，尤其是出 bug 的时候，
01:30要把那个 bug 啊明确的写出来，不要因为不要毁机计一对吧。反正什么东西藏起来，以为就能藏起来就能藏住。但是不的，我举个例子，
01:40比如说我们说 linux 和 windows 哪个安全，我们看 bug 的数量绝对是 linux 要多。为啥开源这么多眼睛盯着他，找找 GG 可可劲劲的找 windows 不开源 bug 的数量可能也只有 windows 的一个程序员能够去 report。但是事实告诉我们啊， linux 要远比 windows 要安全。
02:04原因就是因为 linux speak explicit 啊，他们强强调的理念就是一半双眼睛盯盯着之后啊，这个就不会有不会有把不是绝对的。有些东西开源了也没人看，反而是把自己的 bug 暴露出来，也没有意义，
02:20对不对？所以呢我们说都不是绝对的。然后 the couple vididules with indirection 啊，这个呢就是嗯叫叫高内聚低耦合对吧？就我们本科的时候，在软工上学的啊，
02:36高内聚低耦合。然后你要有一个举举个例子，你你你开就我们我们前段时间开了个会对吧？我开个会要有一个联系人，要留一个邮箱，你就不能留你自己邮箱，
02:47要留一个中间的邮箱，对不对？对，如说校长信箱绝对不是丁校长的个人邮箱，对不对？他一定是校长艾特 STTU 点 EU 点 c 对吧？
02:58这样的话，你往那儿发，你也不知道谁收的啊，就是 indirection 啊，这样的话就可以比 cople 啊就可以哎更灵活一些。 design for interertion 不要指望一次就能够完全搞定，
03:11快速迭代，快速尝试，快速试错，对吧？这样的话才能够真正做到这个系统的这个让系统啊，它是始终处于可以运行的这个阶段啊，
03:21然后呢去获取反馈，不断的改进。互联网厂商对这些都非常了解。硬件厂商说实话了解的，我感觉没有互联网厂商那么的那么的透彻啊，透彻。
03:35 keep single， keep stupid，我们要让系统变得更简单，奥卡姆替代原则对不对？就是当我们看到其实这个根植在我们脑中，对不对当，
03:43我们看到这样一个公式和这样一个公式的时候，我们想当然觉得这是对的啊。告诉你说世界的本质是这个公式，你觉得你说世界的本质是这个公式啊，他们觉得哎呀太美好了。我感觉这个对于简单性的追求啊其实是一种本能。
03:59 ok 所以毕加索呢当时就在追寻，他说啊我用多少怎么样能够画一匹马，画出来就让人觉得这个确实是一匹马。同时呢我就很简单，虽然他就不断的在尝试嘛。这个这个画虽然他当时画了一匹非常简单的马，
04:14这是世界名著了啊。然后呢哎他还画了一匹，更简单啊，看着也是也是匹马。你看这个感觉跟简笔画也没什么区别了，对吧？
04:24你说你要是不说是毕加索的话，谁能知道呢？然后还没有停，对吧？你看它还有一个比加速哈他一直在追求这个简单的精华啊，里面能看出来这什么，
04:39这是最简单的这个追求。你再看看 case，你看这个这些 case 就是简化这件事情，本身它的代价是什么啊？不是说我们很多时候就要讲这个正反面，对不对？
04:51简化当然是好，简化。当然好，大家都知道，但是简单是不是有代价。这个呢就是我们说的这 shellshock，
04:57这个攻击一四年，它的 CVE 是这两个 CVE。然后呢，它运行去测试也很简单，就大家只要在自己的 bash 里面运行这么一行代码运行到这儿。如果说出现了这个 best is vulnerable，
05:17表示你的 bash 是有 bug 的。为什么这么说呢？是因为大家看啊这源代码跑了个啥，就是嗯大家看大家看这里是个这里有一个哇，对不对？大家知道哇，
05:34就变量的意思对不对？反正就你不管它叫什么，反正就瓦等于等于是一个负值，对不对？负值赋值之后，这里有个单引号，
05:41单引号到哪结束？到这儿结束， ok 到这儿结束，换句话说，你别管中间是个啥，你别管中间是个啥，
05:49它就是一个负值。负值，什么是负值啊？负值是把一个东西，把这个把把这一串赋值给他，就是这个东西，
06:00大家看这是啥？括号表示它是一个函数啊，这个函数就是本质上是一个函数的定义。 OK 本质是个函数的定义，就是值就是一一个括号加上一个这个这个括括号后面呢有这样这样这个 apple apple 是一个指令，对不对？
06:12它是这个合在一起本身它只是一个字符串，它只是一个字符串，它是一个赋值操作，本质上就等于 y 等于一是一样的， y 等于二是一样的， OK 是一个复制操作。
06:24然后呢，它的后面有一个 bash 杠 c echo bash test，这是一条指令 OK，它相当于是先赋值再运行了一行代码，对不对？问题是什么呢？
06:36问题是这个办 sh 把这行代码把它给执行了。也就是这里有一个 echo bash is vulnerable，就这行代本本身它在一个值操作作被被执了了意味着什么？这为什么呃想说清楚？这意味着我如果能够去赋职，我就可以去执行，
06:58对不对？你想这是一个多大的问题。事实上我们在当时啊有很多的这个 web 的这个 server 是用 CGI 写的啊，是用 CGI 写的。 CGI 呢，大家现在可能还了解不多了，
07:11 CGI 的后台就是 bash。然后当你的 HDB 去访问一个 CGI 的服务器的时候，是允许你在前面赋值的 OK，就允许你在前面复制。如果你的 CGI 的那个的 basserver 有这样一个 bug，然后他允许你复职，
07:31你又可以在这个里面通过加上一个括号发括号。这本质上是这个这个地方解析的时候出错了啊，本来就这儿解析，然后你在后面放一个，把这个 echo 替换成一个什么替换成一个新建一个 best，或者新建一个开一个这个开下载一个什么软件并且运行，
07:51对不对？就意味着你可以让这个服务器都成为你的肉鸡啊，就成为你的控制的这个体系。所以当时这个 bash 出来的时候啊，这个 best 的 bug 出现的时候啊，它叫销售。
08:06那确实很 shock。哇，一堆服务器啊，这个攻客黑客拼命在那试呀，又多了一台，又多了一台啊，
08:14这个多一台就是肉机，肉机就可以用来 for fun and profit，对吧？然后呢这个这个服务器管理员各种修复说啊怎么办怎么办？我们赶紧把这个线升级。那这个呢就是我们说当时一四年的时候发生的这个场景这种事情。
08:29每年然后这个广络媒 iting 呢，这个细节我就不讲了。大家感兴趣可以去搜相关的这个报道，以及它的背后的这个原理是什么。最终就是刚才我说的一句话就是哇就就这一行代码这行代码在解析的时候啊，出了出了错误啊，
08:44就是这个 passer 啊，这个 passer 啊，我们各各位要看啊啊个 passer 在计算机里面有很多 pass，有很多 pass。 pass 就是你传进来一个字符串的一个结构，我转换成另外一个结构，
08:59就是 pass 要做的事情。 OK。然后呢，这个为什么很严重呢？是因为 ENV 这个是这个环境变量啊，环境变量这个赋值是常常用的这个操作，
09:10甚至连 DHCP 的这个 client 和 DHCP 字都有可能中招啊。 DHCV，大家可能不知道啥，就是你连到交大的时候，他给你分配一个 IP，对不对？
09:20你不用手动去设，这个是 DHCP。好，那为什么销售额会存在呢？其中一个很重要的原因啊是什么呢？就是 unix 的环境，
09:32 unix 编程啊它有三个原则。第一个叫做我们要写小程序，不要写复杂程序，这是第个原则。第二个原则是我们要让小程序在一起工作。他们之间像乐高一样拼拼拼，
09:48能够拼成一个更复杂的一个一个程序。所以大家学 uniqux 编程的时候，其实经常会学到管道，对不对？你学到管道吧，对吧？
09:56 GLS 杠 grab 对吧？ TXT 他就能够把 LS 里面所有的 TXT 把你给 grap 出来。那 grap 本身就是一个小程序， AOS 本身也是一个小程序，这是它的两两个原则，它一共三个原则，
10:16前两个原则。第一个则则不要写复杂的程序，写小程序。第二个叫做把小程序把它组合在一起，去完成更多的这个更多的这种第三个原则，叫做程序和程序之间的流动，
10:30必须是 text triam 啊，必须 text stream。 next stream 就是人可以读懂了 text，你不能是白个 ry， OK，更能是关注。
10:39你说那为啥呢？其实我觉得原因很简单，就是因为 text 是一种大家公认的一个标准。就比如说我如果在这个过程中，我想要看一看 LS 到底传给 grap 什么东西的，我一个人就可以站在这个位置，
10:56可以把里面所有东西全部都读出来。我人是不够懂。 ok 我人是读得懂。同样 grap text 之后，如果他还要再传给一个别的东西，他依然是以 text 的方式去传。
11:07这样的话呢有任何 bug 人就可以直接反过来。如果不传 text，我传什么呢？不是说班主任我传一个数据结构啊，我通过 RPC 去传啊，我定义一个数据结构去传也可以，
11:22这么做就很精确，就很精确。但是呢有个缺点就是人读不懂二进制，对不对？人家读二进制你要很翻，你要翻译很多东西，
11:29这是第一第二。就是如果真的是二进制的话，那就意味着这个管道的左边和管道的右边，他们必须要对同样的这个定义有一个有一个认知，他们要他们要在这个上面达成一致，对不对？
11:43就是你得预定义，你得有个点 h 文件，左边右边要共享这个 h 文件，你才能够才能够让他们之间进行通信，而 test 就没这个问题 OK。所以呢当时 uniix 呢就认为所有东西都要都要去 test 之后呢，
11:58就出现了很多很多各种各样的问题。比如说 LS 杠 l 星点 c 它就会竖大，然后 LS 杠 l 就它它 LS 杠 l 星点 c 就变成了 LS 杠 l 和星点 c 这三个。然后呢，七点 c 呢就对应了这个负点 c 和这个八点 c 然后呢它就变成了 LS 杠 l 负点四一和八点四，它这个就做了一个扩展。
12:23但如果有一个文件，它的名字就叫杠 l。你说谁会给人家企业感，我就我们就知道杠呀。结结果发现，你记得如果你的文件里面有一个文件的名字叫杠 l，
12:37那么它执行的你 LS 星点 c 最后直线下的效，就 LS 星直行下的效果啊，就跟 LS 杠 l 星是一样的啊。因为他把那个杠 l 啊，他把它认为是个参数了，为什么？
12:52因为这是个 taxt trip， OK 这是一个 taxt trip。正因为 best 里面这个参数都是通过 text stream 来传的，所以呢他就很复杂，杠杆还算是简单的，我们能理解的对不对？
13:08你还有这个 dollar，然后里面执行个再一个躲轮对吧，你还有两个躲轮，然后呢你还有可能一个花括号外面套套一个躲轮，然后你还可以一个花括号里面套一个括号，括号里面再套一个大括这个这个大括号，
13:24这个呢就导致了这个 best 的 paspasther er 很复杂，明白了吧？就 best，它必须要去解析，很复杂的这个 tax triam。因为格式是不一样的。
13:36在解析的过程中就出现了我们前面说的 shelshop 这个问题。出现这个问题，那就导致了各种 bug OK。其实这个问题如果我们用二进制，其实是没有这个问题，大家不需要爬死，
13:50但是不会。因为大家觉得我为了简化，如果真用 pass 的话，整个 unix x 系统会变得很复杂，所以我感觉有点死。宁可牺牲掉这个偶尔带来的这个 bug 带来了巨大的 shop，
14:08他他他认为这个确实是有可能的。但我也不愿意为此把我这个 text stream 改成比如说二进制，所以呢我们说 simple 不一定是 better。 ok 就像这个毕加索画的马和，你画的马可能就不一样，对吧？
14:26这个就就我们说的，所以呢，这个是我们说的，这个前面几个点就我们有几个点，就是 sympllist symplicst。然后呢 being visit 这些，
14:36我们前面都讲过了，就不再赘述了啊，就不再赘述了。好，然后继续看这个 design principle 继续的啊 android argument 啊，这个我们只能先简单先讲一讲啊，
14:48就我们贯穿整门课，其实都会讲这些赔则。 and to an argument 是说这个系统啊它不要去做太多上层要做的事儿，就是应用程序知道自己要啥，你不要帮他去做决策啊，就是我们说的这个 n to m 就好像你你小孩喜欢这个，
15:12你说不要你不喜欢，我告诉你应该喜欢什么不行，他喜欢啥就是啥，他知道自己要什么。 entry an 就就在就做书做这个事用。然后呢，
15:23底下还有一些啊，这个这个其实有很多啊，就是后面我们会一个个去讲了，这个这个就不在这里去展开了。这个我现在讲大家有没有感感觉，我们还是讲个例子，
15:32比如说这个 arguscaling 对吧？ scaling，比如说我们这有一个 PPT，然后呢你选择之后，你做一个 steily 把它变大，然后你发现就一团乱了，
15:41一团乱了。所以呢这个我们说这个 skiling 本身啊，其实在 system 里面是很难的一件事情。此外呢还有还有很多 general 这个 principles 啊，就是这个这个 robust robuprprinciple、 safety、
15:55 margin 等等。这里每一条其实都有后背后都有很多故事啊，我们希望能够通过故事来讲这个 principle，而不是简单的去记。其实这里还有 golder ruauautomaity，对吧？
16:05就是如 one writer principle 啊，就是当我们有多个数据库的时候，我们希望只有一个 writer，这边都是 reader， reader 可以有很多，但 wrier 能有一个啊。
16:14然后这个这个这个这个 security 方面还有很多，这里有一二三，后面还有四五六啊，大家可以先看一下啊，我们会看到在未来的过程里面会看到更多。 ok 好，
16:26我们再来看一个 case，就是这个拉马点 CPP 拉玛点 CPP 啊，这个大家都用过吧啊，用过吗？这个如果大家想要在本地跑大模型的话，基本上都会用到这个八八点 CPP。
16:43然后呢，它是一个用 CPV 写的一个推理的一个引擎啊，速度很快。然后呢在二零二三年哎呀，一晃都已经两年多了。这个当时呢就有人二零二三年的三月份，
16:56当时有人提交一个 pad patch，说我们优化了一百倍啊，一百倍啊，真的是这个标题党，这个全世界都有啊。然后他为什么要提高一个倍？
17:06我看说什么啊，那个一百倍最有意思的是，它是这个他四月一号发的啊，四月一号发，然后呢他提高一百倍，但是哎真提高一百倍啊。
17:18大家一看哇塞，我提高度启动速度提高了一百倍啊，但是它的运行速度呢比原来慢，为什么呢？其实他就是做了一个 memory map，就是他本来拉八点 CPP。
17:30比如说你有个三 b 参数的一个模型，他把三排三三条全放内存里面去之后，才开始开始开始给你做推理，对不对？他做了一个慢慢 map OK 就是做。他说哎我把这个三 b 从磁盘映射到内存。
17:45好，接下来我来做推理。那你映射一下，你就改个页表去，你根本不需要做这个漏 ad 的过程。但是你在推理的时候，
17:53那就一堆配置一堆堆配 forhofhold 去搞。所以推理就变的很慢。但是它映射的很快，它还有好处就是当内存不够的时候，比如说我有一个三十 b 的一个模型三十 b 但我内存只有十六 g 原来已运行才告诉你内存不够，现在就不会告诉内存不够，
18:12现在告诉你可以跑，而且确实在跑，但就是速度非常慢，对不对？因为你你想你这个十六 g 内存，你要拖一个三十 b 那就大量内存交换换页啊。
18:23所以呢这个功能呢，当时四月一号的时候呢，哎你看美国是美国时间是三月三十号啊，我们这时间是四月一号，对吧？然后呢他就他就这个这个就放上去。
18:33放上去之后呢，大家觉得哇太棒了，我以前都不能跑新能跑了，没过几天就被撤销了啊，所以也不是也不是也不是完全的这个越越越，越快越好，
18:44对吧？要么看后面的这个这个整体的这个时间成本。好好，我们再讲一个 principle 叫做 worass better 啊， worths better，这个非常有名，
18:54就 rrichard garbriel。他曾经在一篇文章里面提的这个叫叫 worths better。这个呢就是说我们前面说的叫做为了简单，我可以放弃正确啊非常极端的一个观点啊，我们来看他怎么做的。当时呢是这样啊，
19:09我们来看一个 user program， user program， user program 呢它会做一个 system call， system call 呢就是会进科 rent 对不对？又不跑啊，进科 rent 进 current 之后呢，
19:19就回来之后继续往下跑。就是原来做啊，然后呢你看啊这个这个哎然后这个到这一步的话，就 PC 等于 PC 加四，继续往下跑了。然后科隆呢就是从这个地方开始往下跑，
19:33然后运行完之后呢， i return i return 之后呢，再回去到这儿之后呢，它继续往下跑。本来是这样一个流程，跑到这儿就 t's go 进去，
19:42跑完回来从下一行代码开始往下跑。这是现有的这个做法，是这样，一切都很合理。但是当时呢就遇到了一个问题，就是一旦在 kernel 执行的时候，
19:54出了一个 interrupt kernel 执行的时候啊出了一个 interrut。而且这个 interrupt 呢 neo 自己没有办法 hold hold 住，没有办法去处理。在当时说实话，我不知道为什么当时就是一个很大的问题了。但当时就这个很大的问题，
20:06当是产生一个争论，就是当我内核处理不了来自外部的一个中断的时候，我应该怎么办？两拨人就有两个观点。第一波人呢，就是说我们应该让 kero 处理不了的事情，
20:20你你磕都处理不了，对不对？跟我用户没关系啊，跟我这个用户端应用事情没关系。所以你应该把整个的现场恢复恢复之后再来一遍。这一遍你要期望他不要出错，
20:36 OK 不要呃不要发生。英特尔特。因为英特尔测嘛，你也不知道什么时候发生，对不对，你也不能老发生吧。
20:41所以但是说当你处理不了之后，你就应该回退到原来的状态，重新执行一遍，然后再返回。这个观点呢叫做 do the right things。 ok 就像我让你做一个事儿，
20:55我就不管了。你做你做到一半出错了，那你重新做好，做对了，再到我这儿来。 ok 这个观点叫做 do the right things。
21:04另一拨人呢他们说，哎呀，这个科隆要恢复状态，就意味着他要先保存原来的状态，对不对？它也不一定就发生 instruance，
21:15为了一个不一定发生的事情，我要在刚进来的时候先保存我的初始状态。完了之后呢，发生错误之后，我还要回退回去，我能不能回退回去，
21:25我都不知道。万一我写了一个什么东西，他不能回退，那怎么办？于是呢他们就采用了第二种方法，叫做一旦我出错，
21:34我就回去告诉他，我错了。然后你去处理啊，用户用户去处理啊，这个呢叫做 do the simple things，不是 do the right things，
21:44 do the simple things。你比说哪多哪一拨人选择 do the single things，哪一波人选择 do the right things？有两拨人哈，大家看这个这个这个这个左边 MIT 的教授啊，他就是说嗯 do the recase。
22:10然后呢，这个右边右辩很熟悉啊， condolson dinmonstrature 对吧？这 are unix 的发明者，他们当时在 bell lab 啊，然后呢叫自己 the new jersica 啊，
22:23 new jersica。他说我们 do，然后他们就就反过来，那 do right things，就是我们前面说的啊，就是你一旦说了错之后，
22:31 resort 重执行，重新执行啊，它有一个 resort 的过程啊，然后重新开始执行。 roll back 啊，那这里有个 roll back，
22:40对不对？有 roll back 在重新执行，然后呢， new jesy y 就是那个 demonstrature 和这个更烫实，他们就说 we do the see mothings things interrucct，对吧？
22:51我就直接 return 这儿出了问题，直接 return，告诉你我返回一个错误值。然后呢，你自己 compare 一下，出错之后，
22:57你怎么办啊，自己去做这个事。所以呢就产生了两拨人。 OK。第一波人说， FIG 的人说 simple implementation 比 simple interface 更重要。
23:11 OK 这边没问题，他也是这么认为的。第二， incorrectiness is not long intetengence 有多少个 must cover as many as possible。 completeness 啊越覆盖越多越好。但是呢如果你告诉我不一致或者不正确，
23:28我是不能接受的。 MIT 的人说什么 simple 更重要， be correct， be correctness。第二，如果 consisttion 太复杂，
23:38导致导呃 consistent，为了 consistent 复杂，我就放弃掉 sacrifice。 consistent conlainence，为了 sympmplicity，我叫 sacrifice。
23:47所以 MIG 呢是认为 correctess 和 considency 同等同等重要，比 completeness 要重要， completence 呢比 compleicey 重要。而 new droican 呢认为 simplicity 大于 anything else，包括啊包过去就行，还是很极端的，
24:07问对还是很极端的。所以呢这个这个这个最后谁赢了，谁赢了也没有所谓的输和赢嘛，就是两派不同的这个这个这个这个这个观点啊，前一派就是当时做 mltas 没做出来，为啥呢越做越复杂。
24:23后面两派呢后面两个人呢就用一个暑假的时间，对吧？三个礼拜啊，这个搞了一个 unix，成为了这个图灵奖啊，成为了这个这个我们最著名的这个操作系统，
24:34对吧？ unix 所以到底谁是对的呢？我们再来看一 case MARODC mamaproduce 啊，其实已经已经不用了啊， map roo duce 已经哎这个时代已经结束了啊，二十年曾经是非常火的所有大学课程呢都会讲。
24:51今天还会有一些大学会讲，但是呢我们要加一句，哎就不用了。我们现在看什么是 map radeduce 啊，大家应该听过，对不对？
24:57 map radedues 听都听过，对吧？那我们来看一下，在 microdeo 之之程序员，如果要去操作大量的数据和大量的机器是很麻烦的一件事情，为什么？
25:10因为程序员员他首先要想，我这一千台机器在哪呢？我怎么样把数据分成一千份发过去呢？我怎么让一千的起同时开始算呢？我怎么把一件事情算好的东西收回来呢？收回来之后，
25:23我怎么判断谁做这个这个哪些事情挂了，哪些事情没挂啊，没挂的机器，我怎么再让他发一遍呢？他没有这个框架，他所有这些事情都要自己去做，
25:33所以呢就很头疼啊，就很头疼。好，那么一旦我们考虑到机器会肥一点，对吧？会出错会废了，
25:43那这个事情变得更复杂了。 ok 所以呢，当时就缺乏这么一个框架。后来呢，这个谷歌呢就是说我们就用 map roduce 这个这个原原理，就是所有的人只要实现两个函数就可以了。
25:55一个叫 mac，一个 reduce map。 PO duce 本身也不是什么特别大的创新。因为这两个接口的话，其实是在函数式编程里面。就是有的 OK 它是从函数式编程的语言里面借鉴了这个 map roduduce 这样一个接口啊，
26:09然后呢去实现了一套框架。所以他们做的事情无非就是实现了一个底层的这个容错的，就第一是分布式的这个框架能够撒出去收回来，谁对谁谁出错了，谁的这些出错了，重做，
26:22全部是由他们底层来做用户，或者程序员需要实现 map roduce 可以那何的编程会非常非常奇怪。就是当然这个奇怪是相对的啊，比别比以前要好很多。就它有一个 rein t 和一个 in value， reduce 呢有个 outkey 和一个这个这个 list 的一个 intimedia 的这个这个 value。
26:40这个 intermedia value 来自于这个这个 map 来自于这个 map，它是从 list 里面转过来，对不对？我们来做一个 word count 啊，这个有些同学可能没学过啊，我简单说一下，
26:49就自己给个 case。就我现在有一篇莎士比亚的文档，我要统计莎士比亚的文档里面呢，每一个字出现了多少次，对吧？这其实是一个很简单的一个任务吧。
26:59你要是扔给一个程序员，他自己写不写不也能写出来。但是在 map reduced 里面，他他是怎么做的呢？他说啊程序员要实现一个叫 map 的函数和一个 reduce 的函数。 map 函数呢就是产生一堆 word，
27:11加上一个 count， count 的话都写好了，写死了就是一对吧。比如说你拿到一句话啊，叫做 check day is 这个啊 tuesday c 然后他特特别就是他出现数据意思一哎，它产生这个东西。
27:33然后如果再来一个下一句话叫做这个这个呃 he is 呃 his 宋对吧？变成了 he 多少意意思破它产生这样的东西一大堆，然后把文档呢就这这就变成好几好几块，每一块呢就产生一大堆这样的东西。然后呢，这是 mac 函数，
27:55就是把这个字和一个一 mac 起来。 reduce 呢，就是你看哎，这有一个 is 对不对，这有个 is 对不对？ reduce 就把所有的意思合在一块儿，
28:07变成了意思，把后面的一加起来，你看啊啊啊它这个 result 等于 pass。 it me 把这个 be 加起来啊，来几个 is 加几个 e，来几个 is 加几个 e 最后我不就变成了一个一个一个 list 了吗？
28:22就是任何每一个单词出现多少次都出现。大家如果去想这个过程呢会发现，哎呀，你这个中间数据很大呀，对吧？你相当于是中间数据比原来的那个差市比原来数据还要大一点点，
28:33对吧？就因因为每一个都列好长，后面还有个一，然后呢 rerece 的过程呢，你还得从这儿抽一个意思，重生抽一个意思，
28:41你要抽好久，它的效率其实说实话不是那么高，但是它好，就好在它简单，这是一个 case 太简单。 mapper 六 se 这么这么简单吗？
28:50然后呢，如果一开始也没觉得 mapper 六 dese 是一个特别了不起的发明。直到他们发现，在二零零三年引入 mapper 六 dese 之后啊，程序员使用 MAROUCE 的数量呈指数级往上涨。大大就是你看这个三月份对吧？
29:07三月份到二零二零四年的一月份，两月份三到九月份的时候，就已经跑在谷歌的数据中心里面的 MPRO views 的任务的数量就已经到一千多了。本来就就这么几个人在用啊，这个不到呃，就多少？
29:22三三月份三月份一年半，一年半就到一千个，就谷歌的任务，数据中心这种大量的 microo views，他们觉得唉是不是我们找中了一个点 swepoint 程序员喜欢他，哼这这个这个这个这个挺好的东西，
29:36对不对？然后呢，他们就就就就写了一篇这个 paper 加 mappronews 发表了发表之后呢，后面又有一系列的工作，包括 GFS，包括 big table，
29:46变成了所谓的这个谷歌三件套啊，或者叫谷歌参加马车。但是很有名，大家很好看。然后呢，整个的这个过程，
29:54其实我们前面也提了，就是先通过 map 生成一堆 key value， key value y value。然后呢在 group by key 啊，就是把所有的 is 合在一块儿。最后呢再把这个所有的 value 合在一起，
30:07让这个 reducer 把这个 b 把它给 reduce 成一个东西。当然我们刚才说的是加，这是最简单的，很有可能还不是加，可能还要做些别人操作。这样的话呢就形成了一个 map，
30:18 reduced 这样一个这样一个点。然后整个过程的话呢，有 master mode 和这个 worker node。然后这个 task 任务的话呢，就会被分分在很多 map 上面，然后呢分在很多 rerereduce 上面，
30:30由这 master 节节点决定定是 map 谁是 reducer。然后呢，我们还可以去做并发和这个判断。比如说我这个 map map map 做完之后，我这个 reduce 就可以从这个 map 开始去做了啊，就去这个是就前面我们说的一个整理，
30:47就是 source，就把这个同样的 key 合在一起可以做 read， read 最后做这个 reduce。我怎么去做？当时就引引发了大量的这个科研啊，大量的这个研究，
30:57大量的论文就出现了 OK。然后呢我们还可以通过去通过这个 reexcution 去做做这个 fortering。就是你你你 master 发现我给你一个任务，怎么你半天还不回呢，对不对？半天不回，
31:08说你挂了，我就找别人做同样的任务，反正每一个任务都是没有状态的啊，我也不用 care，你你你做完了给我，我也不要了啊，
31:17我找再找一个人。那这个事情呢就是 reexcution 啊， handle 非常简单，通过 reexcution 去做这 fautorrent。同样呢再通过这个 redundant excusion 去做 refinement。比如说有些人拖后腿 struragment，
31:29比如他就是特别慢，不知道为啥可能它这个内存爆了，开始进入 swap 了，整个机器速下降，医疗倍怎么办？那我就把一个任务直接再再扔给一个人去做对啊，
31:42做到最后一个任务的时候，把这个任务分给三个人去做。你们三个人谁第一个给我，另外两个人我就不要了。三百完全没有任何的这个难度啊，都是非常基本的东西，
31:54再做一些 lock localization organization。就是说哎我这我这 map 完了之后，数据都在我本地，对不对？我要去做 reduce 了，我就把数据给别人吧，
32:02不用，我就直接在我本地去做 reduce 就可以了。数据就不用传了，这是它的一个 localization 的这个 optimization。还有呢就是 bad record，就是我有些东西做错了，
32:13做错怎么办呢？我我我做错了，做错之后，我就直接 skip 啊，我就我甚至都不用重复 OK。然后呢，
32:21一旦发现有一个人老老出错，我就把那个节点跳过去 OK。所以整个的这个 map roo dus 都是在做这些简单的这些操作啊，每一个点说起来都是对我们本科一年级都可以理解。好，最后一个结论，
32:40 micro ooce 非常有用，一千个人在用，对不对？一千一千个 work work 在谷歌的水中间跑。然后呢，这个这个成功的把底层的 framework，
32:50就比如说要控制一台机器，然后呢发一千个任务收集回来，谁出错了，把谁踢走，谁慢了再发一个把这些东西和用户真正想要做的事情就是 mac 和 reduce 这两个事情可以结耦拍，让程序员不用去关心这个设备是如何去运行，
33:10如何去容错的 OK，这是它最大的这个一个贡献。它呢有很多体现了我们很多 principle，对吧？就是这个 relest sponshment，然后这个这个 optimize for common case 和 revissness principle，
33:22这些呢其实都比较直观好了。等到这个 number news 火了之后呢，就出现了两个 professor 哈，这个其实也很著名啊。第一个 they do with，第二就是著名的这个 michael stonwbreer，
33:38对吧？ stone break 迫使者对吧？迫使他是土地奖，对吧？因为他数据库做的多，这两个人是属于典型的学院派。
33:49学院派他们写了一篇文章，叫做 maicroduce a major staspespeackorate，就是就是历史的大退步。你们怎么哎呀，这你们这帮程序员怎么就用 number reduce 了呢？我们数据库辛辛苦苦几十年，
34:04对不对？ ACID 一套理论非常完美呃，你们这个 memory 是你考虑过 duconsistent 问题吗？你考虑过这个 transaction 的这个语义吗？你这么多机器，你以为这个光是你们那点容错就能够搞定了吗？
34:19数据有可能会错的，用 MAPRDCE 处理出来的数据跟我们用数据库一千台设备数据库做出来的这数据完全不可同日而语。你们将来一定会遇到 consistence 的问题 for toreral 问题。然后这个这个这个这个这个这个 availability 的问题，在我们数据库领域， ACID 从六几年开始，
34:43我们就开始研究这个理论很成熟。但是 number 就是一夜回到解放前，把我们也回掉了啊，程序员动还这么开心，这是想啥啊？就这他们就直接就写一篇言辞非常犀利的文章啊，
35:00其实看看学术界这些人这个在那写文章互相打来打去，还挺挺有意思啊，挺有意思的。 try and the step back up 看看什用用啊啊有意思啊，不过 still different intensive vliction。哎呀，
35:16二十五年前啊，同志们，二十五年前我们就有了，你是这个什么人，一点都不 norml。这个我们写写写 review 去插别人论文的手，
35:24基本上没有直接公开啊。然后呢，关键是你们居然和我们的 DBMS 的工具都不兼容啊，你们这个想干嘛取代我们？然后呢，这些呢我觉得啊都是属于叫 the right things OK，
35:40他们说的都是对的啊。 major sebgrate，你要这么说呢也合理啊。这个数据库的人确实 ACID 啊， transaction 这些东西他们确实研究了很长时间，就是确实也是有这些问题，
35:52但是你挡不住它容易用啊。然后呢在 memroge dus 之后，就开源就做的这个哈顿，对吧？哈顿是一个用加拉式，直到今天我还有人在用 hadoop 啊，
36:05这个都是二十年前以前的东西了啊，那我们先发现今天还有人在用啊，这个确实不够，然后呢 google 自己都不用了。 google 呢在二零一零年的时候呢，出了一个叫 pregure，
36:15二零一二年的时候呢出了一个 spanner，这个我们都会在课程里面会讲些系统。二零一四年的时候呢，有 data for 等等等等。这些呢都是不断在 mp roduced 的基础之上，不断的迭代，
36:27不断的改进。其实呢就是去 fix 各种各样的问题啊，说回来也确实就是 michael stonebriger 他们在前面 challenge 的各种问题，他确实也遇到了。但是通过不断这样迭代改进呢，他们也能够在保持简单的情况下不断的向前走啊，
36:45不断向前走。所以这是我们说的这个这个这个 iteration，就是迭代啊迭代一圈一圈一圈一圈去做这个迭代。今天谷歌确实也很多东西都是自己的一套 framework，他也没有用这个迭代 base 这一套东西。这是我们说的这个这个这个这个 simple，
37:03它不是就 keep a simple 随便这件事情并不是一个放置四条的节准等于问题。它是有牺牲，有 hiddoff 的，它牺牲了什么？它有可能会牺牲 correctinss，对不对？
37:15大家要心里要知道。它是有代价的，它不是一个半斤油，只要信厚就 ok 了。你们做好这个 correctivst 代价，你再来想这个事情。
37:29好，今天我们到这儿下课，我这个就是这是什么？这个今天晚上我不是这个招对这么优秀，保住。你对对对，
38:30在 TCFE 是是就是什们这些这些是是做。其实这些客户我感觉我实验室了，这个还有办法这个样子协程没有，晚上要，就是灯子的。然后白个这个我大家一十十万克，
38:53十万克，我们之前这么在讨论那个。对，你看他周三晚上是这个就是这个我们有一个收洲站呢，中网上班还都有很多这种。因因为是我们之前要快快军要提供这个就就这个出货的对，
39:14主要是从我们我们会有嗯或者他自己吃啊，问题也都是对哦，那拿然可以的，可可以，这是他你到是怎么样的，有必要说在肯定上来的 COC 啊，
39:41一级后面的话会有不区别。那我会有一些研究生，对吧？那我这就是自己的那个这个毕竟节究这个课嘛，所以我们差不多就是给我们三节课，差不多就是一节到一节半是会随 s 一的去校，
40:00然后后面这个没事的事情，哎呀，放了吧。好下次下次其实报 OC 是很好的 OOC。对我不好意思出去完全是靠我自用，是怎么借我有真的是知道吗？
41:51什么是对不起放弃，那是我去爱你的一人。我一看前面二三，我二三米，不好意思，然后就我进去，
42:23你逼，然后有那要上去来。这样吧，这样摆肯定有优势。对啊，你不是你想说，
42:36我多可我哥，你还有许多嗯，不能哎嗯怎回事？身体上嗯不少都不是个炸物，是如何去买，为什么？
43:38哎呀，今今天就所以这个 back 你十年几的真的不对，地铁进来就这么多，我就没穿过，就只有一个。我以前新这个尾型就是大哥是一个你好，
44:34要我们领导对刺激，我把你对对老后，但是嗯对滚看是好吃的，要进没有问题干嘛呢？又又到好学社，我上周我啊这周我已经真是。
45:53你这样，你把包放这，你真做好事不用决心点，我根本都都记不住的。是应该是正，应该应该因为正好能。
46:10是吗？各位这个讲不是啊，没事没事，我号的一个网，这上他们睡这的睡的。所谓的随机分数，
46:30按次序，按学号分数数，昨天晚上我还有价格方面走，反正我不接意。这个话咱老一点，提前一天不是一个学期玩的，
46:58都是四年多，然后给其死就放在坐坐，谁就该上面的，可惜他给你吧，正好这边准备让我整体必须的。现在看他们那个钱要用我的衣服会，
47:36但是没有我们那个怎么回事儿，这个根据我们那就发群，我那个账号给我们什么这个卡。这还不大思考不一样。你好，宁静，
48:58我不是啊，感谢你。对，是，所以不起。现在我昨天才有是今天他没去过，
49:51你能不能我来死掉，等一下这次次我感觉这个用你对一个假币有东西说欢于这种这个这样子怎么？还有就是是是你记得数量我听说过，但我不喜欢我，等会儿今天使用手指，我中间就没问题。
53:40我还嗯转新行，就是前男友，你右转起飞这个地址，其他一起也比较好。这个真相是怎办？