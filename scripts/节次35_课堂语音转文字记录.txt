00:26是一嘘，就是刚我们家小嗯有我们你更清了是提供珍惜。我写作嗯嗯，是是嗯嘘嗯嗯，嗯爱很好放心，好，
05:36来亲个么么哒。好，最后最后哦最后一点了 OK。其实这节课我们其实都在讲一个考比。也就是说我们当这个这个不管你是 AI 还是非 AI 啊，对吧？
05:49就是说你的这个这个这个当你的这个负载啊，它随随时间变化，然后呢我们又想要最小化资源的话，我们就不得不避不不可避免就需要这个这个去做动态的 elastic 这样的一个能力。那 elastic 的话，你需要做一个全栈的系统，
06:05这个解决问题，包括你怎么从容器初始化，包括怎么去做这个开 cons，包括怎么做模型参数，对吧？然后我们说其实里面网络是一个非常重要的这样的一个因素。
06:15因为不管你是这个 obscility 也好，你还是 migration 也好，我们都需要从网络去做这样一个快速的这样的这样的一个这个这个数据的拉取以及这个传输 OK。那么这边有一个很大的问题，就是说哎我们前面讲过对吧？我们有 RDMA 啊，
06:32 RDA 大家应该都很熟了，对吧？这个我们上一个讲过。对，而且因为它有一个很好的地方，就是它它的网速其实是其实很快的。
06:41但是呢它的这个 control l ay er 其实是是比较慢，什么意思啊？什么叫做 control play？所谓 control play 就是说我们要通信之前，对吧？我们得先建一个网络连接，
06:52然后我们才能才能通信。然后通信的这个具体的发一消息的时间是这个 data day。但是这个 c rol l ay 就是我这个借连接的这个时间。然后 RDAA 啊，它从设计上来说，它的这个 control play 实际上是非常慢的。
07:05比如说啊我们这边给的一个数据，就是我 RDMA 做做一次络络通的这个延迟，对吧？两个微秒，但是如果我要去建一个 control pay，大概是要到十五到二十毫秒啊，
07:16这样的一个这个这个这个这个这个这这个量级。然后如果我们要用这个 NNCC 啊的尼口，就是就是呃 m media 这个集合通讯库。我们要做 mltage cass 的话啊，它其实这这个时间会更加更加长是吧更加长。那这个东西你对一些常常驻的这个应用，
07:34然后运用就是训练，对吧？我跑在那边开个跑一个月，那这个开销显然可以忽略不计。那如果对于我们这种及时的这个应用，对吧？
07:42就是我需要这个这个 online 的去去把你这个数去起一个 instance，然后把你个数据拉过来。那这个其实就会会有一些这样一个影响。比如说啊 AI 应务可能稍微还好一点。但如果你是一个这个传统的这样这个语音和 service 的话，它它基本上是需要啊它整个应用的执行周期大概也就在几十毫秒。
07:58那你再花个几十毫秒去启动，那这个其实是是非常大的这个问题 OK。那我们显然需要一种方法对吧？去快速的建立这个 RDM 连接接来那连接。那这个的话它的我们的解决这套问题的思路啊，其实是和这个传统的这样的一个方法是一样。
08:15什么意思呢？就是说我们这个这个 RDB 连接，我们其实就看嘛，它总会有几步，对吧？那其实第一步干的事情就是说我在这个用户态把这个驱动加载一下，
08:23就跟这个 GP context 一样。然后加载完之后呢，我们得在这个硬件上去建一个建一个队列，就我们在硬件上得配这个为为什么？那像 RDV 的本质是我们的这个网络通信，都是硬件才帮你做加速的。
08:36所以我们得在硬硬件上去建好，足够的啊，其实这个建也是一个打引号的，它并没有在硬件上建个新的东西。但它其实是让硬件知道 OK，我有个队列啊，
08:45这个映射到这个用户态啊，你得你得去做 OK。然后呢，我最后我这个我们上节课讲过对吧？就你我们得做这个握手通信，对吧？
08:54这个通信完之后，这只个 QP 才能拿来用。那这个时间其实实是非常非常长。而且它里面有一部分时间，比如说你的这个建 QP 的这个时间其实是很难干掉。因为你这个你要去 config 硬件上的这样的一个资源。
09:06对所以我们的这个思路怎么样怎么做呢？这个问题其实和我们讲这个 gp u conact 的这个思路一样，就是我们就池化嘛。就是说一旦我们提前建好了一个资源，那其实啊我们就可以复用，它就不用重新创建了。
09:22那这个这个这个这个 RD 背里的这个资源，至少在扩容这个场景下，它其实是可以提前创建。因为大家想扩容也好，或者说是这个 auto 啊，这个这个买 gration 也好，
09:32那是概率性什么？本质上就是说我在操作系统情况下把这个数据读过来 OK。那我不可能存在说一个事情，就是我一个 RDB 连接啊，它这个这个能传这个数据，另一个 RDB 连接它做不了，
09:43对不对？所以我们干的事情就是说哎，假设我有有应应用，对吧？我要做一点点。好，
09:48我一开始第一次启动的时候啊，我的这个这个这个启动很慢的，我要去创建这个链接 OK。但是一旦我这个第二次启动之后，我就把它的这个啊 QP 啊，这个这个 QP 啊，
09:58就缓存在这个操作系统的这个资源池里面 OK。然后我的这个这个这个这个这个下一次使用的话，我就不需要去再重复重复了。 OK，那那这的的其实有几个掐两点啊。第一个插认点就是说这个这个这个 RDVQB 就跟它这个东西，
10:14你要把它在不同应用之间去卸啊，其实相对来说非常复杂的。因为 RDV 在它的驱动是呃横跨这个用户态呵诺态啊，里面有非常非常多的这个数结构。然后它里面这些数结构其实还跟啊硬件打交道。然后如果大家写过这个 RDV 驱动啊，
10:29反正我是过过，就就我就改过，还不是写过。对，就你就会发现这个东西它改起来其实非常非常恶心啊，那这个非常非常的低。
10:36所以可能很难做这个事儿，那这个事怎么干呢？其实我们的思路就这个这个之前我们讲 GPU 一样啊，就是说你不管 RDV 的 QP 有多复杂，它的这个 API 实际上非常简单的。它其实就是一些 post same poster save 这些 API，
10:49就跟 GPU 一样的。它无非就是几百个这个扩大 API。好，那么我们只需要用用系统里面一个经典技术叫做虚拟化。就我们虚拟化出来一个 QP。然后只要我们保证这个什么呢？
11:00就用户他发的这个 API 啊，就 post popost save，我们能够把它忠实的去还原他原来的 QP 执行。那其实站在用户角度下，其实根本不需要知道你这个 QP 是是是在这个这个这个线的对吧？还是说是从头撞地的 OK。
11:14所以呢我们具体做完，就是说其实我们在内核里去维护了一个这个额外资源池。然后呢，当时我用户要发一个 RDB 请求时候呢，我就截获这一篇。然后把这个这个请求啊翻译成一个我可以在资源池上的 QP 执行这个请求，
11:27然后去做就可以了。然后呢，这个这个等于收到请求也是一样啊，我可以去去去这个原本科隆类的这个 QB 值啊，读回来就行了。 OK。
11:36然后这里边呢其实会有一些问题，就是说如果我不同的应用对吧？去去去卸一个 QP 的话，它其实会有一些安全上的这样的一个问题。当然这个东西的话，其实是是可以用一些这个比较机械的手段去去解决的啊，
11:49这个是不是特别复杂，我们加一点手动的这个检查就行了。当然除了一个这个以外呢，还有一个很大的问题，就是说就是说你现在的这个数据中心对吧？它的规模其实相对来说是是比较大的。
12:00就比如说我的这个现在至少阿里面的基本上说几千卡的这样子，个四千千千卡这样这样的事。然后这些咨询员每个 QP 啊，它其实是需要这个这个比较相对来说比较大的这个物理资源的。为什么？因为这个这个每个 QP 它其实要存的是一个物理的队列，
12:15就是你的你生它它足够足够。它在载体存里存下你这个 possibly 往它里面放的这个网络的这个请求。然后这个 QP 的数量呢，通常来说它又是跟这个机器数量和 three read 数量相比。比如说什么呢？因为不同 RMAQP 啊，
12:29它的实现上，它其实它要保证没没有性，所以它会用一个 restlglobal lock 去保护每个 QP。但是有了 global 的的，我我们实会发现问题就是你如果是多线程用用同一个 QB，它的这个性能实非非常的差。
12:41所以一般来说呢我们又得保证什么？就是每个 thread ad 有 QT。好，这样就会导致一个问题。就是说我们如果我们要使用资源连接池的这种方式去保证啊，我在做一个很快的 RGB 连接的时候，
12:51对话我可能需要 spread 数乘以机器数。那么多个这个 QPOK 我才能够再才能够把这个事儿进行给做完。那这个事情的话，再乘以每个 QP 它它需要有一个额外的这个空间的话，那它其实这个内存占用就非常大。 OK，
13:06那怎么解决这个问题呢？其实我们有一个呃非常发现就是说 RDB 啊，它其实在有个新的这个 feature 叫 dynamic connective t be 的时候般大家知道 DCQB 这个 QP 呢有一个很好的这个特性，就是说它的是一个 connectilist。什么意思呢？就是我我这个 QP 啊，
13:22它一个 QP 就可以跟 n 台机器通信，它不需要在机器之间做一个 dedicated 的这样一个信道。它为什么能实现这点呢？是说它比如说我原本这个 DCQB 对吧？实跟机器 a 通信。然后如果我要跟 b 机器通信的话呢，
13:34 DCQB 干个事情，就是它先会发一个 network 的这个 didisconnect 请求发给 AEG。发完之后呢，它会并行的去发一个 b 系的 connect 请求，相当于它会做一个 dammate 这个切换。而这个切换呢会有一定的这样的一个开销。
13:48但这个开销的话，我们发现在我们之前很多场景，比如说你是一个这个这个这个这个这个你不管是这个这个买过一些场景也好，还是这个这个那个那个那个那个那个那个 scill e 场景，对吧？你这这些些小的切换开销其实是可以忽略不计的那这样的话我们其实就可以用这个 DC 的这个 QP 啊，
14:06把这个每台机器对吧？我们要做资源池。因为你池化其实最大的问题不就就是会资源源池就预预预预先化化它 UC 样值，不就是突破类似这样嘛。那一旦我们把这个 QP 给换成一个这种类似于 DCQQ 的这样一个事儿。其实我们就可以做到一个非常非常快的这样的一个这个这个这个这个这个启动 OK。
14:24所以呢加入这些东西之后，对吧？其实我们就可以看到 RDA 的这个可能性可以 tion，对吧？它其实就不是一个啊特别大的问题，它的性能其实也是啊这个这个可以可以接受的。
14:34当然对于现在很多应用其实不都不需要这种复杂的技术。因为本身像这个 VR sleep，对吧？这种东西就是说我这个如果我应用比较单一的话，其实我完全可以把这个 VM 就直接聘到这个机器里，使用 OK 那就行。
14:47但是他但是不管你到底是聘也好，不聘也好，其实你们最重要的这个核心技术点对吧，还都是都是这些。然后啊那么总结一下的话，其实就是说我们今天就讲了这个这个这个啊 competition committed，
14:59对吧？就是说是 elected，其实是对于这个 service provider 是一个啊非常好的这样一个这个这个这个特性。那么你要去实现 eleicc 的话，我们就得啊提供两个最基本的 mechanism，就是 like acgration，
15:09就这个 austiiction。然后每一个这那这个这个这这个做的其实都都都是有很多这个系统的的 allge。然后如果你要把它做到极致的话啊，你得做一个 full system 的这样的一个这个这个这个这个但是你 organizzfull system organization 的话会有问题，就是你的这个系统其实很难 deploy。所以我们最近在做做的一些事，
15:27也就是我们会把一些技术点去做简化。这样的话能够比较方便的去从啊在这个真实的这样的一个就是说啊说白话就是比较容易跟跟 instream 的这个生态去做一些结合。不然的话你对他们感动太大，其实他们其实是不大愿意去去接受 OK。当然这个这个还有很多这个这里面基本身还是一个很有意思的，这个也也有研究空间。
15:47但是这些事情是我我们我们组最近一年吧一年左右的这个啊一两年的这个这个这个做品部分的事儿。但是但是这里面其实还是有很多的这个空间的，大家感兴趣也可以去看一下啊，对不起，在学术这个东西啊，也是这个比较热门的这个方向。
16:01好吧？行，那那我们今天可能大家听我三节课，时间比较长的那在我们今天呃我就就先先到这啊，也许没想到你讲耶，甚至从在这里开始认识是还没撤，
17:31什么时候请遵守。这次这个是那个这个是这边发的嗯，嘘嘘是是嘘一嘘嘘被胎。对，你是不是是嗯嗯，是哟这挺高，
48:20我这一百天用个证，所以先做点硬的是吧？对对对，自己折磨着磨屁股，上到一会儿更舒服，然后都不知道折磨，
48:29这叫更广泛的去好。嗯嗯，对，那那那你问我们几个老师，你不要问我特别的多，那你可以找说。
49:08对，就是就是算得下，对吧？一件二十不到十五就下给我送上面那下来了，大家坐等一下，他们坐一会儿，
49:23那不是 ok 微信那一个谁的是谢谢啊，是是马上去更换，但是我不知道吃啥嗯，扯点关系吧，没钱没办法。对我这个东西。
51:20那好，肯德基这是什么东西啊？你也是啊，上我的就是就有一些就是从头到尾他录起来一会始去出机，网上不够，没早期清是吸剧。
53:41亲，七月在我每个每个第四季活动就是我们的重心牵引。就是我不可能，我看来就是座业也会有点二零一六至，我感觉那个太太厚重太重了吧，还有随便随非法是你是你。