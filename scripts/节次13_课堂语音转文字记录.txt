00:19然后呢，尾器是切是的，没呀，签字字嗯嗯，了解到的去是别提醒我是有运气了，是游戏七分，
05:15这不已经天。因为嗯嗯我们开始今天的呃喂好喂喂 OK 啊，我们开始今天的这个 SSP。那么今天的话，我们继续将会探讨这个上一节课呃类似的话题。那上一节课我们探讨了就是分布式下的这个一致性模型，
05:53对吧？我们说在分布式下，如果你有不同人在对同一个数据，比如说聊天记录去做操作，比如发消息的时候候，很有可能你你就会出现不同看到的这个聊聊天记录是不一样。
06:04那么我我们认为这是一个不一致。那么在这个分布系统也好，在单机系统也好，还有一种可能会产生不一致的。这个时候是呃，问题，
06:13什么是故障啊？就是说当我的这个一个节点或者是我参与计算所有节点发生故障的时候，其实你在这个这个这个这个机器上这个数据啊，仍然有可能会产生回去，尤其那些持久化的这个数据。那么为了保证这样的一个一致呢啊，
06:29我们就需要这个这个这个系统提供一种能力，叫做这个 honesty automaity。这是我们今天啊主要讲的这个内容啊，我们为什么说啊 audersing automaity 是一个对对这个这个这个对这个这个呃在出错情况下一致性来说比较重要的方法。然后我们会介绍几种经典的这个实现 or nothing automatic 的方法啊，包括最简单的这个 shshadow copy，
06:55包括这个在这个大模型时代之前，对吧？大家听的可能比较多的这个 logging right 还在 logging，以及在这个 AI 时代，对吧？大家听的比较多的叫 check point，
07:05对吧？大模型的很多容错方法其实基于 check point。但是那要说明的是这个这个这个 check point 本身这个东西啊，它并不是大模型时代才出现的。它其实最早的历史可以追溯到好几十年前啊这三个技术点。然后这三个技术点，
07:19僧号其实是有一点互补的。比如说这个你你记任任何的笔方法，它其实也需要一个这个类似于 lochappoint 的这样一个机制，让你的这个整个的 log 和变得变恢复会变得比较快。 OK。所以这是我们这节课会介绍三个主要内容。
07:35然后最后的话，我们因为 check point，相信大家可能都都可能也比较感兴趣了。我们可能会介绍呃几个 check point 这个 case，包括它怎么用，在这个 login 里面以及它怎么用在这个大模型圈里面啊啊大家是反正放心。
07:49我们今天讲的这个在大模型圈里面用，其实不要求大家有任何的这这个模型圈里里嘛，其实非常非常简单啊，都都要听懂。然后最后就是怎么把 check point 用到我们之前讲的这个这个 eleventual 四四四里啊，这是不是也帮大家复习啊？
08:03如果大家这个这个还有印象的话，上节课我们讲 eventually consistent 的时候，对吧？我们说为了保证 eventually 的 consistent，我们得有一个 log 去 word events 去去去重去排序这个事件。但是这个你要排序啊，
08:17这个 log 它其实也会一直的这样的一个增长。那么其实也需要一个类似于 check point 这样一个技术，就让这个 log 简啊去去变得变成好了。行，那我们就啊开始这个这个今天的内容。那么我们啊跟之前一样，
08:31我们先用一个这个例子，对吧？告诉呃大家看为什么什么是一 automatic 一致性啊，什么是是非裂情况下这个会发生的这样的一个一致性的问题。 OK，那我们这个例子很简单，
08:44就是个银行的这个一一或者说金融的这样的 APP，比如说支付宝对吧？是不为什么我们用金融的业务做做比较呢？因为其实在金融里面，数据的一致性是非常非常重要。它不像聊天记录，
08:56聊天记录你错了就错了，对吧？你你你金融里面你这个钱错了，这个这个用户要找上门的对吧？那么我们要假设我们要实现一个最简单的这样的一个银行的这样的 APP。然后这个银行 APP 我们只有两个要求。
09:09第一个要求就是我的这个数据持持久的存下来。我不能说我这这个机关机，我我这个钱丢丢了，对吧？那么我所谓持持化化就存在磁盘里。第二个要求就是说我们的这个银行对吧？
09:20它得支持一个转账的这样的一个操作啊，就是我把不同的用户啊这样的一个转来转去 OK。好，我们就假设这样一个非常非常简单的这样的一个这样的一个应用。然后呢，为了简单理解啊，
09:34我们先不考虑分式式，先不不分公式式，我后面会讲分布式。对，我们先假设啊我们只有一台机器，机器这个这个这个去支持这个转账啊，
09:42就只有一啊一一台计加器，它就一个现实。那么大家想想，它其实就是我们上上节课讲的这种是 centralized design，对吧？它其实就不会出现我们上上节课说的那些各种乱七八糟的这个不一致的这样的问题哈。
09:55就这样一个非常简单的这样的一个模型 OK。那么我们要看一下，就是说这个这个模在这个模型下，对吧？如果出现故障，我们这个数据会不会不对啊？
10:07会不会那那在讲这个之前，我们得先定义一下，对吧？这叫什么？我们对于这个银行的这个应用，它数据的正确性要求是什么呢？
10:15大家想想我如果这个银行啊它是一个封闭的这样系统啊，它就只有这样一个转账的操作。那么它呢其实唯一的正确性需要求其实非常简单。就是我这个这个这个这个银行啊，它的账户的这个总额是不会变的对吧？因为你是一个银河的这样一个转转账，
10:31对吧？你不管怎么转，我的这个总和是不会变的。 ok 那么我们接下来的这样的一个问题，就是假设我们有机器机器挂了，就是我们做我们这个这个银行这个服务器啊，
10:45做到一半 OK 突然。比如它没电了，跳电了，或者说它那个操作系统蓝屏了。这个时候我们这个银行能不能这个重启之后，我们这个数据能不能保证这样的一个特性，
10:56对吧？就是 a 加上 b 对吧？它的这个值不会变啊，能不能保证呢？能不能保证呢？那这个问题其实看上去很简单，
11:04对吧？那实际上并没有呃，你要回答它的话，你得考虑一些细节。什么意思呢？就是我们说错 failure，
11:09你得考虑一下这个 failure model，对吧？就是你的出错模型上，比如说我说的挂机器挂，我说机器停电，它到底意味着什么什么意思，
11:18对吧？它比如说我我我是不是有可能出现啊，我的屏幕不显示了，但是我的这个操位系统仍然在跑，这个算不算挂呢？对吧？
11:25那这个其实也算是挂的一种，对吧？那么我们这边啊先考虑一种相对来说简单的啊方式，为什么让我们叫做 field stop？什么叫 fiestop 呢？就是说我们说一旦出现故障 OK，
11:37我们这个系统里面所有部件都不 work，就包括你的这个这个这个这个 OS 也挂了，显示器也挂了啊，所有的都挂了当盘磁盘存下的数据汇报啊，因为它是物理的存在。在感 OK 我们就假假设这样一个这样一个性质 OK。
11:51那么在这样的一个性质下，我们其实就可以什么？我们就可以用系统的这个 model，对吧？去分析分析这样的一个这个这个一个他把出错的情况啊出错下，他说明到会不会对。
12:03但是在这个分析之前，我们肯定得有一个什么，我们得先知道对吧？这个这个这个这个这个应用是怎么实现的？因为我们前面给的这样这样的，实际上是一个非常简单的伪代码，
12:14对吧？我们说这样的一个伪代码，它其实是不能满足我们之前讲的这个数据的这个 persistent 的这样的一个要求的。所以呢我们这边给一个比较简单的这样的一个实现的么？这个时间其实也比较经典啊，以及基本上基本上你做个转账，
12:29也没有比这个更简单的这样的一个实现了。那么这实现是什么呢？就是说第一啊，我们假设一开始这个所有的银行账户都存在在文件里，为什么要存在在文件里？因为你不存在文件里的话，
12:40你的数据就没有办法持久了，对吧？第二呢，我这就就就就要需要实现这个转账这样一个这个这个函数，对吧？那这个函数假设我这个账户存在在这个文件里文件里的话，
12:53那么这个实现起来其实非常简单。我比如说我我们你稍微有点操弃的背景的话，我们啊我们就说我们可以先把这个数据读到这个内存里，怎么读到我们啊，比较简单方法就是 n map。 n map 的意思就是什么？
13:04就是把这个文件里的数据啊直接映射到这个内存里，这样我就可以操作作个个内存据一样去操作文件上的数据 OK。然后读上来之后，我们假设我们的数据都存的是一个 array，对吧？然后就是一个 real cos 这个 right 从来之后呢，
13:17我就可以啊就是说对它内存修改。然后修改完之后呢，我得把这个修改写回写回这个这个这个这个磁盘里的。所以我们有一个这个 f sink 这样子操作。 f ink，它其实就是这个操作系统的这个系统调用。
13:30它会把 derram 里的这个文件里的这样的读上来的数据啊，就写回到这个这个磁啊磁盘里。 OK 最后写完之后，我就可以去这个透支右护手做操作啊， OK 这就是我们今天分析的一个应用啊，可能找不到一个比这个更简单的这个应用。
13:45好，那么我们接下来的一个问题就是在这样的一个比较简单的这样的一个实现里面，对吧？假设我们这个系统这个这个一台机器，它跑到一半挂了挂了的时候，我们的这个磁盘的这个数据到底会会怎么样？
14:00会不会能不能满足？我们之前说的这个不管怎么涨转让对吧？两个两个账户的这个金额总和是不变的，能不能满足的不不满足？其实这个问题我我们也可以思考一下，对吧？
14:12我们说开启 thinky mode，对吧？其实其实这个问题要回答它的话，我们要要要解决的一个问题是什么？我们得说我们说挂了，但是你说挂这个这个东西，
14:21它到底是在哪里挂，对吧？这个其实对系统很关键。大家想想看，我们从一个假设不挂的一个系统角度来说啊，我们的这个这个系统就一直在轮询的去收到一个 RPC，
14:32对吧？我们就去做一下这个操作 OK。那么你如果你考虑到挂这个非 s 分列，它可能是一个这个随机的事情的话，意味着什么？意味着说我们这个代码的这个类一行，
14:43它都可能跑到这个代码的时候就挂了，对不对？所以说要分析这个这段代码在分列下，它会把这个磁盘的这个数据对吧？保留成一个什么样的一个状态，我们得去是吧得去呃分类讨论对吧？
14:57我们得去分类一下，就是说哎我到底是在第一行代代码挂的时候，数据会不会对错？第二行代码挂的时候会不会错。如果这些每一行代码发生挂的时候都不错，那我其实就可以说不是吧？
15:07这个数据是是是，是是是，是是是是没问题的对吧？那如果有一行代码出错，那我们就可以说你这段代码它其实不能保证什么？就是你这个分裂情况下它属于正确的。
15:16那么怎么分析呢？其实我们这个那我们就一行行看，对吧？比如说我们可以大家可以想一下，假设啊我我我要这个这个分析的话，那么我们其实比较关键的其实什么？
15:29其实是这个写文件的那些操作，对吧？因为如果你一个操作是纯内存的，这个操作的话，它其实挂不挂就取决于什么。你的这个初始的时候这个状态是不是对的。
15:37那比如说我们这边唯一一个写文件的操作其实是什么？就是这个 f think 这样的一个操作。那么所以我们其实很很容易的看到一个事，就假设啊我一开始这个文件是对的 OK。然后呢我去执行这个操作的话，假设一开始是对的 OK，
15:52那我在 x 这个之前你不管怎么挂，我的这个数据一定都是一个对的状态，对不对？这个这个呢能理解吧，对吧？因为假设我一开始啊一开始的这个这个这个这个文件的数据是对的 OK。
16:07然后我有一个飞列，在这个 f seek 之前，你再怎么画我的整个这个系统仍然是对的对吧？那么其实最关键的就是什么？就是我写文件的这个过程中能不能保证这个数据是对的对吧？能不能保证数据是对的？
16:20那么我们怎么保证这个写文件就是 f seek，这个过程是对不对？大家想理论上来说，我第二个 API，那我根据它的文档，它它就应该告诉我把这个这个所有的这个这个这个数据都从内存里起到磁拍，
16:33对不对？但大家想想，实际过程中， f sk 这个操作有没有可能会发生故障呢？其实是有可能的。为什么？
16:41因为 f sink 它其实不管所有的它不它很难会给你保证一件事情是什么，就是说它很难不给你保证。如果百分之一百成功啊，它其实是是一个就是它是说在有飞裂的情况下，是一个 best effort 的帮你完成。为什么会出现这样一种实际？
16:57为什么的现在的这个系统很多 API，它并不能帮你保证这个百分之一百成功呢？因为这个 API 它它跑的过程相对来说是比较复杂的。而且在这个复杂的过程中啊，一旦出现了故障，那它其实确实也只能够比如如我在 basenfff sink 过程中，
17:13这个这个这个操作挂呃这这个这个系统化不知道怎么办。那大家可能是想，为什么我 f sink 这个东西看看上去挂的对吧？如果我是从一个调 API 的角度去思考的话，我这个不就是调了一行这个这个操作嘛。那这个呢其实关键点在于你在做这个这个任何系统软件的开发的话，
17:30要有有一个意识。就是你所有的这个每个 API 调用啊，它背后其实会执行非常非常多的。也它也其实也是一堆 API 的调用。你直到分解到细到什么？直接分解到最细的，
17:41就是说它调用的这些设备上的这个硬件上的这个值。比如说硬件告诉你写一个磁盘配置，那这个东西它才能叫什么？你才能把这个代码去完全展开，你才能去做一个分析是吧。那么谁在这边呃，
17:53也是一样的，对吧？比如说 f think 对吧？ f sink 这个东西具体做了什么事情呢？我们其实是是是是是需要去把它从系统角度去做一个拆开来看。我们才能够去看说哎，
18:06我们基于这样一个 f sink c 的这样一个操作啊，去做的这样的一个 application，到底在非 lier 的情况下会怎么办？那么我们说 f sink 干的一件事情是什么？它其实干的是不是把你在 beatatch 里的这个文件的缓存给写到这个磁盘上 OK。那这个操作它具体怎么说呢？
18:24就是说一开始啊我们先得用它假设什么我得先有 a map，对吧？ map 会把这个它假设这个这个 page cash 啊啊 OOS 这个 disk 上的这个这个数据啊，先给读到这个 page cathe 里面，相当于这个是是 dissk 这样一个缓存。然后呢，
18:40我们这个这个在在内存里对这个数据修改，然后 f seek 我们在执行的时候，它展开的时候，其实会分成两条这个更细的指令啊，它是会啊，其实不不是不仅两条，
18:51它其实是一个很多条，它它的条数取决什么啊，取决于你的这个 page cash 有多少呃，相关于这个文件有多少个配置。 OK 它会遍历这样的一个 page cash 里的这样一个文件的这个缓存啊。对于每一个配置呢，
19:04它都会用一个这个磁盘的这个 right 操作给写回去啊。注意大家磁盘只能保证什么。它只能保证说你发一个指令 OK，我只能给你写一个配置啊，这是磁盘给我们的这个这个这这个这个抽象。那么所以站在 f sk k 的角度说，
19:21那么这边其实就得做一个什么逐配置的这样一个写回 OK 是是一个为什么么什么不能磁盘，不能这个这个一下子全全都写回来。大家想想我那个磁盘，你你写的时候，它是它是什么什么里操作来来你正常的磁盘，它实际上是一个这个这个圆盘，
19:37对吧？它是个圆盘，然后它这个磁头一转着啊，转着这样的一个这个这个这个这个写的。然后你每转一次你得去发一遍，对吧？
19:45你不可能说我这个这个这个这个这个一个命令，把所有的都写回去，这肯定没有必要吧。然后然后对对，大概就是这样一一个原理 OK。好，
19:53那么大家想想，假设啊我们这样一个模型模型，然后我开直接接 KK。一开始我把 a 的这个配置就是 a 的这个账号的修改啊，它改成了这个这个这个零写到了这个这个 disk 上，写到二十四 disk 上。
20:08然后这个时候我要写 b 之前哈，突然我的这个系统断电断电了啊，就整个系统非常 stop 了。这个时候大家首先想想，这个时候 b 能不能写，假如我系统断电了，
20:19 b 能不能写回来啊？其实其实是不行为，为什么？因为我前面讲你磁盘上写它得它得通电，对吧？它得通电去去转啊，
20:26你基本上一旦断电，我的磁盘这个操作就不能做了。好，一旦我这个磁盘操作不能做了，大家会发现什么什么问题。因为我断电了，
20:35我的这个配置开始所有数据都没了，对不对？所以在我们的这个系统里面，我如果重启的话，我看到的什么？就是磁盘上的这种数据。
20:42然后这个数据告诉我们什么呢？就是 a 的账号是零， b 的账号是十是十。 ok 那么大家想想这个东西它符不符合我们这个之前的这样的一个质确性定里面，显然是不显然是不符合为什么？因为因为一开始我们的这银银行账行总总额额二十对吧？
21:00但是你一旦发生了故障之之 OKK 们们一个非常简单的实现，它的这个钱就相当于凭消失失了，对吧？那不消失失核核心，因因什么么说？在用户看来这样的一个不一致的现象，
21:11什么就是我这个银行账户对吧？银行账户的话，他应该呃，转账还没有成功，转账没有成功，它意味什么？
21:16它就是说我有一个一个给 a 的这个写入，对吧？写成功了，但给 b 的没有写成成啊类类似或者反一反，那它本质上什么？本质上就是用户的对于这个操操作不一致，
21:27什么意思呢？就是用户期望的是什么？我如果做一个这个银行的这样的一个转账的这样的一个操作，那么理论上来说，我应该是所有的操作，要么就是全部完成，
21:39对吧？我转账应该全部全部全部写成功啊，要要么就是我要么完部没做。就是我我这个转账没有开始啊，你没有告诉我是这个转账成功。但是如果出现一种情况，
21:49就是我这个操作做了一部分，做了一部分没做。那么在我们这个之前的这个银行是就看到这个就不就不一致。所以说所以说对于我们一个系统来保证啊系统来说的话，因为很重要要保证的特性什么呢？就是我对任何这样的一个操作，
22:09它在分裂下，它要保证这件事，它应该要保证跟一个在没有分裂情况下的这个状态是一致的。那么一个比较理想的就是我这个操作对吧？要么全完成，要么全部完成，
22:19那这个我们就叫做这个 our nessing automaase。那么它最早其实是在这个 database ase，对吧？我不知道做这个转吧，你们经常出现。那其实在现在的这个这个这个这个你不管是模型训练里面，
22:32其实也也有这个 honnesy automaity 我们大家其实会看到，对吧？因为大模型训练什么呢？它本质上你要写，你要你要你要存储的话，你要存储好多的这数据，
22:40你要存储这个优化器，你要存储这个参数，对吧？你不可能说我做一个 check point，我这个优化器存了，对吧？
22:47参数没存不不能。那在这样的话，其实你在从这个 check point 去恢复的话，那那其实就跑飞了，对不？所以说这个 honnesy honesty 这个 automaity，
22:55那么在这个这个这这个这个这个这个系统里面，实际上是一个非常重要的概念。所有的系统可能啊最最最理想情况下的话，我们其实都应该要去提供这样一个 polo ye msy OK。好，那么我们现在讲完了这个 honest automtomtic 之后，
23:14对吧？我们就会意识到一个事儿，什么事呢？就我们上面这个最简单的这个这个这个这个转账的这个实现，它是有问题的对吧？它不能够满足 all nothing，
23:26所以我们就需要一些系统的这个方法去实现这样一个 or nothing。那怎么实现呢？李总一开始啊这个一个这个比较经典的方法叫什么呢？叫做叫做 shellow copy 啊， shellow copy。那么大家想一想，
23:43我们假设这个我不要使用 analysy，对吧？就是说我这一个操作，它这个这个这个这个这个修改全部做完，要么全做完，要么全部做完。
23:51其实我们我们有什么方法能够能够做到它来。其实这个这个这个 analysy 啊，它是针对一个文件啊，它有一个比较重要的观察。就是说假设啊我一开始这个这个这个文件的这个数据是正确的对吧？然后呢，
24:06我如果要对他做一些这个影响他这个一致性的这个操作啊，比如他有多个操作，如果你挂了，他没有办法达到 all 拉 thing，那怎么办呢？我如果直接让他写的话，
24:16那么一旦出现宕机，对吧？硬数据结合挂，这其实很不友好。所以我们应该的做法是什？我们不应应该让这个这个这个这个这个修改就有风险的修改，
24:29直接去修改这样的一个这个这个这个原始数据。我们应该什么呢？我们应该是先把它这个拷贝一份，拷贝出来一份，这个这个先拷贝一份，然后我们在一个 temorary 的这样一个这个反正挂了也没关系的，
24:43这个版本上去修改。然后一旦我改完这个所有的这个 bank temperate 的这个数据之后，我能够确保这个 bank temporary 的这个数据都是正确的。然后我再干嘛，我再把这个 bank temporary 去替换掉原来的这样的一个 bank 的这个文件，对吧？
25:00那这样的话，因为我在这个系统里面，你唯一大家用的这个文件 back，它永远永远是是是是对的 OK。那么那么 bank plary 如果要要替换的话，它也是对的。
25:11那意味什么？因为说你不管这个系统怎么挂，对吧？我的最终的给用户看到的这个 bank 这样的一个文件是对的，永远是对的，对不对？
25:22大家基本思想是是基本上比较简单。其实现在很多的这个代码编辑器，对吧？像我们之前很以前用的这种 imax，对吧？它其实也会有这些类似于这种 back up 的，
25:32叫叫做 back up 的文件，对吧？去做这个去做这个这个哦那安耐性的保障，对吧？我们可以以基于之前的这样的一个方法去分析。就是说在任何 case 它挂的时候，
25:46会不会影响它的这个正确性。我们其实很很明显的看到，你不管啊什么时候挂啊，它其实都这个整个文件， bank 这个文件一定是正确的，为什么呢？
25:55你看啊在这个 shattle copy 的这个实现里面，它改文件的地方只有两个地方，一个是什么？一个是我从一个是只读，对吧？我把原来的这个 bank 读到这个 bank camerary，
26:05因为你是只读操作，它肯定是不会影响正确性的。然后第二个呢就是 FC 和 band，就是我去写这样一个这个这个这个这个被呃呃呃这个这个这个暂时的这样的一个文件。那么大家想想这个时候他挂了有没有关系呢？没有关系，
26:19为什么？因为我们其实对用户来说，最重要的什么是原来的这样的一个 bank 这样的一个文件啊， bank 这样的一个文件。所以我们可以看到你这两条代码，不管在哪里挂在哪里挂。
26:32我原来这样一个 temer，这个 bank 的这样一个文件，它一定一定是一个这个一致的 OK。这就是比较经典的一款，也是比较早期对吧？一个我们称之为叫做这个这个下盖头 copy 的这样的一个方法。
26:45 OK。那么这个下下头 copy 这样的一个方法，它在 rename 之前对吧？就我们把它切换之前数据都是对的。那么大家有没有想过一件事，就是如果我这个 rename 这个操作过程中发生了这个故障，
27:03对吧？我的这个这个这个这个这个系统的这个这个数据对不对？那我们说系统的数据，它其实分两部分两部分。一部分是什么呢？一部分是应用它自己的这个数据，
27:14比如说这个 bank 的数据，还有一部分什么，还有一部分是这个你的这个整个系统和操作系统，对吧？它在文件系统里面维护了这样一堆状态，我们大家也上文件系统。
27:25那么其实大家会思思考过的有没有思考问题，就是我的的这个用户数据是对的。 OK。但是我在这个 realme 的这个过程中，会不会出现一种情况，就是我的这个用户数据是对的。
27:38 OK。但是我的这个系统里面，比如说文件系统，它的这个这个这个数据出错了，可不可能出现这种一种情况呢？为什么我们会去 care 这个文件系统数据啊？
27:49大家想一旦你这个文件系统，比如操作系统的这个数据挂了，它意味着什么？它意味着你的这个系统可能重启之后，它都不一定跑得起来，对吧？
27:57那这个时候我你用户的这个 bank 文件，即使是对的，他也没啥说啊，用你得把它什么抠出来，然后呢，你还得去这个这个这个把操鼠重装，
28:05对吧？那这个其实就是非常非常麻烦的一件事情。而且你要你要把它 call 出来，你还得进进入一些这 recovery mode，对吧？这种事都都表啊，
28:13所以我们其实是希望就是说我们的一个 OO 系统特别器，它不仅仅是在于这个我用户的这个这个数据这么类，对吧？我们从系统的这样一个层面，其实也要能够保证它的这样的一个质一致性。那么这个事情在系统层面方不方便做呢？
28:32其实它的挑战和用户层面做其实是一样的。为什么么？因为大家大家如果还记得文件系统，对吧？因为我们知道你的一个文件系统的 nea PI 或者说一个操作系统的操作系统，它背后也是有一堆这样的一个内核的操作也好，
28:48内核和设备的交互是促成的，对不对？如果这些操作他做到一半，他挂了，他其实也会让这个什么系统处于一个这个 partial exexcuted 的的状态。比如说以我们以大家的这个你比较了解的这个文件系统，
29:04对吧为例，那 nonoi node 文件系统它其实去做了一个这样一个 indime 操作，它本质上它得做，它得修改。至少三个这个 data block 一个是什么？一个是你的这个文件夹的这个这个 block，
29:16你要把这个其中的一个 temporary 这个文件删掉，对吧？然后呢，你还得去修改这个这个这个这个 i know 的两个这个假设， inote 的十二是这个 bank，然后 i note 十三是 bank，
29:28 covery 这样一个文件。然后你因为我们说一个不是 i know 的对应的什么一个对对应的是一个文件是 block。 block 其实和配置是一样。所以意味着说你在操作系统的角度来说，它一次只能修改一个 block， OK 一个 block。
29:40所以呢我们就会发现这个过程啊，它一定是就是说我先比如你我管按按照什么顺序，它肯定是说说我我先先我们其其中一顺序就是你先改第二去 block，改完之后呢，我去改这个 i know 的十二对吧？然后把它变成零，
29:54然后再把这个 m 十三变成一 OK。好，这个时候我们其实就会遇到跟之前相同的问题。就是我如果这个文件系统啊非常不凑巧，对吧？我在做这个操作的时候，
30:08正好这个 crash 没电了怎么办？比如说我们在上面这样的一个例子里面，对吧？我在修改完这个这个这个对吧？我在修改完这个这个这个这个个 deladeblock，比如说我先把这个这个这个 bank 啊指向了这个 bank temorary 这个 i note OK。
30:26那这个时候呢，我还没来得及修修改这个 bank 会的这个 counreference count，就是它 chair reference count 还会有一。然后这个时候我们如果挂了系统挂了，然后我在操作系统去做重启，那么重启之后就会发现什么就会发现其实操作系统一都会有有些文件系统的这种一致性检查，
30:44对吧？他就会发现，你比如说检查一下会发现我有一个 i 的，它被两个这个目录项给取消，但是它的原全死只有一意味着什么？其中有一个这个这个目录项它它是假的，
30:56对吧？你要把它你要把它删掉，那么到底哪一个这个目录项是假的要被删掉呢？那大家想站在操作系统的角度来说，它其实如果你不做任何事的，你如如果不做任何记录的话，
31:08其实你你是不知道这样一件事的，对不对？那么这个时候我们怎么办？我们怎么办？要么就是说你让用户去处理，就比如说**作系统发现哎有几个文件，
31:20这个这个这个只有有一个文件，对吧？它有两个文抵下去向直接指想怎么办？我就说哎用户我我弹一个弹窗窗法，让你用户去删。那这个东西大家想想，
31:29它其实并不是一个非常好的这样的一个系统上的这个解法，为什么呢？因为你这个这个用户万一删错了怎么办？他他其实在我们这个例子里面很简单，我们说哎，我们用户肯定知道这个 bank temporary 它肯定是是不需要的。
31:45但是如果这个这个系统，它的这个你在做 rename 的时候是为更复杂的操作。比如说你是在装操作系统，或者说你是在操作系统升级，对吧？如果你这个东西做错的话，
31:54它其实就会影响到你的这个全系统的这样的一个这个正确性。那么这个时候啊，你把这个整个操作系统的这个正确性给依赖于这个用户的这样的一个这个 import 其其，是并不是一个啊非常好的这样的一个思路 OK。所以所以一般来说我们的现在的系统，大家其实都没有会遇到这样一个情况，
32:15对不对？因为因为核心在于现代的这个文件系统，它其实都提供了啊类似的这样一个 or nursing 的这样的一个 automaity 的这样一个保障。也就是说文件系统它保证就是它里面的提供那些 API，在出错的情况下啊，要么做完，
32:30要么就全，要么全部都做完。那这样的话，用户就可以基于这个文件系统提供这样一个很强的一次性的保证，去实现上层的这样的一些这个 o 那性的这个这个这个实现。比如说像这个下周 copy OK。
32:44好，那这个就是这样的一个这个这个这个这个这个这个事情。好，那么接下来我们就会发现，就你光有用户对吧？他比如说他想好，
32:53我要用 searlow copy，这个事情不够，为什么呢？我得依赖于系统系统里面去提供，那那系统又回回来，我系统到底该怎么实现 ononshonysy？
33:03但是我们在这个文件系统这个角度，我能不能直接去使用这个下 arlow copy 去去实现这个 lecoy y 行啊，不行，为什么？因为你你文件系统实现下流 copy，你不是还会遇到之前的这个下游 copy，
33:15遇到的同样的这个 rename 的问题吧。这个问题不就是递归了吗？所以说什么呢？我们就需要另一些思路，对吧？另一套思路去这个这个去从另一个另一个方法去去去解决这个稳定系统的 ogassy。
33:28那我们什么是什么？那么我们这个这个具体用的方法学是什么呢？它的思路其实跟效率 copy 相对来说也不大一样。那么效率 copy 的思路是什么呢？就是说我在出错的时候，对吧？
33:38我总有一份数据是是我如果就是不不做任何何操作话话，数据总会是出错的。所以呢效率 copy 保证什么？就我系统里面永远都有一份正确的数据，它是这样的一个思路啊，应该是我先准备好，
33:51永远也准备好一份对的思路啊，这个思路其实也很常见，我们后面会去做到例子，那么这个思路在稳定系统实现不不大。行，因为我们 rename 这个操作没有办法利用这个思路去去做。
34:01那么稳件系统它实现这样的一个思路什么呢？那他说如果你你他他他没有如果，我没有办法法提前准备好一个这个正确的数据，因为我没有办法 switch，那怎么办呢？那意味着什么？
34:12因为说我这个改造一半的数据一定会出错，对不对？那一定会出错，这个事情影响大不大呢？其实在稳定系统或者说我们在设计的时候，小的时候其实说会发现你你数据准备错时候，
34:23其实问题不大。为什么？因为我们出错，我们只要什么，只要能改出就行，对吧？
34:27我们只要能把这个数据从一个错的状态变成一个对的状态。那我即即即即使我又改错了，又又又 so what 呢？那这个其实就是 jeral 这这样的一套，或者后面继续 lologin 方法的一个基本的这样的思路啊。老李的意思呢就是说这个这个我啊在在做一个可能在比如出错情况下，
34:50会把这个数据改错的操作之前 OK 我我不去留一个原本正确的数据。然后呢，我是去记录足够的这个信息啊，这个信息啊，比如说在这个 relame 里面，它其实就是说你要改哪几个 block，
35:02对吧？这几个 block 正确值是什么？然后一旦我把这几个正确的这个 block 啊这个值记下来之后，那我再去修改原来的数据。好，这个时候我原来的数据，
35:11即使我断电挂了时候有关系啊。没关系，我只要用刚记记来那个数据啊，就就是我们知道这个结论的这个数据啊，去把这个这个这个这个这个错误的这个数据改对就行了。那么它的这个整体流程呢其实就非常非常简单，
35:28对吧？总共分成三步。三步第一步呢就是说我在做任何一个就是需要 nothing 的操作之前 OK 我先把这个我要做的这个修改啊，记在一个 journal 里面， journal 里面。然后呢，
35:40我然后呢我做一个 commit journal 的操作，这个 commit journal 操作确保是吧？确保说你这个 journal 一定是完整的，就是我一定包含了这个。比如说我这个 reneal 要修改这个 block。好，
35:51当做完这个之后，做完 commit 之后，我再去 update 原来的这个 i note blocks。然后反正它可以分成多个操作，没关系啊，挂了也没关系。
36:00为什么挂的时候我就可以从这个 journal 之前恢复。所以呢它就会把这个整个文件性的操作啊分成，尤其要修改的这个操作，对吧？分成两块。在这个在这个 commit journal 之前啊，
36:12反正大家想想，如果我出错了也没有关系，因为任何数据都都没有被修改。那 commit 的 log 之后， commit journal 之后挂了怎么办？也没关系，
36:21我们就可以从什么从 jero 里去恢复这个数据。好，这个夹点有点抽象，对吧？我们可以啊拿一个具体的例子，可以大家看一下，
36:31对吧？那么这个其实就是呃夏老师应该讲过的这样的一个文件系统，对吧？我们说文件系统一开始对吧？有这个 i know block，有这个 data 呃，
36:39 data bit lab，有这个 i node，然后有这个 data block。那么跟之前的这个文件系统的区别就是 OK 我们在这个文件系统里面。最后比如一般来说是在最后我们留一些 special 的这个 block，他去记你的这个所有操作的这个 channel OK。
36:53然后比如说我要去做这个这个这个 rename 这个操作。好，那么我在做里 me 之前，其实我可以先在某些在内存里把这个所有要修改的数据都给先做一遍，对吧？做一遍之后，
37:04我其实就知道这个这个原来的这个 block 它的目标值什么。比如说啊我们这个这个我们对 develote block 的操作，我们做完之后我就知道 OK 它是什么 bank，要指上 m 十三，然然后这 notetemorary bank 这个向量被删掉。然后呢，
37:18这个这个 deneate 十二它 rever 变成零 i note 十三分 councount 一。然后比如说对应的这个 bit bag 全都做 OK 做完之后是吧？然后我们就在这个这这这这个这个什么在这个这个这个呃这个一个阶段里面写一个这个 committed entry。这个是表明什么呢？表明说 commiteneno k 我这个操作做完了，就是说我这个一个操作啊，
37:36你这些操候一定要负责，帮我把这些操作都给做上做上。那这样的话我就是恢复的时候，对吧？我比要看到一个这个 committed 这样的一个 entry 啊，我就可以去 reduce 这样的一个稳定系统的操作了。
37:48然后看上去其实就是然后直接对不对？那么这个操作这个结论里啊，它其实它不仅能做这样的一个这个这个这个这个这个这个这个这个 rename 这个操作。它其实任何你文件系统，比如我要给文件系统 append 一个大的文件，比如说我载一个文件代代啊，
38:05这个其实也可可以用这个里，对吧？因为你像 javappend，它本身上也是需要多个这个 desk 写它，包括括得先先写个 data block，我得把这个文件内容写上。
38:16然后呢，我得去什么去修改这个 i note 里面的这个大小，以及它的这个指针，对不对？那所有这些东西其实我都可以什么都可以在这个 generally 写上啊，这样的话我即使是 ipad 到一半啊，
38:27这个时候挂了的时候也也没关系系吧，我直接接从这个 genernal 去恢复就行了。 OK，那这就是现在的这个文件系统里面啊，基本上用这个 journal 去去去实现这样的 honesy。有了这个 gennel 之后，
38:41我们任的的这个系统操作基本上都是都能变成 onehonesty 了。那这样的话，我们用户在用这个文件系统 API 的时候，你就不不大会去考虑说这个 AI 挂了会怎么样 OK。那这个时候大家可能会有疑问，对吧？
38:57我们说有了这个权中引之后，后权落引之后，这个这个这个文件系统操作，它就一些操作就能变成 f think 了 f think 了。但在我们一不就意味着说，我前面讲的这种这个 f think 呢啊变变成 all dassing。
39:12那我前面讲的这种 f think ink 操作，它不也能变成 audassing 了吗？它不就没有你所说的这种这种这个这个这个原子性的要求用户，他甚至都不需要实现下周 copy 了。其实理论上来说啊，我们也可以我们是可以用全能类这套技术来保证这个这个 f sink 的这个 analysy 的。
39:34但是在通常情况下的文件系统，它不会提供 f think 的，或或者说它没有配置成这样，没有配置这样为什么呢？因为我们其实可以看到这个 analysjournally 啊，它这个方法有一个缺陷。
39:45什么缺陷呢？就是说你你在写任何的这个数据块之前，对吧？你都得先把比如说我要做 f think，我是得把这个 f think 的这个操作先先给写到这个这个 journal 啊，先写 jourourny，
39:59然后等写完之后再能去做原来的这个 in prease 修改意味着什么？就是说说旦旦这个数文件件特别大对吧，比如说就去下载一个特别特别大的这样的一个这个这个这个文件 OK。那这个时候我如果果文件系统所有的操作都是开 journy 的话，那你的系统会非常非常慢，你的性能基本上会会慢一倍，
40:19对吧？所以在现在的文件系统中呢，它并没有用 journal 去保护这个所有的这样的一个操作。它其实只用了兼了保护了了一部分操作。它保护的什么呢？就是文件系统的这些原数据就是什么？
40:33就是 i node 和这个这个 directory 的这个映射关系啊，它它包括 bit map，它这个对不对？因为为什么呢？因为其实对于一个就文件系统设计者发现啊，很多时候对于你这个这个这个这个这个这个这个这个这个文讯啊，
40:49它最重要的实际上是原数。因为你原数据一旦对了，你基本上整个系统它不大会出现什么 consist 这些问题，它不会倒挂。然后呢，你用户态其实很多时候它会做一些自己的这样的一个操作，
41:01来去保证它的数据正确。比如说我们刚刚讲的这个转账，对吧？用户态就可以用其他的 copy。然后比如说呃这个这个这个这个这个这个我下载一半挂了怎么办也没关系啊。它可以它可以通过什么校验码去检验出这个这个这个数据，
41:17对不对？然后去做一些这个这个恢复。所以所以呢我们就可以看到像像大家用的比较多了，比如说 ininx 四对吧， EXT 四它就会有很多的这个 data board 啊，这些 mode 其实对应的就是说它的这 jjournal lelel l 然后它默认的话是不会去这个 jjneal al 所的这样的一个操作啊，
41:34主要是为了这样的一个这样一个性能考虑。 OK 七零，那这就是 journy。好，那么 journy 这边我们有一个啊这个这个这个遗留的问题，遗留的问题什么呢？
41:46就是就是我们说这个我们说 journal 它能恢复的核心点在于什么？在于这个我们在恢复的时候，我们能看到一个完整的这样一个 journeal 的这个数据，对不对？那大家有没有想过一个事情，就是说在在比如说在故障的时候，
42:03在我去 commit 这个 gennel 的时候，我可可不可能出现这个 gennel 是错的。比如说我这个 gennel 里面它有这个的 committeentry，但是它没有这个 old data 这些东西。因为你本身这个我选 generl，它如果比较大的话，
42:16它可能会跨多个这样一个 dissccept，对不对？可不可能出现这种情况呢？成功的出现情况呢，这个时候的话，一般来说有这个这个这个这个两两种设计。
42:28一种设计呢，就比如说你的这个 gennel 啊，如果是不没有数，就就你只有这个文件手原数据的话，那么它的修改其实非常小，非常小。
42:35就是什么它就只会写一个 disco 的 sector。那么这个时候呢，一般的磁盘厂商它是能保证就是说它有足够的电力去去实现，就是一个 sector 写是原子的。所以这个时候我们不用做额外的操作啊，当然你可能会说，
42:50如果这个时候我如果要写多个 sector，然后呢我这个这个可能会很大，或者说我的这个磁盘厂商做的很挫，对吧？他没有给我提供这个这个保证。怎么因为这个保证它其实是需要一些额外的设计啊，
43:00一般来说是在这个磁盘上会有一个小的这个 UPS 啊，就是不间断电源它会存一些备用的这个电源。使得说我这个系统断电之后，我能把剩余的这个这个这个发过来这个操作啊，但有些厂商可能偷懒，对吧？
43:14他没有这个设计，那这时候怎么办呢？其实一下这个时候我们其实也也不需不一定就要需要需要这个假设。为什么我们需要的只是说我这个 jnel 里面对吧？出现了 committed 的这样的一个东西之后，我上面的这个 commitit 的前面这个内容都要写对，
43:31都要写全。那么这个事情我们可以用用什么其他什么机制来保证，我们其实可以用这个这个这个这个一个东西叫做 check check some 对吧？就是我们可以把这个 committed 和这个它上面的内容啊算在内存里，先算个 check cson。然后呢，
43:43我们把这个 check check some 也写到这个结论里 OK。那这个时候如果我即使这个这个没有一个的的原保保证，如果我恢恢复时时无非非就就什么，我就去检查一下这个 sexcheck some，对不对？对吧？
43:54如果这个 check check some 是对的。 ok 那我其实就没有问题。但如果我下次错的那我觉得我这个 jalnews 不完整，我就把它扔掉就可以了。 OK。所以所以 anyway 所以说我们是肯定有办法保证这个节奏的正确性的。
44:09那么把这个东西放在一起之后啊，我们其实就可以就可以这个这个把整个这个文件系统这个把它变得这个这个这个这个正确了。 OK 文件系统操操作这样原数据啊，一定是一定是能保证这样的一个正确 OK。当然一般来说正常的它它实际系统实现的时候，不一定会用 chepson，
44:27它会依赖于这个磁盘的假设，为什么呢？因为你你算 checkon 本身是有性能太销的对吧？又为是我我每次这个狂面的时候，我都得都得都得这个这个都得去多多算一些数据。那这个不是不是很干啊，
44:39这个这个挺挺那啥的嘛，对吧？所以就就是有性能开销。所一般来说大家可能还是依赖于这个厂商的这个这个这个这个这个这个事间。这好，那么有了这样的一套这个比如说结论之后，
44:53对吧？我们这个文件系统就给这个保证了一件事情，就是我这个文件系统的写入就一定是这样一个 automatic 的。比如说这样文件系统呃，这个 reay me ing automatic。有了这样的操作之后，
45:03我们用户对吧就可以去实现这样的一个 shade copy 这个机制。就是我在再做一些可能在出错的时候会挂的这个操作间的吧。我先把这个对的数据 call 一份出来，然后呢我就去改这个这个这个这个我就我就去改那个那个那个来这个数据原数据我些不动对吧？然后做完出出来数据，我全部写完之后，
45:21我再做一个原子的这个切换，然后再把这个这个这个这样的话我这个最终用户看到的这个文件 back，它一定是对的。好好，那么对于一个文件来说，对吧？
45:33那么率 shocopy 实际上是一个这个非常这个经典的这个这个方法啊，但是但是下率 copy 在实际，比如说大家在数据库里面对吧？或者说是这个用的相对来说较少。为什么这样呢？其实销率 copy 有比较一些比较多的这个限制啊限制。
45:50比如说我们来考一下前面我们假设这个例子对吧？比较简单啊，我就是只有一个一个这个这个这个用户对吧？我在做转账。那这个时候呢，我们假设一下我们这个银行对吧？
46:01业务扩展了 OK。我有很多的用户需要同时在做这个这个这个这个转账的这样的一个操作。比如说我有一个 cent，他会做这个从 a 转到 b 对吧？然后又有另一个 cent，他会做做从这个 c 转到 d 这个操作。
46:16那么假设我们但他们修改它是同一个文件，我用同一个文件去存这个所有的银行的这样一个账户。那么我们能不能用这个之前的这个 shadow copy 去支持这样的一个这两个并行的操作。来啊，我们大家想想这个在用 shadow 贝操作，它做起来其实会非常麻烦，
46:35为什么呢？因为假设啊我一个下的 copy，对吧？我用户先把这个 back，比如说我第一个用户先止盈，我先把这个 bank 拷贝了一遍。
46:44这个时候大家想想看，我们如果第二个用户开始跑的话，他一定得基于什么？得基于这个第一个 count 打开的那个文件去改，对不对？但是他不可能另外开一个文件，
46:54为什么？因为如果他另外开一个文件，如果他们两个这个 commit 的时候，我们去这个 curt 一就会把这个看零的这个文件什么覆盖掉，覆盖掉什么现思。我们来来举个例子啊，
47:05举个例子，假设我一开始这个银行对吧？有有有四个这个文件 ABCD，然后他们账号都是一百。然后我这个特零，他先触先触罚，
47:16然后他先做操作，他要什么？要把这个一百块从 clia 转到 b 所以呢他先干了一个什么事，他是先 create 一个这个 shadow 文件 OK，然后他会把这个逐步的去做内存的这个修改啊。我们我们可以认为就是说这个东西它其实是 catch 在这个 OS 的这个内存里的。
47:35这时候我们假设这个时候系统暂停了，比如说操作系统它有 interrup，对吧？它的这个切换切换成了这个 count 一去执行。那么大家想想，我们这个 count 一，
47:46它能不能在这个时候去再创建一个 back temporary 文件，比如说 back temporary 一这个文件，它能不能做这样一件事呢？他大家想想他它做了会怎么样？它做了 bank er 等 temporary 一的时候，它它从哪拷贝呢？
47:59这个时候 back 的这个源文件其实是在这个内存里，对吧？但是这个内存里的这个文件它其实是错的。它它为什么？因为 a 的这个 counent 零的操作，没做做所所如如你你直贝它的话，
48:10你在最后去 cocoswitch，它不就从一个错的这个这个这个 switch 了嘛，错 switch 了，那也就有问题。那我能不能去重新一个，比如说把 copbank temporary 再建个 bank temporary 一呢？
48:22那其实也不对，为什么？因为这个 bank temporary 的这个这个这个这个这个这个这个文件，它也没有去体现这个 curt 一的这样的一个修改，对吧？所以我们会看到你不管你你你能不能直接去新 create bback k amerry，
48:36它显然不行。为什么？因为它这个这个这个这个当时当前的这个 desk，它就并没有考虑到一个的这个 concokind 的操作。那同时呢，我如果这个直接在这个在这个零零的这 cacccash 的基础上去修改，
48:53这个东西也有问题。为什么？因为这个 counite 零它其实没有做完，对吧？没有做完。然后导致一个问题，
48:58就是如果我的这个这个这个 count 一啊，假设我们 cacit 零，因为这个某些问题它被 OS schedule 掉，然后他这个啊这个这个这个长时间没有回来。然后 cact 一这时候大家想想，如果他去提交的话，
49:12会出现什么情况？如果他提交，意味着意味着他把这个缓存这个数据啊去去替换原来的这个 bank，它肯定就是错的。为什么？因为这个这个看 and 看看这个零，
49:22它并没有并没有这样的一个做完，对吧？大家理解吗？就是我如果有多个这个 cand 再去同时操作这样的一个这个这个同一个文件的话，如果你不去在这个 candent 之间去做一个同步的话，你这这个下头 copy 啊，
49:37它其实就没有办法保证这样的一个正确性。所以我们会发现就需要下周 copy 啊，它有三个这个比较大的限制。第一个限制就是它最理想的情况，就是我只有同一时刻，只有一个人在操作。
49:52因为你两个人操作的话，就会到我们刚刚的问题。你要么一个人他不能够做你 name，他得等前面一个做完，那你得去 check dedependency。对，
49:59要么你就会直接去改，就会就会出现这样的一个这个这个这个这个正正正确性的这样的问题。好吧，行，我们先休息一下。然后那个哎你那个你你能帮我看我，
50:32我现在那个四幺二，你能帮我看一下，我这个麦克风没那个机器吵的应该是没声音的，对对看机器显得是这样啊。嗯这个项目里麦克风没声音是吧？对，
51:49就开了，但是那就行。喂喂喂看一下啊，喂哎呀，怎么会声音喂，想退的鱼谁给调这个了，
53:07设尔的频率给改了，一二三四那就的毛利一二三四一二三四，这个又要解改微信，谁的口里好嘞？