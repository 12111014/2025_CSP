00:02必须的是你嗯嗯是嘘宝贝，为什么美女啊？好，我们接着继续 OK。上节课我们先讲就是在系统里面一个很重要的点叫做 authmisty。然后这个这个实现 automatic 具体的用态态一些第一些方法。
05:43比如说像是那个 shadow copy 啊， shadow copy 的话，它依赖于这个在你要正确的实现下头 copy 得依赖于一些系统的这个 automatic。比如说你的文件系统的这些原数据， relme 得是这个 automatic 的。然后弄完之后，
05:56我们其实会让这个个 delow copy 去支持用户态的对一个文件修改的这样的一个 automaicity。但是这样的一个头 shacopy 本质上来说有这个这个这个几个缺陷吧。第一个缺陷。我们上节课结尾讲了，就说如果你有多个用户在操作同一个这个下载 copy 的这个文件的话啊，你你不你得 batch 呃，
06:14你得做一个 group comment，就是你不能不能一个人啊擅自的把一个这个改了一半的文件给提交，他得等当前所有人都做完才提交，那么这个其实是挺不方便的。第二个就是说下周 copy 本身的话，如果你要有多个文件怎么办？
06:28如果我要修改的这个状态，它会呃这个这个这个遍布在整个系统。比如说啊我们数据库里面，对吧？它会有这个用文件去存笔墅。笔墅的话一般来说它是一个文件，
06:38一个 block 啊，存一个别墅的这个 block，然后一个别墅它可能有几十个这个啊这个这个 block。然后你一旦发生了一次 split，对吧？你比如别墅的这个插入，
06:48它可能会修改非常多的这个 block，那你下周 copy 怎么办？你要把这个文件全都得给识别出来，去管理，这个本身是比较复杂的。所以说他你让用户去实现这一套，
06:59其实并不是特别的。这如好。然后第三个就是说你现在拷贝的话，你得去拷贝。整个一开始你得拷贝整个文件。那虽然这个文件系统它会用一些类似于 copon right 的技术。
07:09就是说你拷贝一个文件的时候呢，它其实并不会真实的去去把这个文件去拷贝两份啊，对吧？它可以用一些这样的一个优化，但是它本身其实还是会带来一些这个拷贝的放大。比如说我们的之前的这个例子里面，
07:23对吧？我们假设啊我们要修改这个数据，它只有几个 bit OK。但是你在相对 copy 里面的话，它其实你为了 copy 它得得得把这个几个 bat 是什么？它对一的这个文件的 block 去做一个这个拷贝。
07:36那它其实还是会有一些拷贝的方案。理论上来说，我们最最理想情况下，就是说啊我我去做容错，我不应该是让这个这个数据的访问量去翻倍，对不对？
07:45那么基于这样的话，人们就在去思考一个问题，就是我们有什么样的一个这个更加这个这个通用的这样的一个方法，能够去实现这个任意的这样一个操作。就是前面这样子这种 transfer 啊，它包含了多个这个磁盘数据的这样读写。
08:02这个读写，它可以是在一个文件内，对吧？它有一个是跨多个文件的这样的一个一机器 l 那么这个就是叫做这个 logging 啊 logging，然后 logging 这个基本的这个思路和这个 journal 基基上是一样的啊。就是说 OK 我觉得这 jouroural 的思路再回顾一下什么，
08:20就说我如果一个操作它可能会去破坏机确性，在飞裂的情况下，那怎么办呢？我只需要什么？我只需要在这个这个这个做这个会破坏一致性的操作之前，对吧？
08:30去留下足够多的这个信息，使得说我即使这个发生飞裂了，我也可以从这个信息中去恢复就可以。那么在 GN 六零里面对吧？它的记录的是什么？它记录的是说我这个文件系统里面具体的这个数据，
08:47比如说 i know 的，比如 develop blog 该怎么改？那么这个东西如果我们去把它去做一个泛化的话，它其实可以什么？你一个 log 可以是包含你任意用户定义的这个修改。比如说你在这个我们前面讲这个 transfort 例子，
09:02它就是对于文件账户的修改，它其实是跟文件夹去解耦。对，对不对？对它其实际上样穿测里面，我们对于一个系统来说，
09:09它其实本质上什么？这是对两个账户数据修改。所以你其实本质上什么，你只要在做这个穿梭之前，我去记录下一个这个这个这个这个这个穿梭它具体修改的这个账户。那么其实我其实就可以去仿照这个 generally 的这样的一个方法啊，
09:27去让这个整个 transfer 的这个操作变成这个在分裂的情况下，它也能变成 automisc OK。那这边有一个问题就是说那我站在一个系统呢，比如说我我实现一个 lock 系统对吧，那我到底这个哪些用户的操作是需要做 automatic 的呢？因为我们其实前面可以看到，
09:45就九二九幺六有个问题，就是你在这个操作做完之前，对吧？它是不能够去做真实的修改，所以它操作会有个 delay。第二就是当这个操作全都做完的时候，
09:57它得先什么？先写个 log，就是它有一个词盘，所以它是有一个性能的这样的一个开销的。所以我们其实系统只要当然说我们应该是最小化下面开销，但是我们不能牺牲正确性怎么办呢？
10:07一般来说系统我们会有一个抽象，这个抽象，大家可能听到非常多叫做传参式。这个概念就是用户他告告我这个系统，你这些操作它是要做一个个性的这个操作。因为只有这些操作对吧？
10:20你那个叫什么？那个是比较重要，其他操作的话你就不应该做参式的。因为越少越好会反。因为你就是说喘参式的操作，它是会有这个性能的这个开销。
10:28 tractro k 就有这样一个性的这个概念。然后 transactransacg 呢，它具体其实就是需要用户去标记一下。就是你要比如说 all nothing 的这个开始节点是什么？就是哪一行代码后面的这个操作 or nothing。然后等到这个最后啊这个这个这个这个做完之后，
10:43哎呀，我诉你，你道 OK 有个结束的点，然后开始到这个结束时间点这些操作对吧？我这个传载是会让你变得这个 auto mic。当然除了这个这个这个开始的结束以外呢，
10:55在传输链系统里面一般它会有一个很重要的东西叫做 commit point 啊，它会告诉用户 commit ter 什么意思呢？所谓的 commit point，就是说它其实是一行代码。就是说当这个代码反持行完之后，那么这个系统要保证你这个东西一定一定一定是能 all 而不是 nothing。
11:13为什么呢？大家想如果没有一个这个 commit point 的话，它这这个系统只能保证是吧？只能保证说我这个操作是哦要么哦要么 nothing。但是它它其实并不能告诉你到底是还是 nothing 这样的一个状态。那么这个对于你去实现一个真实系统，
11:26其实不是很友好。为什么？因为比如说大家想我做个转账，对吧？转账的话，我系统肯定是要给用户一个 feedback，
11:33对吧？ feedback 很么那，我什么时候给 feedback 呢？我肯定不能在这个 none nothing 的时候给你 feedback 是吧？为这样的话，我告诉用户，
11:39你转账做完了，如果用户再去检查，他看不到，那这个其实不是很好。所以说我们需要有个点告诉用户，你这个操作一定会变成哦，
11:47那么这个点其实就叫 comment point。那这其实实际上是个概念下来了。那具体的 commcomment point 在哪呢？它其实得开放你的这个不同的系统的实现。我们大家可以看啊，就是同系统统它的个可能画的是不一样的，
11:59但一般来说是能比较好找到的 OK 请。那么那么其实总结一下的话，就是说就是说我们有一个这样一个存载性概念。所以大家去去看这个很多的系统，比如说像 TYS ore 对吧？或者是啥？
12:13它一很多系统它会提供类似于这种北京 commit 这个接口。它这个目的其实就是是为了啊帮助你去标记这个 commit。 and 然后 commit 呃是是看哪些操作，是要 all nething。当然它其实还有一些其他标记，我们后面要 commit e 一下。
12:25当然很多系统的话，它这个你是不需要去标记这个 commit 或者 end。就比如说你像这个跑 CQQ，对吧？ CQU 它每一条默认，它其实就因为就是一个 trtransaction。
12:35如果你是正常开启的话， ok 好，那么假设我们知道了有了这个这个这个 lobgae，有了这个 transsition 的概念之后，对吧？我们其实就可以看到，
12:44就是怎么把它应用到这个这个这个我们之前讲的这样的一个这个这个系统中。我们当然这边还是用这个 transfer 这个就是转账为例啊。但是它这个其实这个例子是这个这个方法非常非常通用的。你不仅是 transfer，对吧？你是对于一种笔数的修改，
13:00或者说你是对于这个更复杂的这个 CQ 语句进行，它其实都可以用类似的方法来去保证。那么它其实要求是什么呢？它是要求就就只有这个这个这个这个两点两点第一点就是说你的这个 update 就是你所有的修改，如果有可能要一定会会造成这个 honnessing，就是出错情况下 honessing 啊不能满足的话，
13:22你必须得 in memory。那在我们这个例子里里面是说我们对于这个数据修改，它是不会去直接更新在这个 n map 的这个速组上。为什么呢？因为你一旦更新的速度上，那么 OS 就有可能通过 flash 把它给去 flash 到这样的一个这个这个磁盘上。
13:37因为当内存不够的时候，会做 flash，这些你可能不知道的。所以我们这边的话就是用一些中间变量，对吧？这个这个在栈上对吧？
13:45那肯定是不会啊，不会被 flash 的。然后确保这个在我能这个确保 general 之前，我这个据是不会修改的。 loo k 然后当我这个所有的操作完了，我就知道说 OK 我最终的这个修改是是做的不是 a 要改成一百，
13:59也要改成一百。那时候呢这个时候我们就跟 general 一样，我们在不一样的什么呢？我们就写了是一个 log 啊，这个 log 它其实包含的就是啊我我我这个这个这个这个这个这个如果这个操作挂的话，我该怎么恢复？
14:13那么这个其实我们就这个这个这个这个这个这个这个 logo 其实也也非常简单，对吧？其实我们只需要什么？只需要有这个这个只需要在这个一个 log 文件里面去写这样的一个一个最后的这个值就行了。那这边有一个问题，就是说我们如会不会出现这个这个这个这个这个这个这个这两个操作对吧？
14:35如果这个这个这个写到一半的时候挂了怎么办呢？大像这个操作这个问题，其实我们在讲九二零的时候讲过，对吧？它是本质上什么？就是我怎么去判断你的这样的一个 log 是否完整，
14:47对吧？那么这边其实就有两种方法，第一种就是你可以去借助。第一，你可以借助文件系统文件系统它的我们以讲九二零零来保证这一个操作是 or nothing。那还有一种方法就是说你可以用 check some 对吧？
14:57你可以用 check check some 去保证说我这个是完整的。总的来说，只要这个 log 是完整的， OK 我们总归是能够去恢复的。 ok OK 就我们可以 HS 二，然后做完之后对吧？
15:09当我们这个 log 做完之后，这个时候我们其实就可以非常安全的去修改这个原始的这样的一个文件的这个内容。因为这时候我们既如果出错的话，我们也可以从这个 log 中去恢复 OK。那这边有个小问题，就是说我们在这个示例的代码里面，
15:26我们其实是没有加 f sink 这样的一个操作的对吧？那大家想一想啊，我们现在这样一个 review lock 里面，它需不需要这样一个 FF sink 这样一个操作呢？需不需要呢？其实其实我们可以发现这个东西你其实不需要要，
15:41因为你没 ssink 它的问题是什么？它的问题只是在于就是说你的这个这个这个这个这个这个这个这个磁盘的数据不是最新的对吧？那不是最新的话，那其实引申的问题就是第一我这个用户读会不会读到不是最新的数据。那这个其实不会的，为什么呢？
15:58因为在操作系统里面它维护了一个东西，就是说只要你这个 n mac 这个文件啊啊，然后你你有特殊的 mod，当然注意有特殊 mode 的话，就是我其他的这个再对这个文件的同一块地去读啊，它一定是如果到的是这个配置始的版本，
16:12而不是这个磁盘上的版本。所以说它首先如果执行的话，它不会去看到这个不不样样。那那么第二个问就就说我如果重启了这个数据不是丢了嘛，那没关系。然后这个时候我们可以去做一个 recovery 啊，
16:26做一个这个这个数据恢复。那 recovery 怎么恢复呢？其实就是说要把什么要把这个没有写回这个这个文件里的这个数据啊给逐个写回。那么大家想这个写回的方式其实非常简单，非常简单，为什么？
16:40因为我们有这个有这个 log，对吧？有这个 log，我们只需要什么？我们只需要便历一遍 log 变一遍 log，然后把 log 里面的这个操作，
16:48比如说 log by 告诉你我文件的个 moof set，对吧？要把它改成多少，那我就对应的去改，对吧？那就那就那就可以了就可以对吧？
16:56所以这个其实就是一个这个这个这个非常简单的，就是有了这个这个相当于其实口这个方法在在这个系统里面叫做 convech logy 啊，其实非常简单方法，它其实包括结论，你这些方法其实本质上都是基于一个一个思想来弄的 OK。好，
17:13那么有了这个 common loloy，现在这边的话，其实我们都已经知道这个怎么用这个 commment loging 来去保证这样的一个正确性 OK。那么接下来的话就是我们前面说了，对于这个用户层，比如你用 transaction 来实现 honesty 的话，
17:29有一个非常重要的点是什么呢？就是说呃我们的这个东西的 comment point 在哪？我们再回来 comment point， comment point 是什么？就是说过了这个点之后，对吧，
17:38你所有的这个操作一定就会是变成 or 就全部而不是一个。那大家想想我们这个代码例子里面，它的 commit point 是啥呢？它的 commment point 大家其实就要想一个问题，就是当我执行了哪行代码之后，我这个操作一定会被恢复，
17:53对吧？那么其实在在我们这个里面只需要执行完这个 pen 这个 think 这个操作一旦告诉我做成功了说明什么？ think 其实就是什么？就我把它 flash 到磁盘里，那说说说明说明什么？这个这个这个我一定是可以从 record 把这个 reduce 回来的。
18:09所以说啊我们这个自己的 componpoint 就这边，那如果我们去实现一个 interactive 的这个 application，对吧？就比如说我用户告诉一个转账，那如在这个 think 之后去加一行这个 notification 就告诉给用户的 feedback，告诉他说 OK 我你这个操操作完啊，
18:24其实就可以了嗯，就可以了。 OK 行，那这边的话就是口碑 logge 啊，它 perblogin 我们做一个简单的总结啊，做个总结。
18:33就是说他实际上什么呢？其实他的思想跟 journal 一样啊，就是说在这个这个这他在我这个用户啊做的这些操作。比如说这些 due state 这个操作啊，就是说其实大家想用户的操作本质上什么，它本质上其实就可以看成一个抽象一个状态机，
18:50对吧？把一个系统从一个旧的状态改变新的状态 OK。然后用户有一系列这个的这个操作，一定要原子的这个状态。 duo 么这个原子做完，在非裂循况下，
19:00它就可能会被的做做。所以怎么怎么做呢？所以在这个 plogg 里面，它会把用户的这些 due 以一个叫做 redue 的这样的一个新形式去记录这个 raduo 啊， raduo。大家这样说，
19:12这这不是不是完全一样。为什么？因为站在用户的角度来说，它的 due 是什么？它的 do 实际上就是我是把这个账号，就他是做这个转账这个操作对吧？
19:21但是我们这个 log 它记录的实际上并不一定要完全跟用户的这个 do 是等价。它只要什么它只需要你的这个这个做完之后啊，就就是就是我一旦宕机之后，我可以从这个这个 log 里面 log 的这个 reduo 里面去把它恢复过来。所以大家看可以看到，就是说在这个这个 due 啊，
19:40它可以是比如说转账，但是 reduce 它可以是一个具体的文件的内容，这两个是完全不一样的 OK。所以基于这样的一个分类的话，就是说所以我们大家也可能会听到这个 log，它会有一些其他的词。
19:53比如说有这种 value log，有这种 operation log，对吧？它的区别什么呢？它的区别无非就是你这个 review 东西是什么？比如说我们举个例子，
20:04像这个这个这个 do 对吧？的本身实际上是就以我们这些例子， dudue 本身它是做一个 transfer 的这个函数。但是我们对于 log 来说的话，我们其实这个这个这个不需要完全一样。那么如果我是记录的是这个 transfer 函数，
20:20它最后做完的这个值就 value。那么这种 log 它其实就是一个 reduo 啊，这 reduo 的这个 value log，那么它干的是什么？就是它它在重做的时候是吧？它干的事情就是把这个啊这个这个写完的这个值去覆盖掉这个这个文件存值啊，
20:36对吧？那么除除了这样一种方式以外，我们其实还能记一种什么样形式的 log。我们还可以记录这个操作本身。比如说我可以记录一下这个穿刺，它一开始之前这个这个这个这个这个这个这个这个这个穿刺一代之前它的状态，
20:51比如 a 和 b 的值。然后呢，我记一下这个操作本身什么是去调用穿刺这个函数，也就是我比如我记一个函数值和穿记入穿刺 a 和 b 的值。那大家想想，有假设我把 log 记成这样的一个形式，
21:04我去 recall 的时候也能恢，对不对？我只需要把 a 和 b 的值值记录到这个初始状态，然后我再去直系调用这个函数指针去做就可以了。这种因为它是需要去做计算，然后来去恢复这样的一个系统的这个新的这个状态。
21:21所以这种这种 log 呢，我们就称为为做 ooperation log 不对系统。然后这两种 olog 到底哪种好呢？但其实没有一个绝对的定论啊，就不同的系统它其实会会去选不同的 log。比如说你这个系统里面对吧？
21:35你修改数据很小，那我用一个 very log 其实就可以，对不对？但如果你这个系统里面修改的数据特别特别多，那这个时候我去记录一个 operation log 的话，它其实会更加高效 OK。
21:46所以但但是这个其实不重要，重要的是什么呢？大家只要记住，就是说我在 log 里面只需要记一个东西。这个东西它不管是 operation 也好，它是 value 也好，
21:54只要能保证什么。我就是我在出错的时候， OK，我一定能恢复到这个原来这个正确的这个 case OK，那其实就可以了。好，
22:02那这个就是啊因为它是基于这个重做这个概念嘛，所以一般也叫做这个这个这个 redo robbin redo robby OK。好，那么这个 reich roce 的话，它有一些这个啊有一些好处，也有一些坏处吧。
22:16那它它的比较好的地方是啊，通常 review login 是效率最高的一种。为什么呢？因为它只需要在这个提交的时候，就是我最后这个要要跨回给用户的时候，我去写一个 batch 这个 log 信息。
22:29而这个信这个写入它一般来说是是个 sequenential， right，就是这个顺序的磁盘就写。那么对于硬件来说，你一个顺序的写是最快啊最快的所是说它的从性能上表达来说是非常好的非常好的。但是呢这种啊 review log 有两个这样的一个问题啊。
22:46第一个问题呢是这个这个这个我们有 regilogic 它的 work，它有一个假设一个假设什么，就是说我所有的数据对吧？得存在这个这个内存里。因为你一旦写 in case，写到原来的数据的话，
22:58那它它如果 boss 掉怎么办？你就没有办法实现那 c 所以说我第一我所有的这个数据一定得包括在这个用户在在这个内存里。第二个呢就是说我们其实可以看到这个方法 work 的这个前提是什么？就是说我得维护一个 log，这个 log 相当于是说我把这个计算对吧？给压拖到一个很小的这样的一个记录里面。
23:17但是即即使是你做了一个很小的这样的一个压缩，对吧？你随着时间增长，比如说我这个系统它运行了年对吧，你这个 log 也会非常非常大。那么大家想想，
23:25很多时候你这个 log 需不需要会这么长？其实不需要的，我们需要有一些方法让这个 log 变得得变小。 OK 啊，那我们先先来讲一下怎么解决这个第一个问题。就是说我这个如果这个 review login，
23:39对吧？如果我内存缓存不下了啊，怎么办啊，怎么办？那么大家想想，我们假设我们什么都不做，
23:47我们有没有办法让这个这个 review looming 能够在这个内存不够的情况下，我可能其实是有一些方法的。比如说操作系统对吧？里面有一个很经典的机制叫做缩屏，大家有印象吗？就缩屏说什么就是我一个操作系统，
24:01它比如说我一个系呃一个一个一个一台机器的话，我可以说我给你有二十个 GB 的这个内存。但实际上我可以给你一个四十个 GB 的这个内存的抽象。为什么？它就我内内存不够，我其实可以把一部分内存数据什么缩不到四百 OK。
24:16然后等这个这个这个我这个内存释放了，我就把这个数据啊 sworp 回来。 OK 这就是一个经典的这样的一个这个操系统。这个抽象。所以大家如果是装机的时候，对吧？
24:26会有印象，比如 u 其 linux x 吧。它它告诉你有一个叫做这个 swap 对你得配置一下，就是说哎我有几十个集啊，我大概配用几十个级的这个磁盘空间，对吧？
24:35去放这个内存啊，大概就有这样的一个概念。那么有了锁品之后，我们其实只需要什么？只需要把这个 freu login 里面，它这个中间的这个修改去缓存到这个内存里面，
24:47对吧？然后我们其实不用做任何事啊，操作系统会帮我们把这个东西给 swap 到磁盘上。那这个不就解决了。这样我们之前之前说的这个这个这个这个这个这个这个这个 redulogic，它依赖于这个在内存把所有数据都放下这样的事情嘛啊那肯那事情显然不会那么美好，
25:05对吧？尤其是操作系统。很多时候你会发现就做操作系统，你发现操作系统帮你解决很很多儿。但其实这些事情解决的其实都不完美，都不完美。
25:12比如说以 swap 来说的话， swap 它其实就有大比较大的问题。第一个问题就是 swap 它其实会用的什么？用的是额外的磁盘空间。大家想一想，我们假设一个极端情况，
25:25就是我要做一个 c 呃这个数据库操作，这个操作会把整个数据库的操作数据都修改一遍，对吧？比如说做一次大表的更新，这个时候大家如果我们用这这个 reloading，然后用 swap 来解决内存不够的问题，
25:37会出现什么情况会出现。其实你如果磁盘的大小远远大于你内存啊，当然这个这个现在可能相对来说少见两代，但是以前内存不大做是吧？这个经常少见啊，或者我们举个极端的例子，
25:50比如说你就是在 GPU 上是吧去做做做这样的 GPU 的内存是比较小的。我去做这样一个操作，就是说什么？就是说这种情况就是最坏情况下，我一我要把这所有的这个数据都缩或可以变到磁盘上，意味着什么？
26:02你的这个磁盘空间其实会会占用翻倍。那一般来说的话，大家如果配缩快，会会会发现就缩快，一般不会让你去特别大。因为配给你配的这个百分之二十、
26:12百分之三十的内存就够了。为什么？因为你这个存盘空间，否则配不是浪费的话，就没没用了嘛。所以我们会发现你去缩短有一个问题，
26:20就是它会有这种很大的这个空间浪费空间浪费。第二个 sworp 其实也有个很大的问题，就是你很难去去这个这个这个这个这个去预估啊，它对你的这个应用性能的影响。大家想想我们 swap 本身是什么？本身是 OO 给你提提供了个更大的内存存抽象，
26:38对不那它带来的代价是什么？但是的代价是，一旦你内存不够了，我就得去做磁盘操作。我得把一些数据写到磁盘里，以及我如果要访问一个被 sworp 包 out 出去的时候，
26:48我得我得用磁磁磁盘上读出来，对不对？那这些额外的磁盘操作，其实大家想都不是应用预期的操作系统在背地里帮你做掉，对不对？这个事情意味着什么？
26:59意味着说我做一个应用啊，我可能跑一行代码看上去很美好，但是一旦 swap 发射啊，我甚至根本都没法去。其实很难分析这个 swap p 对它的这样一能性能的这样子 performance 的这个影响。那么这个对于性能稳定性来说的话，
27:15其实也是非常不友好的。其实就在工业界里面，它有一些说法，就比如说你跑的很慢，或者说你有一些 tale 的这个 latacy 啊，其实跟你的这个机器挂了没啥区。
27:24因为你工工业界很多的这个服务啊，它其实是需要这个这个非常快的时间啊去有响应的。所以我们啊一般来说我们不能够简单的这个依赖于这样的一些 swapping 的这样的一个机制，去实现这个这个扩充内存。那怎么做呢？其实大家想想看，
27:42我们需不需要像 swapping 一样，我们内存不够了，我们把这个内存里缓存数据拷贝出去啊，其实不需要为什么？因为这些数据它改的本身是已经是存在在磁盘里的这样的一个数据了，对不对？
27:55所以我们其实只需要 in case，就是在那个词盘文件原来的文件上去做一些修改，那就可以了。那这样的一个方法虽然直观，它带来的因问是什么呢？就是它没有办法保证 all nothing authastiity，
28:05因为你这个你就 redual loging，对吧？你 review 我只是告诉你个重复，但是一旦我这个被 abort 了，那我就没有办法回滚。那这个时候怎么办呢？
28:14那其实人没有想的方法，其实就很简单嘛。那既然你这个这个有 reduce，那我这个 log 也可以做 unnew，对不对？我只需要像之前一样，
28:25就是说假设啊我这个 transaction OK 做做到一半，做到一半，然后挂了。这个时候我我因为为 u 劣存不够，我写了一些数据到这个磁盘上，那这个时候怎么办呢？
28:36那我就去写一个 NU 的这样一个 log 的 entry，不就可以了吗？不就以了吧。所以这个就是啊一个经典的这个这个 NU loarning 的思想。那它跟之前的这样的一个这个这个这个 review 有什么区别呢？就是 review 我在执行的过程中，
28:55它是不需要写磁盘的，它就到最后的我分的时候需需要写。但用呢我为了确保就是说一旦我这个比如说因为内存不够，对吧？我某一个操作写了磁盘，比如说我把这个数据 in place ed 写到了这个磁盘上 OK。
29:07那这个时候啊我就得什么，我就得去在写之前，我就得写一个这个这个这个 log 的这样内容包含什么？就是要擦除的这样的一个这个数据 OK。那这就是一个 endo rogging 括 enle login 的这样一个一个一个 find 啊，一个一个一个操。
29:25那这边有一个问题，就是我们在这个 log 里面要不要写，要不要要不要写 review 呢？就是我们说前面有一个 reduce，对吧？我们得做一个重做，
29:33我们需不还需需不需要这个 reduce 呢？那理论上来说，我们 reduce 应该是在哪里写啊？应该是在这个所有的操作做完的时候写，对不对？但是很多时候呢，
29:43人们会选择在这个写 n do 的时候也去做一个这个 reduo，为什么呢？为什么呢？因为第一你本身啊你在做一个磁盘操作里面，你去多写一些操作，它是没有害处的这有点像一个 batch 的操作。
29:57为什么？因为磁盘它这个操作，它最大的开销其实是在于这个这个这个这个启动的这个事情。但但一你发射射这个磁盘命令，你多写几个 bit，它其实无所谓。
30:07因为磁盘的它的力度最最小也是要几百个这样办。所以第一就我们写一个 review 的这样一个安全，它其实没有坏处啊，没有坏处啊。第二呢，就是说它会让你的这个这个这个这个这个知货，
30:19就比如说你这个 commit 的时候，就是说会快很多。因为你原本 commit 的时候，我得去写很多的这个 review 的这个东西，对不对？那一旦你在这个 enview 这边的时候，
30:28把这个这个这个这个 review 东西写掉了。那我旁面的时候，我只需要写一个什么 committed 的这个 entry 啊，就写错了。所以呢一般来说啊这个时候的话，我们会需要肯定是需要写这样的一个这个这个这个 review 的这样的一个 ention 啊。
30:44一般是是一个个这样 review ention，它其实就是什么？如果是一个 value log 来说的话，它就是啊这个这个这个这个这个数据的这个新的值。然后最后我们再跟之前的 commention 一样，去这个 commenter 就可以了啊，
30:56就 commenter 就可以了。 OK，那这个其实就是这个就是我们可以通过一个简单的这个扩展，把之前的这样一个 reduunlalog 扩展成一个 unnew review 的这样的一个 log。那么这样的话就能解决这尤其红 i log 它对于这个内存的这个依赖比较大的问题。那么有了这样一套 log 的机制呢，
31:14它其实会带来两两个比较大的影响。两个比较大的影响。什么大的比较影响呢？第一就是我们的 log 会更加复杂啊，更加复杂，为什么呢？
31:23就原本我们这个一个 log，它每个 log 其实就代表什么？就代表了一个这个 transaction 的修改，对不对？就是原本在 redulog 里面，我就是旁面的时候，
31:33我就刷一下，把我的这个 batch 修改全都写到这个 log 里面。但是在这个 endudual log 中呢，它这个这个操作实际上是分离开。为什么？因为我 endudual log 里边我每做一个落盘里里面操作 OK，
31:47我可能都需要去什么修改，这样我都要写一个 entry。那如果我写完一个 entry，我这个切我这操作手把你这个 schedule 掉了。我去切了另一个传参去就会发现我不同的这个 transacch，它的这个 log 啊，
31:59它是就是会交织在整个这个啊 log five low find。那么我们为了区别区分区分，就是说不同的这个这个这个 log entry，对吧？到底是归在哪个 transaction？所以跟这个 regilog 同啊，
32:13我们得去做一个这个这个这个得去做一个这样的一个这个这个这个这个这个这个这个框 ter，我们得有个指针去指向这个符合呃在一个传参式内的这样的一个 log。所以在这个 review new log 里面，它的 log 会啊更加的复杂啊，它不仅包含你的这个传参式，一它还包含你的比如说这几个操作，
32:33那后它还包括这个指针指向前一个这个操作，然后它具体然后包括这个你要 n view 的这个值以及这个 review 的值 OK。那么这边大家可能会好好奇，就是说我们啊我也不是好奇吧，就是说我们这边特定地址的这个值，就是说它要修改这个 order 和 new value，
32:50为什么我们不去给我们？然后我们前面提到它是本账什么，它本账是一个 value log，对吧？就是它这个 log 就的是这个值值。那什什么们这这里面面为要示示讲 value log 不去讲说，
33:01你你你为什么不去记 operation，对吧？它其实也是可以可以是一个 value log，你可以记个操作啊，因为本质是这个 undue 啊，这个事情相对来说复杂一点，
33:11就你要定义一个操作，怎么去 review 是相对容易的对吧？大家想想我，因为我为什么因为你这个 review 这个操作本质上就是 application 做这个逻辑。但是你要想要定义一个 application 的操作会很复杂。因为你要找到这个操作的逆操作，
33:27这个时候不是不是所有的操作都得比较容易的找到这个这个逆操作。所以说在这个 unduundureredup 里边呢，它其实用了很多的实际上是什么？是这种啊，是这种记记不来的啊，我就直接粗暴，
33:40我就直接告诉你你这个穿效果对吧？要其实要要要要要退回到什么值？因为你想看任何的操作，本质上不就是把这个系统从一个状态改成另一个状态嘛，对不对？ OK 行，
33:52那么有了这样的一个操作之后呢，其实我们这个这个这个这个这个整个 log 其实就会啊其实就跟这个之前的差不多。就是我们每做一个磁盘操作的吧，我们写写一个龙干曲，然后最后 comment 啊 comment 这样的一个整体操作 OK。那么这是我们讲这个第一个个来是我的这个 log 会稍微偏的复一点。
34:13我得有一个这个这个 pointer 啊一个指针，去把之前的这些操作选择做一个 link 就是 n dual relog 的第一个点。那第二个点就是说 n dual low 会这个操作，它还会有一个东西会比较麻烦的，是在哪里呢？就是就它的这个出错的这个恢复会更加的这个这个难一点，
34:34为什么呢？因为大家想想，我们对于一个 review log 来说，我其实很简单，我直接什么从头恢复到尾就结束了，对不对？
34:41但是对于一个 new review log 来说呢，我不仅要从头恢复到尾，我还得什么，我还得把一些这个这个要了多少，就是说是 nothing 应应该是 nothing 的这个传单啊给摁丢掉。那么这边就会有一个问题，
34:54就是我到底哪些 transaction 要 endue，还得 do。这个其实是相对于好好弄一点，我只要没有找到一个呃合格的安全，我都可以用淘握。那么更麻烦一点，
35:04就是我到底是要先 endue 还是要先 reduce，对吧？这个其实是是我恢复的时候，我到底是先先重做，还是先那个叫什么先先先去先去抹除呢？因为我比较直观的理解是说，
35:19我应该是先把什么先把这个不要做的东西先给它掉，然后我再去 dureview，对吧？这个比较直观。那我能不能比如说先去 reduce，先去 review，
35:29完我再去 endo 呢的这个其实 endudepends on 什么 depends on 你这个 endo 的这个 state 是不是 reduce 完最新的这样的一个 state。就是如果你 endo 的 state 是一个老的 state 的话，那它其实就可能会这个这个你这个这个操顺序的操作是错。这个 reorder 它是能会导致这权正确性问题。比如说我们可以来举一个例子啊，假设我们有一个 transaction，
35:55一开始我们这个有个数据是 a 对吧？它的值是零，然后有个 transaction，它是把这个 a 从这个零改成，比如说十 OK。然后但是这个 transaction 被 n 丢掉它它 abboth 掉，
36:07就是说它谁做完，它得被 n 丢。然后它这个时候呢，它会有一个 n due entry，就是说它的 old d value 是零零，然后它再改成十 OK，
36:15这是它的一个这个 low entry。这时候如果我有另外一个采摘选 t 二，他把 a 改成了什么？改成了零到这个二十二十。 ok 然后它这里面有个 review 的安全是零到二十，这个是委具。
36:33大家想想在这种情况下的话，如果我在 log 里面对吧？我如果先去 reduce 再去 undo， undo 就会发生什么情况，就会发现最终恢复的实际上是这样的，一个零这个值对吧？
36:47这个值肯显然是一个不对的。这个值为什么呢？因为对于用户来说，它的这个他的这个这个这个这个叫什么这个这个这个这个这个这个这个这个这个他期望的是什么？ TR 已经完成了，那我就最后这个数据库里面值应该是应该是二十。
37:03但是你最终返回的是嘛？其实返回的是，那这个其实是一个错误的错误的这样的一个。所以说我们的恢复得先什么？先 NU 再按 u。但在当然这如果有一些稍微有些全自然线背景的同学可能会说，
37:15对吧？你这个用户 t 一在访问 a 的时候，你理论来说 t 二不应该访问 a 对吧？因为这会有 reconconmation 啊，因为但是通常实现什么呢？就是说我 t 一的时候 a 会拿锁，
37:26但是大家想想会有个问题，就是 t 一啊你即使不是用呃不是这个，因为故障报的，你可能是因为这个这个这个什么呢系统的这样的一个 abort。比如说我这个用户呃不不不不是系统吧，其是用户，
37:39比如说用户我自己就不想做了。这个时候我其实如果把锁给到 t 二的话， t 二还是有可能会拿到这把锁去去做这样的一个执行的啊。没有啊，其实说我这个用户，他这个这个 voo，
37:51他不是因为这个这个这个这个用户，他自己啊自己这个这个这个呃不不是因为系统他挂，而是用用户他自己报。那在这种情况下呢，我们前面说的这种啊 t 一、 t 二的这种执行顺序是有可能出现的。
38:03那么在这种情况下，如果我们这个恢复的时候，没有先去 n view 再去 review 的话，其实就会有就会有问题，就会有问题 OK。所以所以正常情况下的话，
38:16我们这个这个操作啊，它就是说还是先得这个这个这个 n 六，那怎么去判断哪些 transaction n 的那首先就是我们得先什么过一遍这个 dulog 过一遍的 log。然后呢，我们去看一下这个 log 里面哪些 transaction 没有这个 permit entry 啊，如果没有 commit entry 呢，
38:32我们就会给它加一个 bout fly g 啊，把它认为是一个这个 about OK。 about 完之后呢，我们就会去去这个 NU。那 unu 的话，我们得从是吧，
38:41得从后后往前这个 review，对吧？这也很很好理解。因为如果我一个三 trtion，它如果改了一个值同时改两次的话，那其实我们应该恢复的是它一个初始的这样的一个值。
38:52 OK 弄完之后呢，我们其实相当于就是把所有的这个这个这个这个这个这个这个这个这个操作都恢复了。恢复完之后，我们其实做一个这个 review 啊，就可以把这个从后往前 OK 做做恢复下就结束了。好，
39:08对，那到这里为止的话，其实我们就把这个是实现这个 autimicity 一个经典典的这个方啊啊做做这个 lologby 啊，讲的差不多了。那 logby 的话，我们其实实再回回顾一下啊，
39:20回顾再简单总结一下，其实 logby 是什么？就是说我我得保证还是大目标，还是保证 moonst autiicity，然后保证什么 authenity ity 现在是用户的这些操作，就 do do 用户的这样的一个这个这个操作。
39:33然后怎么保证呢？我们其实有两种 log，一种呢是最用的最多的，实际上是这种 review log。就是呢我就告诉你，你执行了我这个 radio log OK，
39:43我就能够复现你这样一个 due 这样的操作了。那么为什么这个 review 和这个 n due 要要区分开来呢？因为你这个 review 本身它可能会有这个 operation， low 它可能是 operation，它也可以是个具体的 value 啊，得具体选什么？
39:56是 depends on 你的这个不同的应用的。然后呢，那么 review 有个问题就是我得缓存所有的修改，那么当我的内存不够怎么办？所以我就得 endue。那 n due 的话，
40:04一般来说就是 n 还是动这里。不好意思啊，没时间我看这个一年级选四啊，这个啊行是嗯是不是是你只会是感觉这个系统好像嗯嗯好像不行啊，好像挂了。这个这个我们等它重启一下吧，
41:52是那听得到吗？保不定没有啊。行，我们就讲到这个这个这个这个 surmmarze 的这个 logging OK 行，那么我们继续啊，那么在大家的角度来说，
42:25对吧？我们比如说你要实现一个系统，或者说你要实现应用 OK。然后你你分析了一下，发现啊我这个应用有这个 autoabicity 的这个问题，对吧？
42:33那么大家很直观的就会想到一个事情，就是说啊我们到底对于我的应用对吧？我到底应该选择这个于 review 的这样一个 loging 好，还是说我去选择就这个的老腿康。那么大家想想对于我们系统来说，对吧？
42:49它有更更更重要的。其实 property 是什么？它 property 其实无非就是说要么就是说就是我我肯定老你这个东西本身是一个辅助的嘛。它它理论上说不应该去影响我们这个用户的执行，也就是什么？就是说我们在用户正常执行的时候，
43:05我这个开销该尽可能的小，对不对？尽可能小。然后这第二个指标是什么？就是说我这个 liability 就是说我这个恢复的时候会不会快，其实也很重要。
43:14因为我的一个这个这个这个传呃一个系统来说，我如果挂了怎么办？那我第一反应肯定是得重启。那重启之后，如果我要跑一个这个恢复，对吧？
43:23如果恢复要做的这个很很很慢，那这个其实也是不大能接受的。所以一般来说我们是不选选这个。所以为什么我们前面说了很多，就是说基于这个 review only 的这种 logging 呢，用的会比较多，
43:36为什么呢？因为 review only 的这个啊它的这个性能就会非常好。它对于任何一个喘性来说，它的它对任何喘载性，它只有一次 logggaclog 的修改，而且是个 secrefical，
43:47 right 非常快，非常快。但是对于这个这个这个这个 a new logging 来说，对吧？ enuroming and euroging 来说的话，这个这个这个你得你每每写一次磁盘，
43:59你还得额外写一次这个磁盘操作。而且因为你既然已经写了磁盘意味着什么，你写磁盘的这个这个 log 的操作，它就不是一个 secursion access，它会变成一个 random access，所以它的性能其实会慢非常多。
44:11而且这个 redule and do rombing 啊，它这个 recovery 本身也会慢很多。因为你这个这个这个这个这个这个这个这个这个我们前面说你的这个 redule 的话，我只需要做一次 scan，我先我只要做一次 review 这个操作就可以了。那对于你这种 midule and do 的话，
44:27我得先扫一遍，先得把磁盘的 log 多扫一遍，先把这个 about about transaction 给标记出来。然后我得先 abbot 先留一遍，然后再捋一遍。那那大家看啊，
44:37其实不管是从这个恢复也好，还是对于这个啊这个这个就这个这个这个这个这个这个这个这个这个个运行也好吧。其实 redulog 的性能都是会更快更快，所以它一般来说在现现代时候里用用最多就 redulog。因为现在的现在的 CPU 啊内存都非常多。现在的 CPU 一般来说像我们服务器上都已经快配到一 GB 的这种啊 CPU 了。
45:00这个其实在以前啊其实比较难想象的。所以基本上这些内存的话，已经能够把大部分的这个 working set 都给都给吃下了 OK 请。那么除了啊这个 renew logging 对吧？以及还有这个 renew logging。那么大家肯定会好奇一件事，
45:15对吧吧，这就是有没有 a new only 的这个 login。就是我这个 log 可以选 new 啊，只有有 new 这个安水。那么大家想想我要有这个嗯 new 的这个这个这个这个 only 的这个 log，我可不可以实现呢？
45:27其实我我第一啊，我肯定是这个这个我在做这个这个这个 endual al log 的时候，我就不去记 review 这个安全，对吧？实际上它就变成一个 new logic，但是你光有 enduroggy，
45:38这这样做是不够的，为什么呢？因为你有数，其实你这个这个这个这个你如果没有 review 的话，你万一普遍成了你这个数据没有完全写完怎么办？所以在 endual 里里边呢，
45:49他除了要建 relothink，他还得做一件什么事啊，我得做一个磁盘。 think 就是说我每一次这个这个这个写用户的这个数据啊，我或者我提交前我得做一次 think 比如说做一次， i think 把所有的这个操作全都啊全都 flash 回去。
46:04那么大家要从 performance 的角度来说的话，它其实就会比我们的这个之前的这样的一个这个这个不管是 n view review 也好，还是 review 也好，它都会差很多。为什么它是要不要 n due review？它会多了一次等这个 think 的这样的操作。
46:19但是 n due review low，它其实不需要等这个啊，我 in place 写的这个数据去刷回去的，所以跟哎哎这这是第一点。然后第二点的话，其实我们刚刚也讨论到，
46:28就是你在这个 endue log 里面去写一个这个 review 全。它其实对于这个性能的影响相对来说是比较小的。因为它本身是 enpick back，在这个 law action。所以基于这两个原因的话啊，几乎没有人去做这样一个这个这个 n dul only 的这样一个东西。
46:43当然 n due on ay only，它在对性能来说它它是比较差。但是它际际上也有些好处，它的好处在哪？就是它的恢复其实非常快，对吧？
46:51因为恢复你只要做一些 n view 就行了，你不用做 review。但是通常来说的话，在它相比较准， due only 其实也没有好好那么多亲。好，
47:02那么到这边为止的话，我们其实就把这个这个这个这个这个这个这个 logging 啊里面这个最基本的这种 log 方法全都讲完了。那么我们现在所有讲的这个 log 方法里面，它还有一件事情没有解决。就是不管你是 NG 围还是五 log， log 也好，
47:18我们现在假设是什么？就是我在系统的运行过程中，对吧？我每来一个操作，我都得去记一个这个 log，然后这就会带来两两个问题。
47:25第一个问题就是我的这个这个 log 文件是越来越大的，意味着什么？就是我系统如一旦重启 OK，它的这个恢复的时间会随着你的什么运行时间逐渐变长，这个其实是一个非常不好的事情。对，
47:40那第二个就是你的 log 如果一直变大的话，那你总会有一天会什么？你的这个磁盘空间会用满，对吧？那这个时候其实其实也是不是特别好的。那么大家想一想，
47:51就是说那大家想想我们怎么去减少 log 的这个大小，或者说我们有没有必要啊把这个整个 log 从头到尾全都记下来了。那想想其实我们 log 本质上是用来干嘛？本质上是用来说，我如果有一个操作作吧，有一一个一一个 transaction 挂了，
48:10或者说一个任何操作挂，我能从复从这个 log 恢复。但是如果这个挂了的 transaction，它的数据已经写到磁盘上了，对不对？那我们是不是就不需要这样的一个它所对应的 log？
48:23对，其实就是基于这样的一个思想。我们就会发现，其实很多时候你的 log 文件虽然记了很多，但你其实大部分 log 都没都没必要。为什么？
48:31因为他们的这个状态已经被体现在了你的具体的这个数据上。 OK。但是有一个问题，就是如果我们没有一些系统的这样的一个机制的话，我怎么知道哪些 log 的这个全它是已经在这个这个就已经被写做完了，哪些还在 enlog 里面得依赖于去这个 review 呢？
48:54略略来越就呢那这个时候我们就需要一个非常经典的这个这个系统的技术叫做切框引。那切框这本质上什么呢？它就是说我是一个显示的这个系统的这样的一个操作 OK，它把系统的这个当前的状态啊打一个包，打一个包，然后把当前打打个包，
49:12然后持久化的存下来。然后这个包这个持久化打的包呢，它一定是一个正确的这样一个状态 OK。那么一旦这个状态是正确之后呢，所有的需要需要一创。这这状状的的东比如说是 log g 其实都是是可以扔掉。
49:27当然这里面这个状态是什么？它是非常抽象，它是点开脏，以具体的系统。比如说在我们之前讲的这个 action 里里面，这个系统的状态就是一堆这个文件就是存数据文件。
49:39那么说你在这个训练大模型里面，你的这个系统的这个状态，对吧？它就是这个参数啊，主要是参数。然后当然你也可以是我们整个 OS 里面运行的这个 process 本身，
49:52它也是可以是系统状态。然后最后就是我们之前讲的这个这个这个这个讲 imagine concerns system 面对吧，我们讲说也有个 log，它也可以去留的这样一个这个这个 state。那么这个 state 其实也是可以分以这样的一个，也也是也是一个，
50:08所以我们要切换包含 OK。那么我们接下来接下来节节课，可能就会跟大家具体介绍一下这几个 case。好吧，那我们先休息会，那就那是一个没有人中，
51:11嗯嗯，是是是这个量求，那你们是嗯，不是他就是，